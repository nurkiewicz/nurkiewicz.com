---
layout: post
title: Enabling JMX in Hibernate, EhCache, Quartz, DBCP and Spring
date: '2011-12-20T19:44:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- hibernate
- spring
- jmx
- ehcache
- quartz
modified_time: '2012-01-04T09:16:18.051+01:00'
thumbnail: http://2.bp.blogspot.com/-5130t6qf51M/TvDWCiDfjXI/AAAAAAAAAgc/_p5Ta0fcSpc/s72-c/Hibernate.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2249268021103317775
blogger_orig_url: https://www.nurkiewicz.com/2011/12/enabling-jmx-in-hibernate-ehcache-qurtz.html
---

Continuing our journey with JMX (see: <a href="http://nurkiewicz.com/2011/03/jolokia-highcharts-jmx-for-human-beings.html">...JMX for human beings</a>) we will learn how to enable JMX support (typically statistics and monitoring capabilities) in some popular frameworks. Most of this information can be found on project's home pages, but I decided to collect it with few the addition of some useful tips.<br /><h4>  Hibernate (with Spring support)</h4>Exposing <a href="http://www.hibernate.org/">Hibernate</a> statistics with JMX is pretty <a href="http://community.jboss.org/wiki/PublishingStatisticsThroughJMX">simple</a>, however some nasty workarounds are requires when JPA API is used to obtain underlying <code>SessionFactory</code><br /><pre class="brush: scala">class JmxLocalContainerEntityManagerFactoryBean() extends LocalContainerEntityManagerFactoryBean {<br /> override def createNativeEntityManagerFactory() = {<br />  val managerFactory = super.createNativeEntityManagerFactory()<br />  registerStatisticsMBean(managerFactory)<br />  managerFactory<br /> }<br /><br /> def registerStatisticsMBean(managerFactory: EntityManagerFactory) {<br />  managerFactory match {<br />   case impl: EntityManagerFactoryImpl =&gt;<br />    val mBean = new StatisticsService();<br />    mBean.setStatisticsEnabled(true)<br />    mBean.setSessionFactory(impl.getSessionFactory);<br />    val name = new ObjectName("org.hibernate:type=Statistics,application=spring-pitfalls")<br />    ManagementFactory.getPlatformMBeanServer.registerMBean(mBean, name);<br />   case _ =&gt;<br />  }<br /> }<br /><br />}<br /></pre>Note that I have created a subclass of Springs built-in <code>LocalContainerEntityManagerFactoryBean</code>. By overriding <code>createNativeEntityManagerFactory()</code> method I can access <code>EntityManagerFactory</code> and by trying to downcast it to <code>org.hibernate.ejb.EntityManagerFactoryImpl</code> we were able to register Hibernate Mbean.<br />One more thing has left. Obviously we have to use our custom subclass instead of <code>org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean</code>. Also, in order to collect the actual statistics instead of just seeing zeroes all the way down we must set the <code>hibernate.generate_statistics</code> flag.<br /><pre class="brush: scala; highlight: [3, 12]">@Bean<br />def entityManagerFactoryBean() = {<br /> val entityManagerFactoryBean = new JmxLocalContainerEntityManagerFactoryBean()<br /> entityManagerFactoryBean.setDataSource(dataSource())<br /> entityManagerFactoryBean.setJpaVendorAdapter(jpaVendorAdapter())<br /> entityManagerFactoryBean.setPackagesToScan("com.blogspot.nurkiewicz")<br /> entityManagerFactoryBean.setJpaPropertyMap(<br />  Map(<br />   "hibernate.hbm2ddl.auto" -&gt; "create",<br />   "hibernate.format_sql" -&gt; "true",<br />   "hibernate.ejb.naming_strategy" -&gt; classOf[ImprovedNamingStrategy].getName,<br />   "hibernate.generate_statistics" -&gt; true.toString<br />  ).asJava<br /> )<br /> entityManagerFactoryBean<br />}<br /></pre>Here is a sample of what can we expect to see in JvisualVM (don't forget to install all plugins!):<br /><br /><br /><a name='more'></a><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-5130t6qf51M/TvDWCiDfjXI/AAAAAAAAAgc/_p5Ta0fcSpc/s1600/Hibernate.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="377" src="http://2.bp.blogspot.com/-5130t6qf51M/TvDWCiDfjXI/AAAAAAAAAgc/_p5Ta0fcSpc/s640/Hibernate.png" width="640" /></a></div><br />In addition we get a nice Hibernate logging:<br /><pre class="brush: plain">HQL: select generatedAlias0 from Book as generatedAlias0, time: 10ms, rows: 20<br /></pre><h4>  EhCache</h4>Monitoring caches is very important, especially in application where you expect values to generally be present there. I tend to query the database as often as needed to avoid unnecessary method arguments or local <i>caching</i>. Everything to make code as simple as possible. However this approach only works when caching on the database layer works correctly. Similar to Hibernate, enabling JMX monitoring in <a href="http://ehcache.org/">EhCache</a> is a two-step process. First you need to expose provided <code>MBean</code> in <code>MBeanServer</code>:<br /><pre class="brush: scala; highlight: 11">@Bean(initMethod = "init", destroyMethod = "dispose")<br />def managementService = new ManagementService(ehCacheManager(), platformMBeanServer(), true, true, true, true, true)<br /><br />@Bean def platformMBeanServer() = ManagementFactory.getPlatformMBeanServer<br /><br />def ehCacheManager() = ehCacheManagerFactoryBean.getObject<br /><br />@Bean def ehCacheManagerFactoryBean = {<br /> val ehCacheManagerFactoryBean = new EhCacheManagerFactoryBean<br /> ehCacheManagerFactoryBean.setShared(true)<br /> ehCacheManagerFactoryBean.setCacheManagerName("spring-pitfalls")<br /> ehCacheManagerFactoryBean<br />}</pre>Note that I explicitly set <code>CacheManager</code> name. This is not required but this name is used as part of the Mbean name and a default one contains <code>hashCode</code> value, which is not very pleasant. The final touch is to enable statistics on a cache basis:<br /><pre class="brush: xml; highlight: 8">&lt;cache name="org.hibernate.cache.StandardQueryCache"<br />    maxElementsInMemory="10000"<br />    eternal="false"<br />    timeToIdleSeconds="3600"<br />    timeToLiveSeconds="600"<br />    overflowToDisk="false"<br />    memoryStoreEvictionPolicy="LRU"<br />    statistics="true"<br />/&gt;<br /></pre>Now we can happily monitor various caching characteristics of every cache separately:<br /><br /><a href="http://3.bp.blogspot.com/-rCKlm6Se-ck/TvDWFyeODYI/AAAAAAAAAgs/75jOfXf7EyQ/s1600/ehcache.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="378" src="http://3.bp.blogspot.com/-rCKlm6Se-ck/TvDWFyeODYI/AAAAAAAAAgs/75jOfXf7EyQ/s640/ehcache.png" width="640" /></a> <br /><br />As we can see the percentage of cache misses increases. Never a good thing. If we don't enable cache statistics, enabling JMX is still a good idea since we get a lot of management operations for free, including flushing and clearing caches (useful during debugging and testing).<br /><h4>  Quartz scheduler</h4>In my humble opinion <a href="http://quartz-scheduler.org/">Quartz scheduler</a> is very underestimated library, but I will write an article about it on its own. This time we will only learn how to monitor it via JMX. Fortunately it's as simple as adding:<br /><pre class="brush: plain">org.quartz.scheduler.jmx.export=true<br /></pre>To <code>quartz.properties</code> file. The JMX support in Quartz could have been slightly broader, but still one can query e.g. which jobs are currently running. By the way the new major version of Quartz (2.x) brings very nice DSL-like support for scheduling:<br /><pre class="brush: scala">val job = newJob(classOf[MyJob])<br />val trigger = newTrigger().<br />  withSchedule(<br />   repeatSecondlyForever()<br />  ).<br />  startAt(<br />   futureDate(30, SECOND)<br />  )<br />scheduler.scheduleJob(job.build(), trigger.build())<br /></pre><h4>  Apache Commons DBCP</h4>Apache Commons <a href="http://commons.apache.org/dbcp/">DBCP</a> is the most reasonable JDBC pooling library I came across. There is also <a href="http://sourceforge.net/projects/c3p0/">c3p0</a>, but it doesn't seem like it's actively developed any more. <a href="http://people.apache.org/%7Efhanik/jdbc-pool/jdbc-pool.html">Tomcat JDBC Connection Pool</a> looked promising, but since it's bundled in Tomcat, your JDBC drivers can no longer be packaged in WAR.<br />The only problem with DBCP is that it does not support JMX. At all (see this <a href="https://issues.apache.org/jira/browse/DBCP-292">two and a half year old</a> issue). Fortunately this can be easily worked around. Besides we will learn how to use Spring built-in JMX support.<br />Looks like the standard <a href="http://commons.apache.org/dbcp/apidocs/org/apache/commons/dbcp/BasicDataSource.html"><code>BasicDataSource</code></a> has all what we need, all we have to do is to expose existing metrics via JMX. With Spring it is dead-simple â€“ just subclass BasicDataSource and add <code>@ManagedAttribute</code> annotation over desired attributes:<br /><pre class="brush: scala">@ManagedResource<br />class ManagedBasicDataSource extends BasicDataSource {<br /><br />    @ManagedAttribute override def getNumActive = super.getNumActive<br />    @ManagedAttribute override def getNumIdle = super.getNumIdle<br />    @ManagedAttribute def getNumOpen = getNumActive + getNumIdle<br />    @ManagedAttribute override def getMaxActive: Int= super.getMaxActive<br />    @ManagedAttribute override def setMaxActive(maxActive: Int) {<br />        super.setMaxActive(maxActive)<br />    }<br /><br />    @ManagedAttribute override def getMaxIdle = super.getMaxIdle<br />    @ManagedAttribute override def setMaxIdle(maxIdle: Int) {<br />        super.setMaxIdle(maxIdle)<br />    }<br /><br />    @ManagedAttribute override def getMinIdle = super.getMinIdle<br />    @ManagedAttribute override def setMinIdle(minIdle: Int) {<br />        super.setMinIdle(minIdle)<br />    }<br /><br />    @ManagedAttribute override def getMaxWait = super.getMaxWait<br />    @ManagedAttribute override def setMaxWait(maxWait: Long) {<br />        super.setMaxWait(maxWait)<br />    }<br /><br />    @ManagedAttribute override def getUrl = super.getUrl<br />    @ManagedAttribute override def getUsername = super.getUsername<br />}<br /></pre>Here are few data source metrics going crazy during load-test:<br /><br /><a href="http://4.bp.blogspot.com/-JIYH78v8Szw/TvDWFBssJHI/AAAAAAAAAgk/pGTrLYdWtFE/s1600/dbcp.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="588" src="http://4.bp.blogspot.com/-JIYH78v8Szw/TvDWFBssJHI/AAAAAAAAAgk/pGTrLYdWtFE/s640/dbcp.png" width="640" /></a> <br /><br />JMX support in the Spring framework itself is pretty simple. As you have seen above exposing arbitrary attribute or operation is just a matter of adding an annotation. You only have to remember about enabling JMX support using either XML or Java (also see: <a href="https://jira.springsource.org/browse/SPR-8943">SPR-8943 : Annotation equivalent to &lt;context:mbean-export/&gt; with @Configuration</a>):<br /><pre class="brush: xml">&lt;context:mbean-export/&gt;<br /></pre>or:<br /><pre class="brush: scala">@Bean def annotationMBeanExporter() = new AnnotationMBeanExporter()<br /></pre>This article wasn't particularly exciting. However, the knowledge of JMX metrics will enable us to write simple yet fancy dashboards in no time. Stay tuned!