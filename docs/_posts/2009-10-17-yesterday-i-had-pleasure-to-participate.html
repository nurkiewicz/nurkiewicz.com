---
layout: post
title: Compile- vs load-time weaving performance in Spring
date: '2009-10-17T19:57:00.007+02:00'
author: Tomasz Nurkiewicz
tags:
- conferences
- aop
- spring
- aspectj
modified_time: '2009-10-18T11:00:14.535+02:00'
thumbnail: http://3.bp.blogspot.com/_P3ewsGQzHn0/StoG7Sa5RdI/AAAAAAAAAOQ/erhb1285nyU/s72-c/perf.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-824546586682370291
blogger_orig_url: https://www.nurkiewicz.com/2009/10/yesterday-i-had-pleasure-to-participate.html
---

Yesterday I had pleasure to participate in <a href="http://09.jdd.org.pl/">Java Developers’ Day</a> in Kraków, Poland. It was a great experience to see <a href="http://wmrichards.com/">Mark Richards</a> (author of <a href="http://www.amazon.com/Java-Message-Service-Mark-Richards/dp/0596522045">Java Message Service</a>) and <a href="http://www.davisworld.org/">Scott Davis</a> (<a href="http://www.amazon.com/Groovy-Recipes-Greasing-Pragmatic-Programmers/dp/0978739299">Groovy Recipes</a>) giving a talk. Also I really enjoyed <a href="http://unimplemented.blogspot.com/">Wojciech Seliga</a> speak about code review. He works for Atlassian and shown a bit of Crucible, but his main point was that code review is not about looking for bugs made by other developers. It is rather an agile process of getting to know the code.<br /><br />I could write much more about JDD, of course starting from "<span style="font-style: italic;">you should regret if you haven’t been there</span>", but I am quite sure that you are already waiting for the main topic. Let’s just say, that there is a chance that JDD will take 2 days in the next year and I will do my best to be there.<br /><br /><br />After reading my <a href="http://nurkiewicz.com/2009/10/ddd-in-spring-made-easy-with-aspectj.html">previous post</a> one of my friends asked about performance of creating objects marked as <span style="font-family:courier new;">@Configurable</span>. He wants to inject <span style="font-family:courier new;">EntityManager </span>or other custom dependencies to his JPA POJOs but is concerned about performance. Because many thousands of objects are created manually or by Hibernate during the application life, overhead introduced by Spring aspect injecting dependencies each time new operator is called may be significant. There is no sense in talking about performance, I will simply measure everything!<br /><br />But before we start our performance comparison test: I haven’t yet explained how to enable compile-time weaving instead of load-time. First a word of explanation: CTW weaves aspect during compilation phase when building your application using Maven. LTW does that when the class is loaded within the JVM. Because both approaches should weave the same aspect and produce the same code, true performance of object creation should be the same despite the weaving method. But we will check that out too.<br /><br />As you probably expect, switching from LTW to CTW is only a matter of configuration, no code must be changed. All you need to do is remove LTW Spring agent from <span style="font-family:courier new;">pom.xml</span> <span style="font-family:courier new;">(surefire plugin</span> configuration) and references to the agent when running JVM (on server and unit tests from your IDE). When  you got rid of LTW, enable CTW in no time (<span style="font-family:courier new;">pom.xml</span>):<br /><br /><pre name="code" class="xml">&lt;plugin&gt;<br /> &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br /> &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;<br /> &lt;configuration&gt;<br />   &lt;complianceLevel&gt;1.6&lt;/complianceLevel&gt;<br />   &lt;aspectLibraries&gt;<br />     &lt;aspectLibrary&gt;<br />       &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />       &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;<br />   &lt;/aspectLibrary&gt;<br /> &lt;/aspectLibraries&gt;<br /> &lt;/configuration&gt;<br /> &lt;executions&gt;<br />  &lt;execution&gt;<br />    &lt;goals&gt;<br />      &lt;goal&gt;compile&lt;/goal&gt;<br />      &lt;goal&gt;test-compile&lt;/goal&gt;<br />    &lt;/goals&gt;<br />  &lt;/execution&gt;<br />&lt;/executions&gt;<br />&lt;/plugin&gt;</pre><br /><br /><br />Nothing to be explained, maybe except the complianceLevel, which corresponds to your JDK version. You must also replace:<br /><br /><pre name="code" class="xml">&lt;context:load-time-weaver/&gt;</pre><br /><br />with:<br /><br /><pre name="code" class="xml">&lt;context:spring-configured/&gt;</pre><br /><br />In your Spring context configuration file.<br /><br />Now, when we know how to switch back and forth from LTW to CTW, let’s run some performance tests. I used Reservation class introduced in previous posts for testing creation performance, but I added three dependencies via transient fields in this POJO:<br /><br /><br /><pre name="code" class="java">@PersistenceContext<br />private transient EntityManager em;<br /><br />private transient TicketService ticketService;<br /><br />@Resource<br />private transient JavaMailSender javaMailSender;</pre><br /><br />The TicketService is being injected using the configuration below:<br /><br /><pre name="code" class="xml">&lt;bean class="com.blogspot.nurkiewicz.reservations.Reservation" scope="prototype" lazy-init="true"&gt;<br /> &lt;property name="ticketService" ref="ticketService"/&gt;<br />&lt;/bean&gt;</pre><br /><br />By testing three beans with different injection techniques I wanted to find out, whether the type of injection has different performance impact.<br /><br />The test scenario was to first create 1000 instances of Reservation class to warm up JVM and then measure the time of creating 50 thousand instances and putting them in previously created array to partially prevent GC. Objects were created in the following weaving environment:<br /><br /><ul><li><span style="font-style: italic;">none </span>– no weaving has been applied</li><li> <span style="font-style: italic;">CTW (no dependencies)</span> – CTW enabled and <span style="font-family:courier new;">@Configurable</span> annotation added to Reservation class, but no dependencies injected (<span style="font-family:courier new;">@PersistenceContext</span>, <span style="font-family:courier new;">@Resource</span> and XML configuration removed)</li><li> <span style="font-style: italic;">CTW (EM)</span> – CTW with EntityManager injected</li><li> <span style="font-style: italic;">CTW (&lt;property&gt;)</span> – CTW with dependency configured in Spring XML context file being injected</li><li> <span style="font-style: italic;">CTW (@Resource)</span> – CTW with dependency autowired using standard @Resource annotation</li><li> <span style="font-style: italic;">CTW (all)</span> – CTW with all three dependencies listed above injected</li><li> <span style="font-style: italic;">LTW (no dependencies)</span> – like above but using LTW</li><li> <span style="font-style: italic;">LTW (EM)</span> – like above but using LTW</li><li> <span style="font-style: italic;">LTW (&lt;property&gt;)</span> – like above but using LTW</li><li> <span style="font-style: italic;">LTW (@Resource)</span> – like above but using LTW</li><li> <span style="font-style: italic;">LTW (all)</span> – like above but using LTW</li></ul><br />Each test creating 50K instances has been repeated 8 times with very low standard deviation. I measured the time it took JVM to create all the instances and scaled it to the number of instances being created per second. Bigger value is better.<br /><br />Probably you start to feel bored so I skip <a href="http://sites.google.com/site/nurkiewicz/Home/zalaczniki/ctwltw_results.pdf">detailed results</a> and give you this nice chart:<br /><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_P3ewsGQzHn0/StoG7Sa5RdI/AAAAAAAAAOQ/erhb1285nyU/s1600-h/perf.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 130px;" src="http://3.bp.blogspot.com/_P3ewsGQzHn0/StoG7Sa5RdI/AAAAAAAAAOQ/erhb1285nyU/s200/perf.png" alt="" id="BLOGGER_PHOTO_ID_5393631119356282322" border="0" /></a><br />The results are a bit surprising for me for two reasons. First, creating objects marked as <span style="font-family:courier new;">@Configurable</span> is less than 4 times slower than creating ordinary objects using new operator. I assumed that creating new objects on heap is so greatly optimized that adding the overhead of Spring aspect scanning the class and trying to inject dependencies to completely unknown class would be tremendous. But even if single dependency is being injected using <span style="font-family:courier new;">@Resource</span> or XML configuration, creation time is reasonable. In fact, 4-5 times slower when the object is created by Hibernate is something that is almost impossible to measure and see in real environment – simply database and network connectivity brings much bigger overheads, making injection time insignificant. Also, just as I thought, there is no big difference between LTW and CTW when there comes to performance, so use whichever you like. Or at least do not take performance into account when deciding.<br /><br />The second surprise, negative this time, was the time of creating objects with injected <span style="font-family:courier new;">EntityManager</span>. Somehow it is almost 30 times slower than normal object creation and 6 times slower than injecting other custom Spring beans. It is not the subject of this post to find out what happens behind the scenes with <span style="font-family:courier new;">EntityManager </span>(probably Spring does some additional magic with EntityManager proxy, maybe I will investigate this in the future), but the results are disturbing.<br /><br />To summarize: using <span style="font-family:courier new;">@Configurable</span> annotation and injecting your Spring beans probably won’t be performance issue in your project. Of course my test isn’t definite and you should check this in your particular case, but the benefits of Spring injection into domain objects can’t be overestimated. But be careful when injecting EntityManager directly to your domain objects – the performance impact is somewhat significant and when creating thousands of objects your application might slow a little bit.<br /><br /><p>Test environment: <span style="font-style: italic;">Intel Core Duo T2050 1.6 GHz, 1 GiB RAM, Windows XP SP2, JDK 1.6.0_14</span></p><p><span style="font-style: italic;"><br /></span></p>