---
layout: post
title: Creating prototype Spring beans on demand using lookup-method
date: '2010-08-05T23:44:00.006+02:00'
author: Tomasz Nurkiewicz
tags:
- spring
- intellij idea
- cglib
modified_time: '2011-03-30T19:04:36.893+02:00'
thumbnail: http://1.bp.blogspot.com/_P3ewsGQzHn0/TFsxE3JoW0I/AAAAAAAAAWg/_OwefRkJmJo/s72-c/IntelliJ+IDEA+lookup-method+inspection.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8577147422073830592
blogger_orig_url: https://www.nurkiewicz.com/2010/08/creating-prototype-spring-beans-on.html
---

The strength of the Spring Framework is its emphasis on stateless services. Being totally against OOP, this approach has many pragmatic advantages, with low memory consumption, no cost of pooling and multithreaded safety at the top of the list. But sometimes you really need the context and having non-singleton beans with different state attached to each instance makes your code a lot cleaner and easier to read. Let’s start from stateless code and do some consecutive refactorings.<br /><br />Every time a new flight is entered into the system, we validate it with multiple business rules using <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> class (please forgive my complete absence of domain knowledge):<br /><br /><pre class="brush: java">public class FlightValidator {<br /><br />@Resource<br />//Many services<br /><br />public boolean validate(Flight flight) {<br />return validateSourceAndTarget(flight) &amp;&amp;<br />isAirplaneAvailable(flight) &amp;&amp;<br />isAirportFree(flight) &amp;&amp;<br />!buyerBlackListed(flight) &amp;&amp;<br />reservationLimitReached(flight);<br />}<br /><br />//Many more methods<br /><br />}</pre><br /><br />There is something really disturbing in this code. The context (<span style="font-family: &quot;courier new&quot;;">Flight </span>instance being validated) is passed over and over through subsequent method invocations. On the other hand, because the context exists on the stack (which is thread local in the contrary to the heap), the class is thread safe by its definition. But still the code is so awkward that having <span style="font-family: &quot;courier new&quot;;">flight</span> field accessible to every method in the class (and sacrificing thread safety) is very tempting*. The easiest solution is to have a new, separate instance of <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> every time we need to validate a flight. So we create <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> bean with prototype scope:<br /><a name='more'></a><br /><br /><pre class="brush: xml">&lt;bean id="flightValidator" class="com.blogspot.nurkiewicz.lookup.FlightValidator" scope="prototype" lazy-init="true"/&gt;</pre><br /><br />Now, every time there is a need for flight validation, we should ask Spring to create a new instance of <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> (imagine the class has multiple dependencies on other beans, has some aspects woven, etc. – we can’t simply use new operator). The easiest way to do this is to implement <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/BeanFactoryAware.html"><span style="font-family: &quot;courier new&quot;;">BeanFactoryAware</span></a> and use injected <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><span style="font-family: &quot;courier new&quot;;">BeanFactory</span></a> to fetch any bean from the client code:<br /><br /><pre class="brush: java; highlight: [10]">public class SomeSpringBean implements BeanFactoryAware {<br />private BeanFactory beanFactory;<br /><br />@Override<br />public void setBeanFactory(BeanFactory beanFactory) throws BeansException {<br />this.beanFactory = beanFactory;<br />}<br /><br />//client code:<br />FlightValidator validator = beanFactory.getBean("flightValidator", FlightValidator.class);<br /><br />}</pre><br /><br />Every time the code in line 10 is executed, new instance (prototype scope) of <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> is created and returned. Maybe the goal is achieved, but the solution is pretty cumbersome. Not only we tie ourselves with the Spring API, but also we fetch bean by name (which is very verbose). Last but not least, prior to Spring 3.0 the <span style="font-family: &quot;courier new&quot;;">getBean()</span> always returned <span style="font-family: &quot;courier new&quot;;">Object</span> instance, forcing client code to downcast the result.<br /><br />I used this pattern several times, always being disgusted. But then, by accident, I found <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-lookup-method-injection">lookup-method</a> feature in Spring docs. BTW Spring documentation is a gift... and a curse (like <a href="http://www.imdb.com/title/tt0312172/quotes">detective Monk</a> used to say) -  so exhaustive and comprehensive that it’s hard to read it and get to know with everything. But back to Spring – the idea behind the lookup method is to drop BeanFactoryAware interface and simply create abstract no-arg method that returns bean of type we are willing to create (i.e. <span style="font-family: &quot;courier new&quot;;">FlightValidator</span>). Now the best part: we just tell Spring declaratively we want this abstract method to create FlightValidator instance every time it is called and Spring will implement this method at runtime (using <a href="http://cglib.sourceforge.net/">CGLIB</a>) for us! Just look how easy it is comparing to <span style="font-family: &quot;courier new&quot;;">BeanFactory</span> approach:<br /><br /><pre class="brush: java">public abstract class SomeSpringBean {<br /><br />protected abstract FlightValidator createValidator();<br /><br />//client code somewhere in the class:<br />FlightValidator validator = createValidator();<br />}</pre><br /><br /><br /><pre class="brush: xml; highlight: 4">&lt;bean id="flightValidator" class="com.blogspot.nurkiewicz.lookup.FlightValidator" scope="prototype" lazy-init="true"/&gt;<br /><br />&lt;bean id="someBean" class="com.blogspot.nurkiewicz.lookup.SomeSpringBean"&gt;<br />&lt;lookup-method name="createValidator" bean="flightValidator"/&gt;<br />&lt;/bean&gt;</pre><br /><br />The 4th line of Spring XML is essential. We basically say: <i>hey, createValidator method is abstract and every time it is called, return new instance (using lookup-method and BeanFactory with singleton beans doesn’t make any sense) of bean named flightValidator</i>. And Spring is clever enough to harness CGLIB and dynamically implement <span style="font-family: &quot;courier new&quot;;">createValidator()</span> method instead of trying to instantiate abstract class. Pretty awesome!<br /><br />This approach looks much nicer, does not involve the Spring API or force us to hardcode bean name in Java code. Now, when we have a fresh new instance of <span style="font-family: &quot;courier new&quot;;">FlightValidator</span>, we can perform some refactorings to take advantage of class instance variables:<br /><br /><pre class="brush: java">private Flight flight;<br /><br />public boolean validate(Flight flight) {<br />this.flight = flight;<br />return validateSourceAndTarget() &amp;&amp;<br />isAirplaneAvailable() &amp;&amp;<br />isAirportFree() &amp;&amp;<br />!buyerBlackListed() &amp;&amp;<br />reservationLimitReached();<br />}</pre><br /><br />First, we assign flight to a private field available for all validating methods. Now, every method can access this field and there’s no need for passing arguments all over. But sadly, it is just the beginning. One day we had to make all validating methods publicly accessible in order to call them separately. But now we need some way to initialize <span style="font-family: &quot;courier new&quot;;">flight</span> field and we certainly don’t want to go back to flight parameter in every method and flight field assignment at the beginning of each one. There is another accidental disadvantage of our solution: if particular instance of FlightValidator leaks to some other thread, this thread can call <span style="font-family: &quot;courier new&quot;;">validate()</span> method with other <span style="font-family: &quot;courier new&quot;;">Flight</span> causing race condition. If only we could make <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> immutable by passing <span style="font-family: &quot;courier new&quot;;">flight</span> only once, binding <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> permanently with this flight and being able to easily call every public validation method...<br /><br /><pre class="brush: java">private final Flight flight;<br /><br />public FlightValidator(Flight flight) {<br />this.flight = flight;<br />}<br /><br />public boolean validate() {<br />return validateSourceAndTarget() &amp;&amp;<br />isAirplaneAvailable() &amp;&amp;<br />isAirportFree() &amp;&amp;<br />!buyerBlackListed() &amp;&amp;<br />reservationLimitReached();<br />}</pre><br /><br />This is it! Our Holy Object Oriented Grail! Compiler forces us to pass valid flight instance (you may add validation to assert that) and after the <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> is created, it will always reference the same flight. API is simple, class is thread safe, everybody is happy... Except our favorite framework... According to the documentation, lookup method discussed above mustn’t have any arguments. But suppose I don’t read the docs and simply add <span style="font-family: &quot;courier new&quot;;">Flight</span> parameter to lookup method and expect the magic to happen:<br /><br /><pre class="brush: java">protected abstract FlightValidator createValidator(Flight flight);</pre><br /><br />I thought to myself that Spring will transparently pass lookup method parameter(s) to the FlightValidator constructor matching its declaration – and we have just created such a constructor. I run the application and it starts fine, but when I try to call lookup method I get:<br /><br /><pre class="brush: plain">java.lang.AbstractMethodError: com.blogspot.nurkiewicz.lookup.SomeSpringBean.createValidator(Lcom/blogspot/nurkiewicz/lookup/Flight;)Lcom/blogspot/nurkiewicz/lookup/FlightValidator;</pre><br /><br />Seems like Spring ignored lookup method with arguments and simply didn’t implement it using CGLIB. I would expect context startup to fail or at least warning that lookup won’t work (I even created <a href="https://jira.springframework.org/browse/SPR-7426">SPR-7426</a>) but sadly only unit tests can prevent you from such a mistake. And IntelliJ IDEA:<br /><br /><a href="http://1.bp.blogspot.com/_P3ewsGQzHn0/TFsxE3JoW0I/AAAAAAAAAWg/_OwefRkJmJo/s1600/IntelliJ+IDEA+lookup-method+inspection.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5502045329356774210" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/TFsxE3JoW0I/AAAAAAAAAWg/_OwefRkJmJo/s400/IntelliJ+IDEA+lookup-method+inspection.png" style="cursor: pointer; display: block; height: 118px; margin: 0px auto 10px; text-align: center; width: 400px;" /></a><br /><br /><br />We might work around this limitation and create some sort of <span style="font-family: &quot;courier new&quot;;">init(Flight flight)</span> method instead of constructor. But what if we forget to call this method or call it twice? Thread safety, immutability and consistency are lost... Spring does not allow us to parameterize creation of prototype beans created by lookup method but come on, it’s open source and I am a programmer, I wouldn’t sleep at night if I at least didn’t try...<br /><br /><h4>Patching Spring...</h4><br /><br />The stacktrace following <a href="http://download-llnw.oracle.com/javase/6/docs/api/java/lang/AbstractMethodError.html">AbstractMethodError</a> didn’t help me but after turning on verbose Spring logging I immediately spotted <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/support/CglibSubclassingInstantiationStrategy.html"><span style="font-family: &quot;courier new&quot;;">org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy</span></a> class that is responsible for dynamic creation of abstract lookup method code and other features using CGLIB. But first I had to discover why my parameterized lookup method is ignored by this mechanism. After few minutes of studying I came across <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/support/LookupOverride.html"><span style="font-family: &quot;courier new&quot;;">org.springframework.beans.factory.support.LookupOverride</span></a> class with method:<br /><br /><pre class="brush: java">@Override<br />public boolean matches(Method method) {<br />return (method.getName().equals(getMethodName()) &amp;&amp; method.getParameterTypes().length == 0);<br />}</pre><br /><br />So I changed too rigorous constraint and removed no arguments condition:<br /><br /><pre class="brush: java">@Override<br />public boolean matches(Method method) {<br />return method.getName().equals(getMethodName());<br />}</pre><br /><br />I quickly run my unit tests and now Spring generated code for my abstract lookup method (<span style="font-family: &quot;courier new&quot;;">AbstractMethodError</span> is gone) but still framework tries to instantiate <span style="font-family: &quot;courier new&quot;;">FlightValidator</span> bean using no-arg constructor, ignoring lookup method parameters. First success, another challenge.<br /><br />Half hour later I finally make out how CGLIB works and how Spring uses it. I’ll skip CGLIB tutorial (maybe we’ll come back to this great library later), enough is to say that every time we call lookup abstract method, CGLIB synthesized class calls provided callback method, that for lookup method looks like this (excerpt from LookupOverrideMethodInterceptor  inner class in org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator):<br /><br /><pre class="brush: java; highlight: 3">public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {<br />LookupOverride lo = (LookupOverride) beanDefinition.getMethodOverrides().getOverride(method);<br />return owner.getBean(lo.getBeanName());<br />}</pre><br /><br />Third line is crucial. We take bean name defined in Spring XML and fetch it from <span style="font-family: &quot;courier new&quot;;">BeanFactory</span> named <span style="font-family: &quot;courier new&quot;;">owner</span>. But hey, what is that, args array argument?!? And take a look at overloaded <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean%28java.lang.String,%20java.lang.Object...%29"><span style="font-family: &quot;courier new&quot;;">getBean(String name, Object... args)</span></a> method, ready to be used! I’ll give it a try and see what happens:<br /><br /><pre class="brush: java; highlight: 3">public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {<br />LookupOverride lo = (LookupOverride) beanDefinition.getMethodOverrides().getOverride(method);<br />return owner.getBean(lo.getBeanName(), args);<br />}</pre><br /><br />Can you spot the difference? I run unit tests and can’t believe my own eyes – it works! It’s amazing, I only changed – not even added, changed! – two lines of code and unlocked this great feature. Now I can pass arbitrary set of parameters to the lookup method and they are going to be passed straight to the constructor of newly created object. Finally the lookup method idea makes sense – create new, fully customized and initialized object every time you request it. No need for further setup and danger of data inconsistency. Long live the Spring Framework!<br /><br />If you like this feature, I opened <a href="https://jira.springframework.org/browse/SPR-7431">SPR-7431</a> ticket, watch it and vote for it.<br /><br /><br /><br />* one might argue that <span style="font-family: &quot;courier new&quot;;">validate()</span> should actually be a method of <span style="font-family: &quot;courier new&quot;;">Flight</span> and is an example of <a href="https://industriallogic.com/gh/submit?Action=PageAction&amp;album=recognizingSmells&amp;path=recognizingSmells/moreUncommonSmells/featureEnvyExample&amp;devLanguage=Java"><span style="font-style: italic;">Feature Envy</span></a> (see <a href="http://martinfowler.com/">Martin Fowlers</a>’ <a href="http://www.amazon.com/gp/product/0201485672?ie=UTF8&amp;tag=javaandneighb-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0201485672">book</a>) code smell. I already <a href="http://nurkiewicz.com/2009/10/ddd-in-spring-made-easy-with-aspectj.html">discussed</a> how to get rid of this smell using Spring