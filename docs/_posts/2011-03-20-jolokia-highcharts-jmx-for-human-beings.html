---
layout: post
title: Jolokia + Highcharts = JMX for human beings
date: '2011-03-20T19:46:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- jquery
- jfreechart
- javascript
- jmx
- jolokia
- monitoring
- jqplot
- highcharts
modified_time: '2011-11-17T19:17:16.718+01:00'
thumbnail: https://lh5.googleusercontent.com/-H3nlHGAfKN0/TYZJODIuekI/AAAAAAAAAaQ/cA8_tVMcqio/s72-c/single.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8563938229337803058
blogger_orig_url: https://www.nurkiewicz.com/2011/03/jolokia-highcharts-jmx-for-human-beings.html
---

<div>Java Management Extensions (<a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX</a>) is a well established, but not widespread technology allowing to monitor and manage every JVM. It provides tons of useful information, like CPU, thread and memory monitoring. Also every application can register its own metrics and operations in so called <a href="http://download.oracle.com/javase/6/docs/api/javax/management/MBeanServer.html">MBeanServer</a>. Several libraries take advantage of JMX: <a href="http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/jmx/StatisticsServiceMBean.html">Hibernate</a>, <a href="http://ehcache.org/documentation/jmx.html">EhCache</a> and <a href="http://logback.qos.ch/manual/jmxConfig.html">Logback</a> and servers like <a href="http://tomcat.apache.org/tomcat-7.0-doc/monitoring.html">Tomcat</a> or <a href="http://www.mulesoft.org/documentation/display/MULE3USER/JMX+Management">Mule ESB</a>, to name a few. This way one can monitor ORM performance, HTTP worker threads utilization, but also change logging levels, flush caches, etc. If you are creating your own library or container, JMX is a standard for monitoring, so please don't reinvent a wheel. Also Spring has a wonderful support for <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/jmx.html">JMX</a>.</div><div><br /></div><div>If this standard is so wonderful, why aren't we using it all day long? Well, history of JMX reaches the dark ages of J2EE. Although the specification isn't that complicated, there are at least two disadvantages of JMX effectively discouraging people from using it. First one lies on the server side. At the foundation of Java Management Extensions is an MBeanServer where you register MBeans. Each MBean exposes its properties (attributes) and operations for external access. This is fine (especially when Spring is used: 1 line of XML + two annotations), but there's a catch. By default the MBeanServer exposes itself via RMI, which is certainly not the top XXI century protocol...</div><div><br /></div><div>The second drawback of JMX lies on the client side. <a href="http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html">JConsole</a>, although not terrible, has very limited functionality. If we want to present our JMX-enabled application to the customer, showing JConsole as a client is a bit embarrassing. It is capable of showing graphs, but you cannot display more than one attribute at the same composite graph and you also can't observe attributes from different MBeans at the same time. Last but not least, again, we're living in the XXI century, Swing client? Weird RMI port? What about Web 2.0 rave? Knowing how much I love charts (and how data visualization is important for diagnosing and correlating facts) I felt really disappointed by JConsole capabilites. And the only <a href="http://www.jmanage.org/">rival</a> of JConsole seems dead.</div><h5 class="western">Jolokia – bridge JMX over HTTP</h5><br />I knew exactly what I wanted: HTTP transport for JMX server, so that I can easily access MBeanServer from outside without the RMI mess. <a href="http://www.jolokia.org/features-nb.html">Jolokia</a> meets my expectations perfectly. This small library (about 170 kiB) connects to a given MBeanServer and exposes it via REST-like interface. Just deploy the jolokia.war file on your servlet container and use whatever HTTP client you want to monitor your JVM!<br /><br /><pre class="brush: plain"><br />$ curl localhost:8080/jolokia<br />{<br />  "request" : { "type" : "version" },<br />  "status" : 200,<br />  "timestamp" : 1300561261,<br />  "value" : {<br />      "agent" : "0.83",<br />      "info" : {<br />          "product" : "tomcat",<br />          "vendor" : "Apache",<br />          "version" : "7.0.10"<br />        },<br />      "protocol" : "4.1"<br />    }<br />}<br /><br /><br />$ curl localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage<br />{<br />  "request" : {<br />      "attribute" : "HeapMemoryUsage",<br />      "mbean" : "java.lang:type=Memory",<br />      "type" : "read"<br />    },<br />  "status" : 200,<br />  "timestamp" : 1300561367,<br />  "value" : {<br />      "committed" : "169607168",<br />      "init" : "49404160",<br />      "max" : "702808064",<br />      "used" : "16635472"<br />    }<br />}<br /></pre><br /><div><br /></div><div><br /><a name='more'></a>You must be aware that Jolokia has a handful of other features. It can work on ordinary JVMs (not only servlet containers) starting dedicated web server, it can also <a href="http://www.jolokia.org/features/proxy.html">connect</a> to external MBeanServer, so you don't have to add any new WAR files as long as you have JMX external access. But the killer feature I quickly discovered was:</div><div></div><h5 class="western">Jolokia + AJAX – a perfect couple</h5><div><br /></div><div>HTTP, JSON... AJAX? Accessing MBeans directly using JavaScript on the client side would be huge. But I haven't even written a single line of code yet when I spotted Jolokia <a href="http://jolokia.org/reference/html/clients.html#client-javascript">Javascript Client Library</a>. Wow, I really love this project! So I took the token bucket application developed <a href="http://nurkiewicz.com/2011/03/tenfold-increase-in-server-throughput.html">last time</a> and quickly added simple server polling for current heap memory usage. Boring. Chart displaying memory usage over time would be much sexier...</div><h5 class="western">Jolokia, AJAX and Highcharts – exciting threesome</h5><div>First, I owe you some explanation. Why am I entering the dirty playground of the most hated web 2.0 child – JavaScript? Let me reveal my goal: fast and snappy, good looking JMX visualization with real-time updates in the browser rather than in the obscure jconsole. The solution should be simple, shouldn't require major server side changes (preferably: none) and should be highly configurable and flexible. Leveraging <a href="http://www.jfree.org/jfreechart/">JFreeChart</a> (Java de facto standard for charting) to produce new version of the chart each second or even more frequently was out of the question.</div><div><br /></div><div>But if we already have access to JMX metrics on the client (browser) side, why not generating the charts there as well, only quickly updating data series when new data arrives. Be pragmatic. First I tried <a href="http://www.jqplot.com/">jqPlot</a> – works great for static charts, but sucks completely when trying to update them. Unless you can live with 10 MiB of memory leaking in the browser every second per chart... Seems like many JavaScript charting libraries suffer the same problem – except <a href="http://www.highcharts.com/">Highcharts</a> – library of my choice. Here is how easily one can plot memory usage chart only on the client side using Jolokia JMX library:</div><div><br /></div><div><pre class="brush: js"><br />$(document).ready(function() {<br />    new Monitor();<br />});<br /><br />function Monitor() {<br />    var jmx = new Jolokia("/jolokia");<br /><br />    var chart = new Highcharts.Chart({<br />        chart: {<br />            renderTo: 'memoryChart',<br />            defaultSeriesType: 'spline',<br />            events: {<br />                load: function() {<br />                    var series = this.series[0];<br />                    setInterval(function() {<br />                        var x = (new Date()).getTime();<br />                        var memoryUsed = jmx.getAttribute("java.lang:type=Memory", "HeapMemoryUsage", "used");<br />                        series.addPoint({<br />                            x: new Date().getTime(),<br />                            y: parseInt(memoryUsed)<br />                        }, true, series.data.length &gt;= 50);<br />                    }, 1000);<br />                }<br />            }<br />        },<br />        xAxis: {<br />            type: 'datetime'<br />        },<br />        series: [{<br />                data: [],<br />            }<br />        ]<br />    });<br />}<br /></pre></div><div>Few less important lines were skipped (mainly chart cosmetics), as always full source is available on <a href="https://github.com/nurkiewicz/token-bucket">GitHub</a>. And this is the result so far:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh5.googleusercontent.com/-H3nlHGAfKN0/TYZJODIuekI/AAAAAAAAAaQ/cA8_tVMcqio/s1600/single.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="246" src="https://lh5.googleusercontent.com/-H3nlHGAfKN0/TYZJODIuekI/AAAAAAAAAaQ/cA8_tVMcqio/s320/single.png" width="320" /></a></div><br /></div><div><br /></div><div>BTW I bit reluctantly switched to Google Chrome browser while writing this article. JavaScript-heavy applications are insanely slow on Firefox, work fine on Opera but Google Chrome beats them together.</div><div><br /></div><div>Having one chart, why not add several others? Luckily Jolokia supports <a href="http://jolokia.org/features/bulk-requests.html">bulk</a> requests (also in JavaScript client library), so we will poll server only once a second, no matter how many charts are displayed.  </div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-V1pVl5POZ24/TYZJWYKkXNI/AAAAAAAAAaU/vlIn5Dyt1iM/s1600/multiple.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="242" src="https://lh4.googleusercontent.com/-V1pVl5POZ24/TYZJWYKkXNI/AAAAAAAAAaU/vlIn5Dyt1iM/s320/multiple.png" width="320" /></a></div><br /></div><div><br /></div><div>Since we are doing so well, why not allow user to rearrange charts so that he can put most relevant ones next to each other (portlets? iGoogle? Anyone?) Luckily, <a href="http://jqueryui.com/demos/sortable/portlets.html">jQuery UI</a> library (Jolokia JavaScript client is built on top of jQuery) ships with portlet-like support built-in.  </div><div><br /></div><div><pre class="brush: js"><br />function JmxChartsFactory(keepHistorySec, pollInterval, columnsCount) {<br />    var jolokia = new Jolokia("/jolokia");<br />    var series = [];<br />    var monitoredMbeans = [];<br />    var chartsCount = 0;<br /><br />    columnsCount = columnsCount || 3;<br />    pollInterval = pollInterval || 1000;<br />    var keepPoints = (keepHistorySec || 600) / (pollInterval / 1000);<br /><br />    setupPortletsContainer(columnsCount);<br /><br />    setInterval(function() {<br />        pollAndUpdateCharts();<br />    }, pollInterval);<br /><br />    this.create = function(mbeans) {<br />        mbeans = $.makeArray(mbeans);<br />        series = series.concat(createChart(mbeans).series);<br />        monitoredMbeans = monitoredMbeans.concat(mbeans);<br />    };<br /><br />    function pollAndUpdateCharts() {<br />        var requests = prepareBatchRequest();<br />        var responses = jolokia.request(requests);<br />        updateCharts(responses);<br />    }<br /><br />    function createNewPortlet(name) {<br />        return $('#portlet-template')<br />                .clone(true)<br />                .appendTo($('.column')[chartsCount++ % columnsCount])<br />                .removeAttr('id')<br />                .find('.title').text((name.length &gt; 50? '...' : '') + name.substring(name.length - 50, name.length)).end()<br />                .find('.portlet-content')[0];<br />    }<br /><br />    function setupPortletsContainer() {<br />        var column = $('.column');<br />        for(var i = 1; i &lt; columnsCount; ++i){<br />            column.clone().appendTo(column.parent());<br />        }<br />        $(".column").sortable({<br />            connectWith: ".column"<br />        });<br /><br />        $(".portlet-header .ui-icon").click(function() {<br />            $(this).toggleClass("ui-icon-minusthick").toggleClass("ui-icon-plusthick");<br />            $(this).parents(".portlet:first").find(".portlet-content").toggle();<br />        });<br />        $(".column").disableSelection();<br />    }<br /><br />    function prepareBatchRequest() {<br />        return $.map(monitoredMbeans, function(mbean) {<br />            return {<br />                type: "read",<br />                mbean: mbean.name,<br />                attribute: mbean.attribute,<br />                path: mbean.path<br />            };<br />        });<br />    }<br /><br />    function updateCharts(responses) {<br />        var curChart = 0;<br />        $.each(responses, function() {<br />            var point = {<br />                x: this.timestamp * 1000,<br />                y: parseFloat(this.value)<br />            };<br />            var curSeries = series[curChart++];<br />            curSeries.addPoint(point, true, curSeries.data.length &gt;= keepPoints);<br />        });<br />    }<br /><br />    function createChart(mbeans) {<br />        return new Highcharts.Chart({<br />            chart: {<br />                renderTo: createNewPortlet(mbeans[0].name),<br />                animation: false,<br />                defaultSeriesType: 'area',<br />                shadow: false<br />            },<br />            title: { text: null },<br />            xAxis: { type: 'datetime' },<br />            yAxis: {<br />                title: { text: mbeans[0].attribute }<br />            },<br />            legend: {<br />                enabled: true,<br />                borderWidth: 0<br />            },<br />            credits: {enabled: false},<br />            exporting: { enabled: false },<br />            plotOptions: {<br />                area: {<br />                    marker: {<br />                        enabled: false<br />                    }<br />                }<br />            },<br />            series: $.map(mbeans, function(mbean) {<br />                return {<br />                    data: [],<br />                    name: mbean.path || mbean.attribute<br />                }<br />            })<br />        })<br />    }<br />}<br /></pre></div><div><br /></div><div>Sure, 110 lines is a lot of code, but you must admit that it's not that much when feature set is considered: configurable chart history length, polling interval and number of columns in portlet layout. Also, the set of visible JMX charts are fully customizable. If you want, you might easily add the possibility to add and remove charts at runtime when needed or even browsing MBeanServer exposed beans. The usage is of this class is very simple:</div><div><br /></div><div><pre class="brush: js"><br />$(document).ready(function() {<br />    var factory = new JmxChartsFactory();<br />    factory.create([<br />        {<br />            name: 'java.lang:type=Memory',<br />            attribute: 'HeapMemoryUsage',<br />            path: 'committed'<br />        },<br />        {<br />            name: 'java.lang:type=Memory',<br />            attribute: 'HeapMemoryUsage',<br />            path: 'used'<br />        }<br />    ]);<br />    factory.create([<br />        {<br />            name: 'java.lang:type=OperatingSystem',<br />            attribute: 'SystemLoadAverage'<br />        }<br />    ]);<br />    factory.create({<br />        name:     'java.lang:type=Threading',<br />        attribute: 'ThreadCount'<br />    });<br />    factory.create([<br />        {<br />            name: 'Catalina:name="http-bio-8080",type=ThreadPool',<br />            attribute: 'currentThreadsBusy'<br />        },<br />        {<br />            name: 'Catalina:name=executor,type=Executor',<br />            attribute: 'queueSize'<br />        }<br />    ]);<br />    factory.create([<br />        {<br />            name: 'com.blogspot.nurkiewicz.download.tokenbucket:name=perRequestTokenBucket,type=PerRequestTokenBucket',<br />            attribute: 'OngoingRequests'<br />        },<br />        {<br />            name: 'com.blogspot.nurkiewicz.download:name=downloadServletHandler,type=DownloadServletHandler',<br />            attribute: 'AwaitingChunks'<br />        }<br />    ]);<br />});<br /></pre> </div><div><br /></div><div>Tired of code? HTML for this article can be found <a href="https://github.com/nurkiewicz/token-bucket/blob/master/src/main/webapp/index.html">here</a>, and as Chinese used to say, <i>a picture is worth a thousand </i><i>lines of code</i>:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh4.googleusercontent.com/-oJPWOO1VYAU/TYZJc98K_lI/AAAAAAAAAaY/erLrPCHYv7A/s1600/portlet.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="195" src="https://lh4.googleusercontent.com/-oJPWOO1VYAU/TYZJc98K_lI/AAAAAAAAAaY/erLrPCHYv7A/s320/portlet.png" width="320" /></a></div></div><div>But because our monitoring dashboard is so dynamic, to quote <a href="http://en.wikipedia.org/wiki/Nicolaus_Copernicus">Nicolaus Copernicus</a> “<i>A YouTube video is worth a thousand pictures</i>”* (somewhere in the middle you'll see the system reacting after heavy load was simulated):</div><div><br /></div><div style="text-align: center;"><iframe allowfullscreen="" frameborder="0" height="510" src="http://www.youtube.com/embed/a5nqZmyhTNo?rel=0&amp;hd=1" title="YouTube video player" width="640"></iframe></div><div><br /></div><div>Now these 100+ lines of JavaScript code aren't that overwhelming, don't you think? To summarize, using JavaScript and handful of readily available libraries we added interactive, refreshable, Web 2.0-ish monitoring dashboard. It integrates seamlessly with every JVM using JMX, and if we would use Jolokia <a href="http://www.jolokia.org/features/proxy.html">proxy</a> mode, <b>no</b> changes would be required in monitored application/server. Because the client asks JMX server in batch and updates charts on the client side, everything works with minimal delay.</div><div><br /></div><div>So the next time your customer asks for a monitoring solution or you want to enrich existing application without modifying it too much – consider the simplest solution, as it might be the best one as well. And maybe this tiny dashboard code is a valuable milestone of a decent successor of aforementioned <a href="http://www.jmanage.org/">JManage</a>? </div><div><br /></div><div>* Other famous quote by <a href="http://en.wikipedia.org/wiki/Nicolaus_Copernicus">Nicolaus Copernicus</a>: “<i>Don't believe in everything you read in the Internet</i>”...<br /><br /></div>