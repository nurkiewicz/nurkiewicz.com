---
layout: post
title: Secret powers of foldLeft() in Scala
date: '2012-04-09T15:26:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
modified_time: '2012-04-10T10:35:34.480+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-574688540848567249
blogger_orig_url: https://www.nurkiewicz.com/2012/04/secret-powers-of-foldleft-in-scala.html
---

<i><code>foldLeft()</code> method, available for all collections in Scala, allows to run a given 2-argument function against consecutive elements of that collection, where the result of that function is passed as the first argument in the next invocation. Second argument is always the current item in the collection.</i> Doesn't sound very encouraging but as we will see soon there are great some use-cases waiting to be discovered.<br /><br />Before we dive into <code>foldLeft</code>, let us have a look at <code>reduce</code> - simplified version of <code>foldLeft</code>. I always believed that a <a href="http://en.wikipedia.org/wiki/A_picture_is_worth_a_thousand_words">working code is worth a thousand words</a>:  <br /><pre class="brush: scala">val input = List(3, 5, 7, 11)<br />input.reduce((total, cur) =&gt; total + cur)<br /></pre>or more readable:  <br /><pre class="brush: scala">def op(total: Int, cur: Int) = total + cur<br /><br />input reduce op<br /></pre>The result is <code>26</code> (sum). The code is more-or-less readable: to <code>reduce</code> method we are passing 2-argument function <code>op</code> (operation). Both parameters of that function (and its return value) need to have the same type as the collection. <code>reduce()</code> will invoke that operation on two first items of the collection:  <br /><pre class="brush: scala">op(3, 5)  //8<br /></pre>The result (<code>8</code>) is passed as a first argument to a subsequent invocation of <code>op</code> where the second argument is the next collection element:  <br /><pre class="brush: scala">op(8, 7)  //15<br /></pre>and finally:  <br /><pre class="brush: scala">op(15, 11)  //26<br /></pre>From the logical standpoint the following composed operation has been invoked:  <br /><pre class="brush: scala">op(op(op(3, 5), 7), 11)<br /></pre>When we realize that <code>op()</code> is basically an addition:<br /><a name='more'></a><br /><pre class="brush: scala">(((3 + 5) + 7) + 11)<br /></pre>So far so good - <code>reduce()</code> <i>reduces</i> a collection of a given type to a single value of the same type. Example use-cases include adding up numbers, concatenating a sequence of strings, etc.:  <br /><pre class="brush: scala">List("Foo", "Bar", "Buzz").reduce(_ + _)<br /></pre>Note the shorthand notation for code block without naming the parameters: <code>_ + _</code>. Obviously we are not limited to addition operator:  <br /><pre class="brush: scala">def factorial(x: Int) = (2 to x).reduce(_ * _)<br /></pre>It is worth to mention two special cases: when the collection has only one element, <code>reduce()</code> returns this very element. When it is empty, <code>reduce()</code> will throw an exception. Let's face it, typically we implement factorial for the first (and last) time somewhere at the beginning of the university and to add up numbers we have a convenience method:  <br /><pre class="brush: scala">input.sum<br /></pre>Besides the problem with empty collections is a bit painful - after all the sum of empty set of numbers is intuitively equal to 0 and the concatenation of an empty set of strings is... an empty string. Here is where <code>foldLeft()</code> enters with the ability to specify initial value:  <br /><pre class="brush: scala">input.foldLeft(0)(op)<br /></pre>In this case the <code>op()</code> function is first called with initial value <code>0</code> as the first argument and with the first collection element:  <br /><pre class="brush: scala">op(0, 3)<br /></pre>The subsequent iterations remain the same. If the collection is empty, <code>foldLeft()</code> returns the initial value. It is sad how many tutorial stop right here. After all we can simply prepend initial value to the input list and happily use <code>reduce()</code>:  <br /><pre class="brush: scala">(0 :: input).reduce(op)<br />(0 :: Nil).reduce(op)  //empty list is prepended by 0<br /></pre>Even worse, many suggest “simplified" <code>foldLeft()</code> syntax, I doubt it simplifies anything:  <br /><pre class="brush: scala">(0 /: input)(op)<br /></pre>This is equivalent to <code>input.foldLeft(0)(op)</code> but intended for people who love Perl. So, closing this way too long introduction, let us see the true power behind <code>foldLeft()</code>.<br /><br />Let us assume that we have an object of type <code>[T]</code> on which we would like to perform a set of transformations. Transformation is nothing more than a function that accepts and returns an object of type <code>[T]</code>. We can return the same instance (no-op transformation), wrap the original object (the <i>Decorator</i> pattern) or mutate it.<br /><br />It is not hard to imagine that the order of transformations is important. For example let us use an ordinary string and set of transformations represented by functions of <code>String =&gt; String</code>:  <br /><pre class="brush: scala">val reverse = (s: String) =&gt; s.reverse<br /><br />val toUpper = (s: String) =&gt; s.toUpperCase<br /><br />val appendBar = (s: String) =&gt; s + "bar"<br /></pre>Remembering that a result of a first transformation is an argument of the second one we can say:  <br /><pre class="brush: scala">appendBar(toUpper(reverse("foo")))  //OOFbar<br />toUpper(reverse(appendBar("foo")))  //RABOOF<br /></pre>I think that's obvious. Unfortunately we need a method taking an arbitrary (possibly empty or created dynamically) list of transformations to apply:  <br /><pre class="brush: scala">def applyTransformations(initial: String, transformations: Seq[String =&gt; String]) = //???<br /><br />applyTransformations("foo", List(reverse, toUpper, appendBar))<br />applyTransformations("foo", List(appendBar, reverse, toUpper))<br />applyTransformations("foo", List.fill(7)(appendBar))<br /></pre>The last line performs <code>appendBar</code> transformation 7 times on an initial value <code>"foo"</code>. How to implement <code>applyTransformations</code> method? The programmer with highly imperative background would probably come up with something like this:  <br /><pre class="brush: scala">def applyTransformations(initial: String, transformations: Seq[String =&gt; String]) = {<br />    var cur = initial<br />    for(transformation &lt;- transformations) {<br />        cur = transformation(cur)<br />    }<br />    cur<br />}<br /></pre>Boring loop over all transformations, the intermediate result is stored in a variable. This implementation has several drawbacks. First - it's imperative (!) Scala tries to embrace the functional programming paradigm and this code seems very low-level. Our second take is much more idiomatic as far as Scala is concerned - we use recursion and pattern matching:  <br /><pre class="brush: scala">@tailrec<br />def applyTransformations(initial: String, transformations: Seq[String =&gt; String]): String =<br />    transformations match {<br />        case head :: tail =&gt; applyTransformations(head(initial), tail)<br />        case Nil =&gt; initial<br />    }<br /></pre>A little bit harder to comprehend compared to imperative solution. If the list of transformations is empty - return current value. If it's not, apply the first transformation (<code>head(initial)</code>) and recursively call myself with the rest of the transformations (<code>tail</code>).<br /><br />Turns out this problem can be implemented in much, much more concise way, without explicit loops and recursion. Have you noticed how the problem with nested transformations (<code>appendBar(toUpper(reverse("foo")))</code>) is similar to how the <code>foldLeft()</code> works (<code>op(op(op(3, 5), 7), 11)</code>)?  <br /><pre class="brush: scala">def applyTransformations(initial: String, transformations: Seq[String =&gt; String]) =<br />    transformations.foldLeft(initial) {<br />        (cur, transformation) =&gt; transformation(cur)<br />    }<br /></pre>Understanding how the code above works requires a little bit of time - but it is really rewarding afterwards. Also it allows you to fully grasp the power of <code>foldLeft()</code>. Before you go further try to figure this out yourself. Few tips:  <br /><ul><li>The type of <code>foldLeft()</code> result <code>[B]</code> doesn't necessarily have to be the same as the collection type <code>[A]</code>. It is the type of the initial value. In our example the input collection contains functions but the initial value is String.</li><li>Function passed as an argument to <code>foldLeft()</code> does not need to accept both arguments of <code>[A]</code> type and return that type as well - as it was with <code>reduce()</code>. In fact, the signature of <code>foldLeft()</code> is as follows: <pre class="brush: scala">def foldLeft[B](initial: B)(op: (B, A) =&gt; B): B<br /></pre></li><li>The value returned by <code>op</code> function should be of the same type as its first argument. Also the whole <code>foldLeft()</code> invocation will have the same type.</li></ul>Let's think about it: the type of the first argument of <code>op()</code> is compatible with the initial value (<code>initial: B</code>) because in the first iteration it is the initial value that is passed as the first argument of <code>op</code>. A second argument is the first element of the input collection of type <code>[A]</code>. In the second iteration the result of <code>op()</code> invocation (of type <code>[B]</code>) is passed as the first argument of subsequent invocation of <code>op</code>. This time the second element of the input collection is used as the second argument. And it goes on until it reaches the end of the collection.<br /><br />I think the pseudo-code would be much easier to comprehend. First some example invocation:  <br /><pre class="brush: scala">List(reverse, toUpper, appendBar).foldLeft("foo") {<br />    (cur, transformation) =&gt; transformation(cur)<br />}<br /></pre>Subsequent iterations (pseudo-code):  <br /><pre class="brush: scala">val initial = "foo"<br />val temp1 = (initial, reverse) =&gt; reverse(initial)<br />val temp2 = (temp1, toUpper) =&gt; toUpper(temp1)<br />val temp3 = (temp2, appendBar) =&gt; appendBar(temp2)<br /></pre>And after inlining temporary variables:  <br /><pre class="brush: scala">val initial = "foo"<br />appendBar(toUpper(reverse(initial)))<br /></pre>Isn't this the result we've been waiting for? As it turns out, <code>foldLeft()</code> is not only useful when we need to reduce (aggregate) collection to a single value, like adding up numbers - in fact, <code>reduce()</code> or <code>sum()</code> are better suited in this case. <code>foldLeft()</code> seems to be a great fit when we need to iterate over an arbitrary collection but every iteration requires some sort of result from previous one. By the way this is the reason why <code>fold</code> and <code>reduce</code> operations can't be executed in parallel.<br /><br />In comments to the original article <i>Cezary Bartoszuk</i> suggested an alternative way of using <code>foldLeft()</code> in this problem:  <br /><pre class="brush: scala">def composeAll[A](ts: Seq[A =&gt; A]): A =&gt; A = ts.foldLeft(identity[A] _)(_ compose _)<br /><br />def applyTransformations(init: String, ts: Seq[String =&gt; String]): String = composeAll(ts.reverse)(init)<br /></pre>If this solution isn't clear to your, once again few tips. First of all <code>identity[A] _</code> is an  <a href="http://en.wikipedia.org/wiki/Identity_function">identity function</a> - always returning an argument untouched. Secondly <code>val composed = appendBar compose toUpper</code> is equivalent to:  <br /><pre class="brush: scala">val composed = (s: String) =&gt; appendBar(toUpper(s))<br /></pre>So another mathematical term: <a href="http://en.wikipedia.org/wiki/Function_composition">function composition</a>.  <br /><blockquote>This was a translation of my article <a href="http://scala.net.pl/ukryta-potega-foldleft/"><i>"Ukryta potęga foldLeft()"</i></a> originally published on <a href="http://scala.net.pl/">scala.net.pl</a>. </blockquote>