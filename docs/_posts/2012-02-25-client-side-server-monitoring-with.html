---
layout: post
title: Client-side server monitoring with Jolokia and JMX
date: '2012-02-25T23:52:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- javascript
- design patterns
- jmx
- jolokia
- monitoring
modified_time: '2017-09-03T13:01:49.047+02:00'
thumbnail: https://1.bp.blogspot.com/-pys4rtOVC-A/T0lhEvRzTTI/AAAAAAAAAh4/0nx5yaU-DnE/s72-c/javamelody.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8823925083838247835
blogger_orig_url: https://www.nurkiewicz.com/2012/02/client-side-server-monitoring-with.html
---

The choice of Java monitoring tools is tremendous (random selection and order powered by Google):<br /><br /><table><tbody><tr><td><a href="http://code.google.com/p/javamelody">javamelody</a></td><td><a href="http://1.bp.blogspot.com/-pys4rtOVC-A/T0lhEvRzTTI/AAAAAAAAAh4/0nx5yaU-DnE/s1600/javamelody.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="124" src="https://1.bp.blogspot.com/-pys4rtOVC-A/T0lhEvRzTTI/AAAAAAAAAh4/0nx5yaU-DnE/s200/javamelody.png" width="200" /></a></td></tr><tr><td><a href="http://code.google.com/p/psi-probe/">psi-probe</a></td><td><a href="http://3.bp.blogspot.com/-aSTrhsdPK7s/T0lhNFrLycI/AAAAAAAAAiE/h866ogGiTk8/s1600/psi-probe.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="123" src="https://3.bp.blogspot.com/-aSTrhsdPK7s/T0lhNFrLycI/AAAAAAAAAiE/h866ogGiTk8/s200/psi-probe.png" width="200" /></a> </td></tr><tr><td><a href="http://visualvm.java.net/">JVisualVM</a></td><td><a href="http://3.bp.blogspot.com/-5nnEPVG32f0/T0lhTXBiLtI/AAAAAAAAAiQ/tlj7rjLCB-c/s1600/jvisualvm.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="143" src="https://3.bp.blogspot.com/-5nnEPVG32f0/T0lhTXBiLtI/AAAAAAAAAiQ/tlj7rjLCB-c/s200/jvisualvm.jpg" width="200" /></a></td></tr><tr><td><a href="http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html">jconsole</a></td><td><a href="http://3.bp.blogspot.com/-wGXY3S4gZUM/T0lhZYbeiRI/AAAAAAAAAic/UJcl-iMj6c0/s1600/jconsole.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="157" src="https://3.bp.blogspot.com/-wGXY3S4gZUM/T0lhZYbeiRI/AAAAAAAAAic/UJcl-iMj6c0/s200/jconsole.jpg" width="200" /></a></td></tr><tr><td><a href="http://jamonapi.sourceforge.net/">JAMon</a></td><td><a href="http://3.bp.blogspot.com/-CDGRuR2PjQ4/T0lhjdKq7YI/AAAAAAAAAio/F1YAo72AR94/s1600/jamon.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="126" src="https://3.bp.blogspot.com/-CDGRuR2PjQ4/T0lhjdKq7YI/AAAAAAAAAio/F1YAo72AR94/s200/jamon.jpeg" width="200" /></a></td></tr><tr><td><a href="http://exchange.nagios.org/directory/Plugins/Java-Applications-and-Servers/check_jmx/details">Java JMX Nagios Plugin</a></td><td>N/A</td></tr></tbody></table><br />Besides, there are various dedicated tools e.g. for <a href="http://activemq.apache.org/web-console.html">ActiveMQ</a>, <a href="https://community.jboss.org/wiki/WebConsole">JBoss</a>, <a href="http://code.google.com/p/jwatch">Quartz scheduler</a>, <a href="http://blog.springsource.org/2010/03/10/springsource-tc-server-2-0">Tomcat/tcServer</a>... So which one should you use as an ultimate monitoring dashboard? Well, none of them provide out-of-the-box features you might require. In some applications you have to constantly monitor the contents and size of a given JMS queue. Others are known to have memory or CPU problems. I have also seen software where system administrators had to constantly run some SQL query and check the results or even parse the logs to make sure some essential background process is running. Possibilities are endless, because it really depends on the software and its use-cases. To make matters worse, your customer doesn't care about GC activity, number of open JDBC connections and whether this nasty batch process is not hanging. It should <i>just work</i>.<br /><br />In this post we will try to develop easy, cheap, but yet powerful management console. It will be built around the idea of a single binary result – it works or not. If this single health indicator is green, no need to go deeper. But! If it turned red, we can easily drill-down. It is possible because instead of showing hundreds of unrelated metrics we will group them in a tree-like structure. The health status of each node in a tree is as bad as the worst child. This way if anything bad happens with our application, it will bubble-up.<br /><br /><br /><a name='more'></a><br /><br />We are not forcing system administrator to constantly monitor several metrics. We decide what is important and if even tiniest piece of our software is malfunctioning, it will pop-up. Compare this to a continuous integration server that does not have green/red builds and e-mail notifications. Instead you have to go to the server every other build and manually check whether the code is compiling and all tests were green. The logs and results are there, but why parse them and aggregate manually? This is what we are trying to avoid in our home-grown monitoring solution.<br /><br />As a foundation I have chosen (not for the <a href="http://nurkiewicz.com/search/label/jolokia">first time</a>) <a href="http://draft.blogger.com/blogger.g?blogID=6753769565491687768">Jolokia</a> JMX to HTTP bridge. JVM already provides the monitoring infrastructure so why reinvent it? Also thanks to Jolokia the whole dashboard can be implemented in JavaScript on the client side. This has several advantages: server footprint is minimal, also it allows us to rapidly tune metrics by adding them or changing alert thresholds.<br /><br />We'll start by downloading various JMX metrics onto the client (browser). I have developed some small application for demonstration purposes employing as many technologies as possible – Tomcat, Spring, Hibernate, ActiveMQ, Quartz, etc. I am not using the built-in <a href="http://www.jolokia.org/client/javascript.html">JavaScript client library</a> for Jolokia as I found it a bit cumbersome. But as you can see it is just a matter of a single AJAX call to fetch great deal of metrics.<br /><pre class="brush: js">function request() {<br />    var mbeans = [<br />        "java.lang:type=Memory",<br />        "java.lang:type=MemoryPool,name=Code Cache",<br />        "java.lang:type=MemoryPool,name=PS Eden Space",<br />        "java.lang:type=MemoryPool,name=PS Old Gen",<br />        "java.lang:type=MemoryPool,name=PS Perm Gen",<br />        "java.lang:type=MemoryPool,name=PS Survivor Space",<br />        "java.lang:type=OperatingSystem",<br />        "java.lang:type=Runtime",<br />        "java.lang:type=Threading",<br />        'Catalina:name="http-bio-8080",type=ThreadPool',<br />        'Catalina:type=GlobalRequestProcessor,name="http-bio-8080"',<br />        'Catalina:type=Manager,context=/jmx-dashboard,host=localhost',<br />        'org.hibernate:type=Statistics,application=jmx-dashboard',<br />        "net.sf.ehcache:type=CacheStatistics,CacheManager=jmx-dashboard,name=org.hibernate.cache.StandardQueryCache",<br />        "net.sf.ehcache:type=CacheStatistics,CacheManager=jmx-dashboard,name=org.hibernate.cache.UpdateTimestampsCache",<br />        "quartz:type=QuartzScheduler,name=schedulerFactory,instance=NON_CLUSTERED",<br />        'org.apache.activemq:BrokerName=localhost,Type=Queue,Destination=requests',<br />        "com.blogspot.nurkiewicz.spring:name=dataSource,type=ManagedBasicDataSource"<br />    ];<br />    return _.map(mbeans, function(mbean) {<br />        return {<br />            type:'read',<br />            mbean: mbean<br />        }<br />    });<br />}<br /><br />$.ajax({<br />    url: 'jmx?ignoreErrors=true',<br />    type: "POST",<br />    dataType: "json",<br />    data: JSON.stringify(request()),<br />    contentType: "application/json",<br />    success: function(response) {<br />      displayRawData(response);<br />    }<br />});<br /></pre>Just to give you an overview what kind of information is accessible on the client side, we will first dump everything and display it on <a href="http://jqueryui.com/">jQuery UI</a> <a href="http://jqueryui.com/demos/accordion/">accordion:</a> <br /><pre class="brush: js">function displayRawData(fullResponse) {<br />  _(fullResponse).each(function (response) {<br />    var content = $('&lt;pre/&gt;').append(JSON.stringify(response.value, null, '\t'));<br />    var header = $('&lt;h3/&gt;').append($("&lt;a/&gt;", {href:'#'}).append(response.request.mbean));<br />    $('#rawDataPanel').<br />        append(header).<br />        append($('&lt;div/&gt;').append(content));<br />  });<br />  $('#rawDataPanel').accordion({autoHeight: false, collapsible: true});<br />}<br /></pre>Remember that this is just for reference and debug purposes, we are <b>not</b> aiming to display endless list of JMX attributes.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-tH53MiYyorY/T0liElwC7zI/AAAAAAAAAi0/KgKkXxc1ALo/s1600/raw_all.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="237" src="https://4.bp.blogspot.com/-tH53MiYyorY/T0liElwC7zI/AAAAAAAAAi0/KgKkXxc1ALo/s400/raw_all.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-tTUlzMfQjTY/T0linhvyNTI/AAAAAAAAAjk/7fMu0Z_WSWU/s1600/raw_os.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="237" src="https://4.bp.blogspot.com/-tTUlzMfQjTY/T0linhvyNTI/AAAAAAAAAjk/7fMu0Z_WSWU/s400/raw_os.png" width="400" /></a></div><br /><br />As you can see it is actually possible to implement complete <code>jconsole</code> port inside a browser with Jolokia and JavaScript... maybe next time (anyone care to help?). Back to our project, let's pick few essential metrics and display them in a list:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-v6gmTYnUq1w/T0liLR1E-zI/AAAAAAAAAjA/O3-8wrj56BI/s1600/flat_list.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="https://1.bp.blogspot.com/-v6gmTYnUq1w/T0liLR1E-zI/AAAAAAAAAjA/O3-8wrj56BI/s400/flat_list.png" width="234" /></a></div><br /><br />The list itself looks very promising. Instead of displaying charts or values I have assigned an icon to each metric (more on that later). But I don't want to go through the whole list all the time. Why can't I just have a single indicator that aggregates several metrics? Since we are already using <a href="http://www.jstree.com/">jsTree</a>, the transition is relatively simple:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-8mRuedKLU_M/T0liU02q3UI/AAAAAAAAAjM/CM2dO8-YRw8/s1600/tree_green.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="https://1.bp.blogspot.com/-8mRuedKLU_M/T0liU02q3UI/AAAAAAAAAjM/CM2dO8-YRw8/s400/tree_green.png" width="234" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-5j1OnEfBq7I/T0liahRXaWI/AAAAAAAAAjY/2FksdT8yipI/s1600/tree_fatal.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="https://1.bp.blogspot.com/-5j1OnEfBq7I/T0liahRXaWI/AAAAAAAAAjY/2FksdT8yipI/s400/tree_fatal.png" width="234" /></a></div><br /><br />On the first screenshot you see a healthy system. There is really no need to drill down since <i>Overall</i> metric is green. However the situation is worse on the second screenshot. <i>System load</i> is alarmingly high, also the <i>Swap space</i> needs attention, but is less important. As you can see the former metrics bubbles up all the way to the overall, top metric. This way we can easily discover what is working incorrectly in our system. You might be wondering how did we achieved this pretty tree while at the beginning we only had raw JMX data? No magic here, see how am I constructing the tree:<br /><br /><pre class="brush: js; highlight: 7">function buildTreeModel(jmx) {<br />  return new CompositeNode('Overall', [<br />    new CompositeNode('Servlet container', [<br />      new Node(<br />          'Active HTTP sessions',<br />          jmx['Catalina:context=/jmx-dashboard,host=localhost,type=Manager'].activeSessions,<br />          Node.threshold(200, 300, 500)<br />      ),<br />      new Node(<br />          'HTTP sessions create rate',<br />          jmx['Catalina:context=/jmx-dashboard,host=localhost,type=Manager'].sessionCreateRate,<br />          Node.threshold(5, 10, 50)<br />      ),<br />      new Node(<br />          'Rejected HTTP sessions',<br />          jmx['Catalina:context=/jmx-dashboard,host=localhost,type=Manager'].rejectedSessions,<br />          Node.threshold(1, 5, 10)<br />      ),<br />      new Node(<br />          'Busy worker threads count',<br />          jmx['Catalina:name="http-bio-8080",type=ThreadPool'].currentThreadsBusy,<br />          Node.relativeThreshold(0.85, 0.9, 0.95, jmx['Catalina:name="http-bio-8080",type=ThreadPool'].maxThreads)<br />      )<br />    ]),<br />    //...<br />    new CompositeNode('External systems', [<br />      new CompositeNode('Persistence', [<br />        new Node(<br />            'Active database connections',<br />            jmx['com.blogspot.nurkiewicz.spring:name=dataSource,type=ManagedBasicDataSource'].NumActive,<br />            Node.relativeThreshold(0.75, 0.85, 0.95, jmx['com.blogspot.nurkiewicz.spring:name=dataSource,type=ManagedBasicDataSource'].MaxActive)<br />        )<br />      ]),<br />      new CompositeNode('JMS messaging broker', [<br />        new Node(<br />            'Waiting in "requests" queue',<br />            jmx['org.apache.activemq:BrokerName=localhost,Destination=requests,Type=Queue'].QueueSize,<br />            Node.threshold(2, 5, 10)<br />        ),<br />        new Node(<br />            'Number of consumers',<br />            jmx['org.apache.activemq:BrokerName=localhost,Destination=requests,Type=Queue'].ConsumerCount,<br />            Node.threshold(0.2, 0.1, 0)<br />        )<br />      ])<br />    ])<br />  ]);<br />}</pre>The tree model is quite simple. Root node can have a list of child nodes. Every child node can be either a leaf representing a single evaluated JMX metric or a composite node representing set of grandchildren. Each grandchild can in turns be a leaf or yet another composite node. Yes, it is a simple example of <a href="http://en.wikipedia.org/wiki/Composite_pattern"><i>Composite</i></a> design pattern! However it is not obvious where <a href="http://en.wikipedia.org/wiki/Strategy_pattern"><i>Strategy</i></a> pattern was used. Look closer, each leaf node object has three properties: label (what you see on the screen), value (single JMX metric) and an odd function <code>Node.threshold(200, 300, 500)</code>... What is it? It is actually a higher order function (function returning a function) used later to interpret JMX metric. Remember, the raw value is meaningless, it has to be interpreted and translated into good-looking icon indicator. Here is how this implementation works:<br /><br /><pre class="brush: js">Node.threshold = function(attention, warning, fatal) {<br />    if(attention &gt; warning &amp;&amp; warning &gt; fatal) {<br />      return function(value) {<br />        if(value &gt; attention) { return 1.0; }<br />        if(value &gt; warning) { return 0.5; }<br />        if(value &gt; fatal) { return 0.0; } else { return -1.0; }<br />      }<br />    }<br />    if(attention &lt; warning &amp;&amp; warning &lt; fatal) {<br />      return function(value) {<br />        if(value &lt; attention) { return 1.0; }<br />        if(value &lt; warning) { return 0.5; }<br />        if(value &lt; fatal) { return 0.0; } else { return -1.0; }<br />      }<br />    }<br />    throw new Error("All thresholds should either be increasing or decreasing: " + attention + ", " + warning + ", " + fatal);<br />  }</pre>Now it becomes clear. The function receives level thresholds and returns a function that translates them to number in -1:1 range. I could have returned icons directly but I wanted to abstract tree model from GUI representation. If you now go back to <code>Node.threshold(200, 300, 500)</code> example of <code> Active HTTP sessions</code> metric it is finally obvious: if the number of active HTTP sessions exceed 200, show <i>attention</i> icon instead of OK. If it exceeds 300, <i>warning</i> appears. Above 500 <i>fatal</i> icon will appear. This function is a <i>strategy</i> that understands the input and handles it somehow.<br /><br />Of course these values/functions are only examples, but this is where real hard work manifests – for each JMX metric you have to define a set of sane thresholds. Is 500 HTTP sessions a disaster or only a high load we can deal with? Is 90% CPU load problematic or maybe if it is really low we should start worrying? Once you fine-tune these levels it should no longer be required to monitor everything at the same time. Just look at the top level <b>single metric</b>. If it is green, have a break. If it is not, drill-down in few seconds to find what the real problem is. Simple and effective. And did I mention it does not require any changes on the server side (except adding Jolokia and mapping it to some URL)?<br /><br />Obviously this is just a small proof-of-concept, not a complete monitoring solution. However if you are interested in trying it out and improving, the whole source code is <a href="https://github.com/nurkiewicz/jmx-dashboard">available</a> - as always on my GitHub <a href="https://github.com/nurkiewicz">account</a>.  <script>SyntaxHighlighter.highlight();</script>