---
layout: post
title: Logika biznesowa w Groovy ze Springiem i JPA część 2/2
date: '2009-05-01T19:42:00.004+02:00'
author: Tomasz Nurkiewicz
tags:
- groovy
- jpa
- spring
modified_time: '2009-05-01T21:20:21.169+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2503890422159107440
blogger_orig_url: https://www.nurkiewicz.com/2009/05/logika-biznesowa-w-groovy-ze-springiem_01.html
---

<a href="http://nurkiewicz.com/2009/05/logika-biznesowa-w-groovy-ze-springiem.html">Przypominam</a>, że naszym celem jest pobieranie skryptów Groovy z bazy danych, a użyjemy do tego JPA. Oczywiście chcemy maksymalnie wykorzystać wsparcie springowe, jednak nie obejdzie się bez małego "tuningu". Krótka zabawa w detektywa i znajdujemy metodę <span style="font-family:courier new;">convertToScriptSource()</span> klasy <span style="font-family:courier new;">org.springframework.scripting.support.ScriptFactoryPostProcessor</span>:<br /><br /><pre name="code" class="java">protected ScriptSource convertToScriptSource(<br />     String beanName, String scriptSourceLocator, ResourceLoader resourceLoader) {<br /><br /> if (scriptSourceLocator.startsWith(INLINE_SCRIPT_PREFIX)) {<br />     return new StaticScriptSource(scriptSourceLocator.substring(INLINE_SCRIPT_PREFIX.length()), beanName);<br /> }<br /> else {<br />     return new ResourceScriptSource(resourceLoader.getResource(scriptSourceLocator));<br /> }<br />}</pre>Metoda ta parsuje string przekazany jako argument atrybutu <span style="font-family:courier new;">script-source</span> i zwraca obiekt implementujący <span style="font-family:courier new;">ScriptSource</span>:<br /><pre name="code" class="java">package org.springframework.scripting;<br /><br />public interface ScriptSource {<br /> String getScriptAsString() throws IOException;<br /> boolean isModified();<br /> String suggestedClassName();<br />}</pre>Ale zacznijmy od poprawienia <span style="font-family:courier new;">ScriptFactoryPostProcessor</span>. Stworzyłem klasę dziedziczącą po niej i przesłoniłem metodę <span style="font-family:courier new;">convertToScriptSource()</span> tak, aby rozpoznawała również prefiks "<span style="font-family:courier new;">jpa</span>". Przykład na koniec a implementacja trywialna. Najważniejsze to jak zmusić Springa, żeby używał naszego post procesora, skoro nigdzie jawnie nie deklarujemy tego oryginalnego? Otóż wystarczy dodać bean:<br /><pre name="code" class="xml">&lt;bean id="scriptFactoryPostProcessor" class="com.blogspot.nurkiewicz.PluggableScriptFactoryPostProcessor"/></pre>Kwestia konwencji nazewniczej: jeśli użytkownik zdefiniuje bean o id <span style="font-family:courier new;">scriptFactoryPostProcessor</span>, będzie on używany zamiast tego oryginalnego. Ot cała filozofia. A co zwraca nasz post procesor po napotkaniu prefiksu "<span style="font-family:courier new;">jpa</span>"?<br /><pre name="code" class="java">public class JpaScriptSource implements ScriptSource {<br /><br /> private final String id;<br /> private final ScriptDao scriptDao;<br /><br /> private Date lastModified;<br /><br /> public JpaScriptSource(ScriptDao scriptDao, String id) {<br />     this.scriptDao = scriptDao;<br />     this.id = id;<br /> }<br /><br /> @Override<br /> public synchronized String getScriptAsString() throws IOException {<br />     Script script = scriptDao.restore(id);<br />     lastModified = script.getLastModified();<br />     return script.getSource();<br /> }<br /><br /> @Override<br /> public synchronized boolean isModified() {<br />     return scriptDao.restore(id).getLastModified().after(lastModified);<br /> }<br /><br /> @Override<br /> public String suggestedClassName() {<br />     return null;<br /> }<br /><br />}</pre>I do kompletu obiekt reprezentujący nasz skrypt w bazie danych (szczegóły modelu relacyjnego trzymam w <span style="font-family:courier new;">orm.xml</span>, tak jest chyba czytelniej):<br /><pre name="code" class="java">@Entity<br />@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)<br />public class Script {<br /><br /> @Id<br /> private String id;<br /> private String description;<br /> private String source;<br /> private Date lastModified = new Date();<br /><br /> //get/set<br />}</pre>Po kolei. Metoda <span style="font-family:courier new;">getScriptAsString()</span> najpierw ładuje z bazy obiekt typu Script (u mnie z tabelki <span style="font-family:courier new;">Scripts</span>) o podanym kluczu głównym. W naszym wypadku id jest napisem będącym nazwą skryptu. To id przekażemy w atrybucie <span style="font-family:courier new;">script-source</span> beanu. Potem wystarczy zwrócić treść skryptu (właściwość <span style="font-family:courier new;">source</span>).<br /><br />Atrybut <span style="font-family:courier new;">lastModified </span>jest wykorzystywany w metodzie <span style="font-family:courier new;">isModified()</span>. Jej działanie jest proste: Spring co zadany czas (atrybut <span style="font-family:courier new;">refresh-check-delay</span> tagu <span style="font-family:courier new;"><lang:groovy></lang:groovy></span>) sprawdza, czy skrypt nie został zmodyfikowany i jeśli tak: ładuje go ponownie. Technicznie woła właśnie metodę <span style="font-family:courier new;">isModified()</span> i jeśli zwróci ona prawdę, zawoła metodę <span style="font-family:courier new;">getScriptAsString()</span>. Ta ostatnia pobierze z bazy danych uaktualniony kod i <span style="font-style: italic;">voila</span>!<br /><br />Ponieważ ilość wywołań <span style="font-family:courier new;">ScriptDao.restore()</span>  jest znacząca, encja <span style="font-family:courier new;">Script </span>jest objęta cachem w Hibernate. Możliwe przypadki użycia są bardzo szerokie. Przykładowo administrator biznesowy modyfikuje skrypt w bazie za pomocą przyjaznego interfejsu webowego (jedyne odwołanie do bazy i aktualizacja cache) a w ciągu sekundy (ustawiono 1000 ms) Spring woła metodę <span style="font-family:courier new;">isModified()</span>. Ta wyciąga z cache nową wersję skryptu i zauważa, że data <span style="font-family:courier new;">lastModified</span> zmieniła się. Zwraca prawdę sugerując Springowi odświeżenie kodu. Metoda <span style="font-family:courier new;">getScriptAsString()</span> ponownie trafia w cache, znowu oszczędzając cenne zasoby bazy danych. A czemu nie zwracać w <span style="font-family:courier new;">isModified()</span> zawsze prawdy? Skoro i tak skrypt zawsze znajdziemy w cache, po co utrudniać sobie życie? Ano skrypt może i jest w cache, ale skoro się zmienił, to Spring musi go ponownie przetworzyć (zależy od języka: preprocesowanie, kompilacja, optymalizacja). Dlatego lepiej nakazywać odświeżanie tylko wtedy, gdy faktycznie skrypt został zmodyfikowany.<br /><br />Jak to wszystko się spina razem? Nasza definicja w <span style="font-family:courier new;">applicationContext.xml</span> wygląda teraz następująco:<br /><pre name="code" class="xml">&lt;lang:groovy id="customerVerifier" script-source="jpa:CustomerVerifier"<br />   refresh-check-delay="1000" autowire="byType" /></pre>Nasz "podrasowany" post procesor rozpoznaje prefiks "<span style="font-family:courier new;">jpa</span>" i przekazuje identyfikator skryptu "<span style="font-family:courier new;">CustomerVerifier</span>" (jeśli ktoś woli, może użyć numerycznego klucza) do nowoutworzonego obiektu <span style="font-family:courier new;">JpaScriptSource</span>. Obiekt ten jest następnie wykorzystywany przez wewnętrzną infrastrukturę Springa. Za jego pomocą framework załaduje skrypt z bazy (korzystając ze <span style="font-family:courier new;">ScriptDao</span>) - reszta jest poza naszą odpowiedzialnością.<br /><br />Naturalnie nic nie stoi na przeszkodzie, żeby zadeklarować wiele beanów &lt;lang:groovy>, przekazując po prefiksie "jpa" identyfikatory różnych skryptów z bazy. W ten sposób tworzymy całą aplikację opartą o trzon usług napisanych w Javie (beany springowe) oraz zbiór skryptów w Groovy (które można zmieniać w trakcie działania, np. poprzez interfejs webowy) realizujących szybkozmienną logikę biznesową. Taka architektura ma swoje wady i zalety, ktoś może też powiedzieć "OSGi dla ubogich". Ale na pewno warto ją rozważyć projektując duże systemy, gdzie elastyczność stoi na pierwszym miejscu.<br /><br />Na koniec kilka uwag. Testowanie jednostkowe tego rozwiązania jest mocno utrudnione. Ponieważ nie da się ładować skryptów leniwie jak innych beanów, skrypty muszą być w bazie w chwili wstawania kontekstu. Niestety, baza (ja używałem H2) tworzy się w pamięci przy starcie kontekstu a metoda oznaczona jako <span style="font-family:courier new;">@Before</span> uruchamia się dopiero później. Czyli nie da się wstawić skryptów przed startem kontekstu - bo wtedy nie ma jeszcze bazy - a później jest już za późno, bo kontekst i tak nie może wstać bez wstawionych skryptów :-(.<br /><br />Przy okazji chciałem użyć schematów (<span style="font-style: italic;">schema</span>) w PostgresQL, na którym testowałem JPA. O ile w bazie działają znakomicie, o tyle Hibernate nie radzi sobie z generacją kodu DDL: tworzy tabelki bez uprzedniego stworzenia schematów. Uniemożliwiło to dalsze korzystanie z dobrodziejstw tego mechanizmu, chociaż JPA wspiera nazwy schematów i gdy są już gotowe, wszystko śmiga. Błąd jest już zgłoszony do JIRA Hibernate (<a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-1853">HHH-1853</a>) - czeka 3 lata, rok w tą czy w tamtą nie zrobi różnicy :-(