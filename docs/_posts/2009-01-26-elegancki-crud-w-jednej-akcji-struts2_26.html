---
layout: post
title: Elegancki CRUD w jednej akcji Struts2 część 2/2
date: '2009-01-26T19:55:00.005+01:00'
author: Tomasz Nurkiewicz
tags:
- struts2
modified_time: '2009-03-28T22:21:35.919+01:00'
thumbnail: http://3.bp.blogspot.com/_P3ewsGQzHn0/SX4N_oFAnkI/AAAAAAAAAMM/cGBs0AarV58/s72-c/movies.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7772429110663069093
blogger_orig_url: https://www.nurkiewicz.com/2009/01/elegancki-crud-w-jednej-akcji-struts2_26.html
---

<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_P3ewsGQzHn0/SX4N_oFAnkI/AAAAAAAAAMM/cGBs0AarV58/s1600-h/movies.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 112px;" src="http://3.bp.blogspot.com/_P3ewsGQzHn0/SX4N_oFAnkI/AAAAAAAAAMM/cGBs0AarV58/s200/movies.png" alt="" id="BLOGGER_PHOTO_ID_5295685598575631938" border="0" /></a><br />Kontynuuję moją opowieść o Struts2, zamykając wątek z <a href="http://nurkiewicz.com/2009/01/elegancki-crud-w-jednej-akcji-struts2.html">części pierwszej</a>.<br /><br />W tak zwanym międzyczasie zacząłem czytać "<a href="http://www.amazon.com/Groovy-Action-Dierk-Koenig/dp/1932394842">Groovy in Action</a>", potem zobaczyłem też wpis na blogu <a href="http://jlaskowski.blogspot.com/2009/01/wieci-z-rozdziau-4-introduction-to.html">Jacka Laskowskiego</a>. Cóż, zaryzykuję stwierdzenie, że z punktu widzenia wygody programowania, wsparcia języka dla typowych czynności programistycznych (ale niestety również wydajności), Groovy ma się do Javy jak Java do C++. Jednym słowem jestem mocno oczarowany finezją tego języka: pętla for odchodzi do lamusa, dostajemy za to operator statku kosmicznego "&lt;=&gt;" i znakomite wsparcie dla kolekcji). Grails z kolei wzbudziło we mnie wątpliwość, czy kilkanaście stron tekstu by opisać CRUDa w Struts2, jednym z najpopularniejszych frameworków webowych w Javie to nie przesada...<br /><br />Jednak do Grooviego na pewno wrócę, a teraz dokończmy naszą aplikację webową w staroświeckiej i nieporadnej Javie (autor ww. książki ostrzegał, że po pierwszym zetknięciu z Groovy właśnie tak będzie wyglądał powrót do Javy ;-)). Przypomnę, że w pierwszej części artykułu zdołaliśmy zaledwie skonfigurować naszą aplikację i zdefiniować stos interceptorów. Co prawda ten domyślny też by się nadał, ale przymiotnik "elegancki" w tytule zobowiązuje :-).<br /><br />Zajmijmy się teraz konfiguracją właściwej akcji. Na razie bez pisania kodu dodajmy naszą nową akcję zajmującą się całym cyklem życia obiektu do deskryptora <span style="font-family:courier new;">struts-config.xml</span>. Jak zostało już wcześniej zdradzone, jedna klasa akcji zawiera szereg metod takich jak <span style="font-family:courier new;">list()</span>, <span style="font-family:courier new;">save()</span> czy<span style="font-family:courier new;"> show()</span>, a każda z nich odpowiada jednej logicznej akcji. Tag &lt;action&gt; posiada co prawda atrybut <span style="font-family:courier new;">method</span>, dzięki czemu definiując akcję definiujemy nie tylko klasę, ale jednocześnie metodę (jeśli chcemy użyć innej niż <span style="font-family:courier new;">execute()</span>). Dzięki niemu można umieścić w jednej klasie kilka metod i "wyprodukować" dzięki temu kilka akcji. Jednak deklarowanie wszystkich takich akcji explicite byłoby męczące, trudne w utrzymaniu i spotęgowałoby jedynie ilość XMLa. Na szczęście istnieje możliwość definiowania szeregu akcji za pomocą masek, co wyjaśni poniższy przykład:<br /><br /><pre name="code" class="xml"><br />&lt;action name="movie/*" method="{1}" class="moviesAction"&gt;<br />&lt;!-- [...] --&gt;<br />&lt;/action&gt;<br /></pre><br /><br />Nazwa akcji posiada maskę "*", a nazwa metody odwołuje się do zmiennej {1}, która, co jest chyba intuicyjne, odpowiada wartości pasującej do wspomnianej maski. Oznacza to, że jeśli przykładowo użytkownik wpisze adres "<span style="font-family:courier new;">movie/vote</span>", Struts2 wywoła metodę<span style="font-family:courier new;"> vote()</span> (oczywiście jeśli takowa istnieje i ma odpowiednią sygnaturę) klasy akcji. Z tą klasą też coś namieszałem - nie jest to bynajmniej pełna nazwa klasy z pakietem tylko… nazwa beanu springowego. Nie będę się jednak zajmował integracją Spring-Struts2, bo ani nie jest to przedmiotem naszego tutoriala, ani też nie stanowi specjalnej trudności. Szczegółów proszę szukać w kodzie źródłowym.<br /><br />Poszło szybko, zamiast definiować osobno 6 akcji (bo tyle ostatecznie napiszemy), różniących się jedynie metodą, wystarczył jeden generyczny zapis. By jednak uzupełnić mapowania rezultatów akcji na widoki, zastanówmy się jednak co mogą zwracać nasze poszczególne akcje. Ja przyjąłem następujące założenia:<br /><br /><span style="font-style: italic; font-weight: bold;font-family:courier new;">list</span><span style="font-weight: bold;"> </span>- przejście do widoku listy wszystkich filmów<br /><br /><span style="font-style: italic; font-weight: bold;font-family:courier new;">redirectList </span>- jw. ale poprzez wysłanie użytkownikowi kodu <span style="font-family:courier new;">redirect</span>. Przydatne np. gdy usuwamy film i chcemy przenieść użytkownika na listę filmów, pozbawioną już właśnie usuniętego obiektu. Zwykłe przeniesienie na widok jak w przypadku rezultatu <span style="font-family:courier new;">list</span> spowodowałoby, że w URLu ciągle widniałby adres <span style="font-family:courier new;">movie/delete?id=123</span>, co niechybnie doprowadziłoby do błędy w przypadku odświeżenia strony (wzorzec GET after POST).<br /><br /><span style="font-weight: bold; font-style: italic;font-family:courier new;">input </span>- wyświetlenie widoku umożliwiającego edycję szczegółów filmu. Przyjąłem przy tym, że na stosie wartości powinna się znaleźć zmienna <span style="font-family:courier new;">id</span> - jeśli jej wartość jest zerowa, widok służy do wprowadzenia danych nowego filmu. Inna wartość oznacza edycję już istniejącego filmu. Trochę konserwatywnie, ale pliki JSP zawsze można dopasować do własnych potrzeb.<br /><br /><span style="font-weight: bold; font-style: italic;font-family:courier new;">show </span>- wysyła użytkownikowi komunikat <span style="font-family:courier new;">redirect</span> do akcji <span style="font-family:courier new;">movie/show</span> zawierający parametr <span style="font-family:courier new;">id</span>. Przydatne po akcjach zmieniających stan filmu, gdy chcemy wyświetlić jego szczegóły w trybie tylko tylko do odczytu. Znowu nie można zwyczajnie przekierować akcji do widoku ze względu na "trefny URL" (patrz rezultat <span style="font-family:courier new;">redirectList</span>)<br /><br /><span style="font-weight: bold; font-style: italic;font-family:courier new;">success </span>- domyślny rezultat, wyświetla szczegóły filmu. Przydatny np. gdy klikamy na liście na konkretny film - odświeżenie widoku nie zrobi krzywdy aplikacji.<br /><br />Bogatsi o taką wiedzę możemy ją zakodować w XMLu :-):<br /><br /><pre name="code" class="xml"><br />&lt;action name="movie/*" method="{1}" class="moviesAction"&gt;<br />&lt;result name="list"&gt;list.jsp&lt;/result&gt;<br />&lt;result name="redirectList" type="redirectAction"&gt;movie/list&lt;/result&gt;<br />&lt;result name="input"&gt;input.jsp&lt;/result&gt;<br />&lt;result name="show" type="redirectAction"&gt;<br />   &lt;param name="actionName"&gt;movie/show&lt;/param&gt;<br />   &lt;param name="id"&gt;${id}&lt;/param&gt;<br />&lt;/result&gt;<br />&lt;result&gt;show.jsp&lt;/result&gt;<br />&lt;/action&gt;<br /></pre><br /><br />Tam gdzie mówiliśmy o wysłaniu użytkownikowi komunikatu <span style="font-family:courier new;">redirect</span>, używany jest rezultat typu <span style="font-family:courier new;">redirectAction</span>, w pozostałych przypadkach domyślny rezultat przekazuje sterowanie do pliku JSP. Zastanawiające może być jedynie mapowanie rezultatu <span style="font-family:courier new;">show</span>. Otóż chcemy wysłać do użytkownika komunikat <span style="font-family:courier new;">redirect </span>do akcji <span style="font-family:courier new;">movie/show</span>. Jednak nic mu po tym, jeśli nie będzie wiedział, o film z jakim <span style="font-family:courier new;">id </span>ma poprosić. Stąd dodatkowy parametr, który de facto spowoduje odesłanie komunikatu redirect do URLa <span style="font-family:courier new;">movie/show?id=123</span>, gdzie 123 to wartość dostępna pod nazwą <span style="font-family:courier new;">id </span>na stosie wartości. Zapis klamrowy "<span style="font-family:courier new;">${id}</span>" jest konieczny, ponieważ domyślnie w tym miejscu Struts2 nie interpretuje napisów jako wyrażeń OGNL.<br /><br />Z wielkim smutkiem oznajmiam, że koniec programowania w XMLu, wracamy do Javy :-). Ponieważ wszystkie akcje typu CRUD są podobne, postanowiłem stworzyć klasę bazową <span style="font-family:courier new;">AbstractCrudAction&lt;E&gt;</span> definiującą podstawowe operacje, implementującą wspólne funkcje i kilka pożytecznych interfejsów. Aha, typ generyczny <span style="font-family:courier new;">E</span> to typ obiektu dziedziny, jakim zarządzamy, czyli w naszym wypadku <span style="font-family:courier new;">Movie</span>. Oto nasza klasa bazowa w całej okazałości:<br /><br /><pre name="code" class="java"><br />public abstract class AbstractCrudAction&lt;E&gt; extends ActionSupport implements ModelDriven&lt;E&gt;, Preparable {<br /><br />public static final String LIST = "list";<br />public static final String REDIRECT_LIST = "redirectList";<br />public static final String SHOW = "show";<br /><br />protected E model;<br /><br />protected List&lt;E&gt; list;<br /><br />public E getModel() {<br />     return model;<br />}<br /><br />public List&lt;E&gt; getList() {<br />     return list;<br />}<br /><br />public String create() {<br />     return INPUT;<br />}<br /><br />public abstract void prepareList();<br /><br />public String list() {<br />     return LIST;<br />}<br /><br />public abstract void prepareShow();<br /><br />public String show() {<br />     if(model == null) {<br />           addActionError(getText("error.not_found"));<br />           return REDIRECT_LIST;<br />      }<br />   return SUCCESS;<br />}<br /><br />public abstract void prepareEdit();<br /><br />public String edit() {<br />     return INPUT;<br />}<br /><br />public abstract void prepareDelete();<br /><br />public abstract String delete();<br /><br />public abstract void prepareSave();<br /><br />public abstract String save();<br /><br />public abstract void prepareUpdate();<br /><br />public abstract String update();<br /><br />public void prepare() throws Exception {<br />}<br />}<br /></pre><br /><br />Warto nadmienić o kilku, nie do końca jasnych elementach tej klasy. Po pierwsze implementuje ona dwa interfejsy, oba niezmiernie ciekawe. <span style="font-family:courier new;">ModelDriven&lt;E&gt;</span>, za sprawą interceptora <span style="font-family:courier new;">modelDriven </span>(polecam poczytanie kodu źródłowego klasy <a href="http://struts.apache.org/2.1.6/struts2-core/apidocs/com/opensymphony/xwork2/interceptor/ModelDrivenInterceptor.html">ModelDrivenInterceptor</a>, dobry start do zrozumienia działania interceptorów i pisania własnych) rozdziela logikę (akcję) od modelu danych (w naszym wypadku filmu). Brzmi strasznie a ogranicza się do tego, że interceptor dla wszystkich akcji implementujących ten interfejs wywołuje metodę <span style="font-family:courier new;">getModel()</span>, która powinna zwrócić typ <span style="font-family:courier new;">E</span>, i umieszcza zwrócony obiekt na szczycie stosu wartości. Ma to ogromną zaletę nad ręcznym implementowanie metody <span style="font-family:courier new;">getMovie()</span> czy podobnej - ponieważ nasz obiekt dziedziny znajduje się bezpośrednio na szycie stosu, w widoku możemy używać prostych wyrażeń OGNL takich jak "<span style="font-family:courier new;">title</span>" czy w przyszłości "<span style="font-family:courier new;">actors[0]</span>" - gdybyśmy w akcji mieli metodę<span style="font-family:courier new;"> getMovie()</span>, używalibyśmy odpowiednio "<span style="font-family:courier new;">movie.title</span>", "<span style="font-family:courier new;">movie.actors[0]</span>", etc. Oczywiście zgodnie z działaniem stosu wartości, jeśli dana właściwość nie zostanie znaleziona w modelu na szycie stosu, framework szuka niżej we właściwościach akcji itd.<br /><br />Interfejs <span style="font-family:courier new;">ModelDriven </span>przypomina zatem <span style="font-family:courier new;">FormBeany </span>ze Struts1, jednak znacznie lepiej zaprojektowane. Zatem jeśli Wasza akcja ewidentnie zajmuje się określonym obiektem dziedziny, nie ma sensu tworzyć dla niego specjalnej metody get*() w klasie (lub przemapowywać właściwości obiektu na właściwości klasy).<br /><br />Z metodą<span style="font-family:courier new;"> getModel()</span> i interceptorem <span style="font-family:courier new;">modelDriven </span>jest jednak pewien problem: interceptor działa przed akcją, zatem jeśli przyszło Wam do głowy przypisać zmiennej zwracanej przez <span style="font-family:courier new;">getModel()</span> wartość w metodzie <span style="font-family:courier new;">execute()</span> lub analogicznej, to nie zadziała. Wcześniej interceptor wywoła <span style="font-family:courier new;">getModel()</span> i zingoruje zwróciny null - żaden pożytek :-). Oczywiście nie wspominałbym o tym, gdybym nie znał rozwiązania, które przy okazji zwiększy jakość naszej akcji - interfejs <span style="font-family:courier new;">Preparable</span>!<br /><br />Interfejs ten działa analogicznie do interfejsu <span style="font-family:courier new;">modelDriven </span>- specjalny interceptor sprawdza, czy nasza akcja przypadkiem nie implementuje <span style="font-family:courier new;">Preparable </span>i jeśli tak - wywołuje metodę prepare() tego interfejsu. Jednak jak widać na powyższym kodzie, my z tej funkcjonalności nie korzystamy. Mamy jednak po jednej metodzie <span style="font-family:courier new;">prepare*()</span> dla każdej metody akcji: <span style="font-family:courier new;">prepareList()</span>, <span style="font-family:courier new;">prepareSave()</span>, etc. Jak łatwo się domyśleć, metody te są wołane tylko dla akcji związanych z określoną metodą - podczas gdy samo <span style="font-family:courier new;">prepare()</span> jest najpierw dla każdej akcji.<br /><br />Jak widać we wszystkich wypadkach metody <span style="font-family:courier new;">prepare*()</span> są abstrakcyjne, a właściwe metody akcji nie zawsze! Dla przykładu metoda <span style="font-family:courier new;">prepareEdit()</span> najpierw przygotowuje dane dla akcji <span style="font-family:courier new;">edit()</span>, (chociażby ładując obiekt z bazy danych). O ile tylko konkretna klasa (np. <span style="font-family:courier new;">MoviesAction</span>) wie jaki obiekt należy załadować, o tyle implementacja metody <span style="font-family:courier new;">edit()</span> jest zawsze taka sama - i można ją zaimplementować w klasie bazowej.<br /><br />Takie podejście nie tylko zapewnia ładniejszy kod, separując fazę przygotowania danych i inicjalizacji innych struktur od właściwej logiki biznesowej. Dzięki wspomnianemu stosowi interceptorów <span style="font-family:courier new;">paramsPrepareParams</span>, możemy zastosować pewną bardzo elegancką sztuczkę. Niestety jej omówienie nieco odbiega poza zakres tego tutorialu, zainteresowanych odsyłam do opisu w pliku <span style="font-family:courier new;">struts-default.xml</span> w JARze ze Strutsami - ew. kiedyś może skuszę się na pełniejszy opis. W skrócie sztuczka polega na tym, że najpierw framework czyta z requestu jedynie <span style="font-family:courier new;">id</span>, potem w <span style="font-family:courier new;">prepareUpdate()</span> ładujemy oryginalny obiekt z bazy by w drugim uruchomieniu interceptora <span style="font-family:courier new;">params </span>nanieść na oryginalny obiekt zmiany nadesłane od użytkownika. Całość jedynie zapisujemy w <span style="font-family:courier new;">update()</span>.<br /><br />Tytułem wyjaśnienia - zmienna <span style="font-family:courier new;">model </span>została już omówiona, natomiast zmienna <span style="font-family:courier new;">list </span>jest wykorzystywana jedynie przy wyświetlaniu listy. Okazuje się bowiem, że wszystkie pozostałe akcje korzystają z pojedynczej instancji klasy modelu, a tylko <span style="font-family:courier new;">list()</span> potrzebuje całej listy. Mała, ale chyba wybaczalna niekonsekwencja. Wytłumaczę się również z terminologii - <span style="font-family:courier new;">edit()</span> i <span style="font-family:courier new;">create()</span> to akcje wyświetlające formularze edycji, natomiast <span style="font-family:courier new;">update()</span> i<span style="font-family:courier new;"> save()</span> służą do zapisania odpowiednio zmian lub nowego obiektu.<br /><br />Może jeszcze wytłumaczę się ze szczątkowej logiki w <span style="font-family:courier new;">show()</span>. Otóż klasa zakłada, że zaimplementowana w klasie dziedziczącej metoda <span style="font-family:courier new;">prepareShow()</span> zajmie się zapisaniem w zmiennej <span style="font-family:courier new;">model </span>obiektu do wyświetlenia. Jeśli metoda tego nie zrobiła lub nie odnalazła odpowiedniego obiektu - <span style="font-family:courier new;">show()</span> wraca do widoku listy z komunikatem o błędzie. Tutaj widać zastosowanie interceptora <span style="font-family:courier new;">store</span>: dodajemy komunikat o błędzie, ale potem robimy <span style="font-family:courier new;">redirect </span>do listy - bez tego interceptora komunikat by zniknął.<br /><br />Podkreślę po raz pierwszy, ale nie ostatni, że ta jedna klasa wspierać będzie CRUD dla dowolnych obiektów modelu, uwalniając nas od kilku męczących szczegółów. Pora zatem przejść do konkretnej implementacji:<br /><br /><pre name="code" class="java"><br />public class MoviesAction extends AbstractCrudAction&lt;Movie&gt; {<br /><br />private MoviesDao moviesDao;<br /><br />private long id;<br /><br />public void setId(long id) {<br />this.id = id;<br />}<br /><br />public long getId() {<br />     return id;<br />}<br /><br />@Override<br />public void prepareList() {<br />     list = moviesDao.getAllMovies();<br />}<br /><br />@Override<br />public void prepareShow() {<br />      model = moviesDao.getMovie(id);<br />}<br /><br />@Override<br />public void prepareEdit() {<br />     model = moviesDao.getMovie(id);<br />}<br /><br />@Override<br />public void prepareSave() {<br />     model = new Movie();<br />}<br /><br />@Override<br />public String save() {<br />     moviesDao.saveMovie(model);<br />     return SHOW;<br />}<br /><br />@Override<br />public void prepareUpdate() {<br />     model = moviesDao.getMovie(id);<br />}<br /><br />@Override<br />public String update() {<br />     moviesDao.updateMovie(model);<br />     return SHOW;<br />}<br /><br />@Override<br />public void prepareDelete() {<br />     model = moviesDao.getMovie(id);<br />}<br /><br />@Override<br />public String delete() {<br />     moviesDao.deleteMovie(model);<br />     return REDIRECT_LIST;<br />}<br /><br />public void setMoviesDao(MoviesDao moviesDao) {<br />     this.moviesDao = moviesDao;<br />}<br />}<br /></pre><br /><br /><span style="font-family:courier new;">MoviesDao </span>jest interfejsem wstrzykiwanym przez Springa - konkretna implementacja nie jest istotna. Najważniejsze, że dotarliśmy szczęśliwie do celu:  oto właściwa akcja implementująca pełen cykl CRUD składa się z samych jednolinijkowców, żadnej logiki, sama esencja - odczyt bądź zapis z wykorzystaniem DAO (dla przeciwników tego wzorca, wstrzyknięcie bezpośrednio EntityManagera też by się sprawdziło). Jeśli chcemy zaimplementować CRUD dla innego obiektu z modelu, właściwie wystarczy zaimplementować również prostą akcję dziedziczącą po <span style="font-family:courier new;">AbstractCrudAction&lt;E&gt;</span>.<br /><br />No, nie tylko - jeszcze warstwa prezentacji, która siłą rzeczy musi się różnić. Ale o niej mówić nie będę, zainteresowanych JSPami odsyłam do kodu źródłowego. Warto zerknąć na <span style="font-family:courier new;">list.jsp</span> (użyłem <a href="http://displaytag.sourceforge.net/1.2/">displaytaga</a>, biblioteki, której warto poświęcić osobny wpis… kiedyś) oraz na <span style="font-family:courier new;">input.jsp</span> (jeden prosty atrybut <span style="font-family:courier new;">validate="true"</span> i Strutsy wygenerują nam śliczną walidację po stronie w klienta w JavaScripcie). Właśnie: nie wspomniałem też o walidacji (nie mogłem skorzystać z adnotacji, ponieważ musiałbym nimi udekorować obiekt dziedziny, co jest kiepskim pomysłem) oraz internacjonalizacji. Znowu odsyłam do kodu aplikacji.<br /><br />To by było na tyle, niestety z przykrością muszę powiadomić o kolejnym zgrzycie w wersji 2.1.6, który już wcześniej dawał mi się we znaki. Przy wysyłaniu <span style="font-family:courier new;">redirect </span>do klienta z parametrem <span style="font-family:courier new;">id = ${id}</span>, chociaż zupełnie poprawne i działa, powoduje pojawienie się logu na poziomie ERROR z komunikatem:<br /><br /><span style="font-family:courier new;">2009-01-25 22:21:55,947 ERROR [CommonsLogger.java:27] : Unable to set parameter [id] in result of type [org.apache.struts2.dispatcher.ServletActionRedirectResult]</span><br /><span style="font-family:courier new;">Caught OgnlException while setting property 'id' on type 'org.apache.struts2.dispatcher.ServletActionRedirectResult'. - Class: ognl.ObjectPropertyAccessor</span><br /><span style="font-family:courier new;">File: ObjectPropertyAccessor.java</span><br /><span style="font-family:courier new;">Method: setProperty</span><br /><span style="font-family:courier new;">Line: 132 - ognl/ObjectPropertyAccessor.java:132:-1</span><br /><span style="font-family:courier new;"> at com.opensymphony.xwork2.ognl.OgnlUtil.internalSetProperty(OgnlUtil.java:392)</span><br /><span style="font-family:courier new;"> […]</span><br /><br />Nie jest to nasz błąd, zwyczajnie twórcy Struts2 nie mogą się zdecydowanie, na jakim poziomie zalogować tą informację: <a href="https://issues.apache.org/struts/browse/WW-1714">Using the Redirect Action Result with parameters to the target action causes an OGNL warning</a>. BTW mój problem z myślnikiem w <span style="font-family:courier new;">groupId </span>okazał się być przypadłością mavena, mogłem sprawdzić z innym archetypem, mea culpa. Podziękowania dla <a href="http://jdn.pl/blog/416">Łukasza Lenarta</a> za komentarz.<br /><br /><br /><br />Zgodnie z obietnicą <a href="http://sites.google.com/site/nurkiewicz/Home/zalaczniki/struts2-crud.zip">kod przykładowej aplikacji</a>, wystarczy <span style="font-family:courier new;">mvn jetty:run</span> by odrobinkę sobie poklikać. Jeśli w moim zdecydowanie przydługim opisie pominąłem jakiś ważny szczegół, proszę o informację.<br /><br />P.S.: Mój Eclipse Ganymede (3.4.1) wyświetla idiotyczny błąd w plikach JSP korzystających z displaytaga:<br /><br /><span style="font-family:courier new;">Syntax error on token "}", delete this token</span><br /><br />W linii… 0 pliku JSP. Jeśli ktoś spotkał się z podobną przypadłością (albo jeszcze lepiej udało mu się ją zwalczyć), byłbym wdzięczny za info :-).