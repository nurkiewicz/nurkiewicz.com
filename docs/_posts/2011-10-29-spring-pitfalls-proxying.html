---
layout: post
title: 'Spring pitfalls: proxying'
date: '2011-10-29T11:10:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- transactions
- aop
- scala
- spring
modified_time: '2011-11-17T19:29:51.245+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-624144439922682448
blogger_orig_url: https://www.nurkiewicz.com/2011/10/spring-pitfalls-proxying.html
---

<br /><div>Being a Spring framework user and enthusiast for many years I came across several misunderstandings and problems with this stack. Also there are places where abstractions leak terribly and to effectively and safely take advantage of all the features developers need to be aware of them. That is why I am starting a <i>Spring pitfalls series</i>. In the first part we will take a closer look at how proxying works.</div><div><br /></div><div>Bean proxying is an essential and one of the most important infrastructure features provided by Spring. It is so important and low-level that for most of the time we don't even realize that it exists. However transactions, aspect-oriented programming, advanced scoping, <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-annotation-support-async">@Async</a>support and various other domestic use-cases wouldn't be possible without it. So what is <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-proxying">proxying</a>?</div><div><br /></div><div>Here is an example: when you inject DAO into service, Spring takes DAO instances and injects it directly. That's it. However sometimes Spring needs to be aware of each and every call made by service (and any other bean) to DAO. For instance if DAO is marked transactional it needs to start a transaction before call and commit or rolls back afterwards. Of course you can do this manually, but this is tedious, error-prone and mixes concerns. That's why we use declarative transactions on the first place.</div><div><br /></div><div>So how does Spring implement this interception mechanism? There are three methods from simplest to most advanced ones. I won't discuss their advantages and disadvantages yet, we will see them soon on a concrete examples.</div><div><br /></div><h4>  Java dynamic proxies</h4><div>Simplest solution. If DAO implements any interface, Spring will create a Java <a href="http://www.ibm.com/developerworks/java/library/j-jtp08305/index.html">dynamic proxy</a> implementing that interface(s) and inject it instead of the real class. The <i>real</i> one still exists and the proxy has reference to it, but to the outside world – the proxy is the bean. Now every time you call methods on your DAO, Spring can intercept them, add some AOP magic and call the original method.</div><div style="font-style: normal; margin-bottom: 0cm;"><br /></div><h4>  CGLIB generated classes</h4><div>The downside of Java dynamic proxies is a requirement on the bean to implement at least one interface. CGLIB works around this limitation by dynamically subclassing the original bean and adding interception logic directly by overriding every possible method. Think of it as subclassing the original class and calling super version amongst other things:<br /><a name='more'></a></div><div><br /><br /></div><pre class="brush: scala"><br />class DAO {<br />  def findBy(id: Int) = //...<br />}<br /><br />class DAO$EnhancerByCGLIB extends DAO {<br />  override def findBy(id: Int) = {<br />    startTransaction<br />    try {<br />      val result = super.findBy(id)<br />      commitTransaction()<br />      result<br />    } catch {<br />      case e =&gt;<br />        rollbackTransaction()<br />        throw e<br />    }<br />  }<br />}<br /></pre><br /><div><br /><br /></div>However, this pseudocode does <b>not</b>illustrate how it works in reality – which introduces yet another problem, stay tuned. BTW all examples will be in Scala, live with that and get used to it.<br /><br /><br /><h4>  AspectJ weaving</h4>This is the most invasive but also the most reliable and intuitive solution from the developer perspective. In this mode interception is applied directly to your class bytecode which means the class your JVM runs is not the same as the one you wrote. AspectJ weaver adds interception logic by directly modifying your bytecode of your class, either during build – <i>compile time weaving</i>(<i>CTW</i>) or when loading a class – <i>load time weaving</i>(<i>LTW</i>).<br /><br /><br /><br />If you are curious how AspectJ magic is implemented under the hood, here is a decompiled and simplified .class file compiled with AspectJ weaving beforehand:<br /><div><br /><br /></div><div><pre class="brush: java"><br />public void inInterfaceTransactional()<br />{<br />  try<br />  {<br />    AnnotationTransactionAspect.aspectOf().ajc$before$1$2a73e96c(this, ajc$tjp_2);<br />    throwIfNotInTransaction();<br />  }<br />  catch(Throwable throwable)<br />  {<br />    AnnotationTransactionAspect.aspectOf().ajc$afterThrowing$2$2a73e96c(this, throwable);<br />    throw throwable;<br />  }<br />  AnnotationTransactionAspect.aspectOf().ajc$afterReturning$3$2a73e96c(this);<br />}<br /><br /></pre></div><div><br /><br /></div><div>With load time weaving the same transformation occurs at runtime, when the class is loaded. As you can see there is nothing disturbing here, in fact this is exactly how you would program the transactions manually. Side note: do you remember the times when viruses were appending their code into executable files or dynamically injecting themselves when executable was loaded by the operating system?</div><div><br /><br /></div><div>Knowing proxy techniques is important to understand how proxying works and how it affects your code. Let us stick with declarative transaction demarcation example, here is our battlefield:</div><div><br /><br /></div><div><pre class="brush: scala"><br />trait FooService {<br />  def inInterfaceTransactional()<br />  def inInterfaceNotTransactional();<br />}<br /><br />@Service<br />class DefaultFooService extends FooService {<br /><br />  private def throwIfNotInTransaction() {<br />    assume(TransactionSynchronizationManager.isActualTransactionActive)<br />  }<br /><br />  def publicNotInInterfaceAndNotTransactional() {<br />    inInterfaceTransactional()<br />    publicNotInInterfaceButTransactional()<br />    privateMethod();<br />  }<br /><br />  @Transactional<br />  def publicNotInInterfaceButTransactional() {<br />    throwIfNotInTransaction()<br />  }<br /><br />  @Transactional<br />  private def privateMethod() {<br />    throwIfNotInTransaction()<br />  }<br /><br />  @Transactional<br />  override def inInterfaceTransactional() {<br />    throwIfNotInTransaction()<br />  }<br /><br />  override def inInterfaceNotTransactional() {<br />    inInterfaceTransactional()<br />    publicNotInInterfaceButTransactional()<br />    privateMethod();<br />  }<br />}<br /><br /></pre></div><div><br /><br /></div><div>Handy <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">throwIfNotInTransaction()</span> method... throws exception when not invoked within a transaction. Who would have thought? This method is called from various places and different configurations. If you examine carefully how methods are invoked – this should all work. However our developers' life tend to be brutal. First obstacle was unexpected: <a href="http://scalatest.org/">ScalaTest</a> does not support Spring integration <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/testing.html">testing</a>via dedicated runner. Luckily this can be easily ported with a simple trait (handles dependency injection to test cases and application context caching):</div><div><br /><br /></div><div><pre class="brush: scala"><br />trait SpringRule extends AbstractSuite { this: Suite =&gt;<br /><br />  abstract override def run(testName: Option[String], reporter: Reporter, stopper: Stopper, filter: Filter, configMap: Map[String, Any], distributor: Option[Distributor], tracker: Tracker) {<br />    new TestContextManager(this.getClass).prepareTestInstance(this)<br />    super.run(testName, reporter, stopper, filter, configMap, distributor, tracker)<br />  }<br /><br />}<br /></pre></div><div><br /><br /></div><div>Note that we are not starting and rolling back transactions like the <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/testing.html#testing-tx">original</a>testing framework. Not only because it would interfere with our demo but also because I find transactional tests harmful – but more on that in the future. Back to our example, here is a smoke test. The complete source code can be downloaded <a href="https://github.com/nurkiewicz/spring-pitfalls">here</a>from <a href="https://github.com/nurkiewicz/spring-pitfalls/tree/proxy-problem">proxy-problem</a>branch. Don't complain about the lack of assertions – here we are only testing that exceptions are not thrown:</div><div><br /><br /></div><div><pre class="brush: scala"><br />@RunWith(classOf[JUnitRunner])<br />@ContextConfiguration<br />class DefaultFooServiceTest extends FunSuite with ShouldMatchers with SpringRule{<br /><br />  @Resource<br />  private val fooService: FooService = null<br /><br />  test("calling method from interface should apply transactional aspect") {<br />    fooService.inInterfaceTransactional()<br />  }<br /><br />  test("calling non-transactional method from interface should start transaction for all called methods") {<br />    fooService.inInterfaceNotTransactional()<br />  }<br /><br />}<br /></pre></div><div><br /><br /></div><div>Surprisingly, the test fails. Well, if you've been reading my articles for a while you shouldn't be surprised: <a href="http://nurkiewicz.com/2009/08/spring-aop-riddle.html">Spring AOP riddle</a> and <a href="http://nurkiewicz.com/2009/09/spring-aop-riddle-demystified.html">Spring AOP riddle demystified</a>. Actually, the Spring reference documentation explains this in <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-understanding-aop-proxies">great detail</a>, also check out <a href="http://stackoverflow.com/questions/3037006">this</a>SO question. In short – non transactional method calls transactional one but <b>bypassing</b> the transactional proxy. Even though it seems obvious that when inInterfaceNotTransactional() calls inInterfaceTransactional() the transaction should start – it does not. The abstraction leaks. By the way also check out fascinating <a href="http://www.ibm.com/developerworks/java/library/j-ts1/index.html">Transaction strategies: Understanding transaction pitfalls</a> article for more.</div><div><br /><br /></div><div>Remember our example showing how CGLIB works? Also knowing how polymorphism works it seems like using class based proxies should help. <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">inInterfaceNotTransactional()</span> now calls <span class="Apple-style-span" style="font-family: 'Courier New',Courier,monospace;">inInterfaceTransactional()</span>overriden by CGLIB/Spring, which in turns calls the original classes. <b>Not a chance!</b> This is the real implementation in pseudo-code:</div><div><br /><br /></div><div><pre class="brush: scala"><br />class DAO$EnhancerByCGLIB extends DAO {<br /><br />  val target: DAO = ...<br /><br />  override def findBy(id: Int) = {<br />    startTransaction<br />    try {<br />      val result = target.findBy(id)<br />      commitTransaction()<br />      result<br />    } catch {<br />      case e =&gt;<br />        rollbackTransaction()<br />        throw e<br />    }<br />  }<br />}<br /></pre></div><div><br /><br /></div><div>Instead of subclassing and instantiating subclassed bean Spring first creates the original bean and then creates a subclass which wraps the original one (somewhat <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</a>pattern) in one of the post processors. This means that – again – the self call inside bean bypasses AOP proxy around our class. Of course using CGLIB changes how are bean behaves in few other ways. For instance we can now inject concrete class rather than an interface, in fact the interface is not even needed and CGLIB proxying is required in this circumstances. There are also drawbacks – constructor injection is no longer possible, see <a href="https://jira.springsource.org/browse/SPR-3150">SPR-3150</a>, which is a <a href="http://nurkiewicz.com/2011/09/evolution-of-spring-dependency.html">shame</a>. So what about some more thorough tests?</div><div><br /><br /></div><div><pre class="brush: scala"><br />@RunWith(classOf[JUnitRunner])<br />@ContextConfiguration<br />class DefaultFooServiceTest extends FunSuite with ShouldMatchers with SpringRule {<br /><br />  @Resource<br />  private val fooService: DefaultFooService = null<br /><br />  test("calling method from interface should apply transactional aspect") {<br />    fooService.inInterfaceTransactional()<br />  }<br /><br />  test("calling non-transactional method from interface should start transaction for all called methods") {<br />    fooService.inInterfaceNotTransactional()<br />  }<br /><br />  test("calling transactional method not belonging to interface should start transaction for all called methods") {<br />    fooService.publicNotInInterfaceButTransactional()<br />  }<br /><br />  test("calling non-transactional method not belonging to interface should start transaction for all called methods") {<br />    fooService.publicNotInInterfaceAndNotTransactional()<br />  }<br /><br />}<br /></pre></div><div><br /><br /></div><div>Please pick tests that will fail (pick exactly two). Can you explain why? Again common sense would suggest that everything should pass, but that's not the case. You can play around yourself, see <a href="https://github.com/nurkiewicz/spring-pitfalls/tree/class-based-proxy">class-based-proxy</a>branch.</div><div><br /><br /></div><div>We are not here to expose problems but to overcome them. Unfortunately our tangled service class can only be fixed using heavy artillery – true AspectJ weaving. Both compile- and load-time weaving makes the test pass. See <a href="https://github.com/nurkiewicz/spring-pitfalls/tree/aspectj-ctw">aspectj-ctw</a>and <a href="https://github.com/nurkiewicz/spring-pitfalls/tree/aspectj-ltw">aspectj-ltw</a>branches accordingly.</div><div><br /><br /></div><div>You should now be asking yourself several question. <i>Which approach should I take</i>(or: <i>do I really need to use AspectJ?</i>) and <i>why should I even bother?</i> – amongst others. I would say – in most cases simple Spring proxying will suffice. But you absolutely have to be aware of how does the propagation work and when it doesn't. Otherwise bad things happen. Commits and rollbacks occurring in unexpected places, spanning unexpected amount of data, ORM <a href="http://stackoverflow.com/questions/82429">dirty checking</a> not working, invisible records – believe, this things happen on wild. And remember that topics we have covered here apply to all AOP aspects, not only transactions.</div>