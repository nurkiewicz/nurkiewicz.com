---
layout: post
title: Elegance vs. simplicity
date: '2010-03-14T19:59:00.004+01:00'
author: Tomasz Nurkiewicz
tags:
- esb
- warsaw-jug
- mule
- design patterns
modified_time: '2010-05-16T18:42:16.614+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7545374834689080778
blogger_orig_url: https://www.nurkiewicz.com/2010/03/elegance-vs-simplicity.html
---

Few weeks ago I had pleasure to give a speech "<span style="font-style: italic;">Mule ESB vs. Apache ServiceMix</span>" at <a href="http://groups.google.com/group/warszawa-jug">Warsaw Java Users Group</a>, together with <a href="http://blog.dywicki.pl/">Łukasz Dywicki</a>. During this live coding session I have been implementing some simple integration logic using <a href="http://www.mulesoft.org/display/MULE">Mule ESB</a>, while Łukasz did the same with <a href="http://servicemix.apache.org/">ServiceMix</a>. The presentation went pretty good, you can find source code <a href="http://github.com/nurkiewicz/wjug-money">here</a>.<br /><br />While preparing for the speech I have discovered some bug (see <a href="http://www.mulesoft.org/jira/browse/MULE-4708">MULE-4708</a>) in Mule ESB 2.2.1. My patch has been applied in less than 10 hours after submitting, which is quite impressive. Sadly, the ESB’s code I had to study to track down the bug was not so impressive, at least that was my first impression. Just take a look at this excerpt from <span style="font-family:courier new;">org.mule.transport.jms.JmsMessageUtils</span>, that takes literally any object and converts it into proper JMS message type:<br /><br /><pre class="brush: java">public static Message toMessage(Object object, Session session) throws JMSException {<br />      if (object instanceof Message) {<br />          return (Message) object;<br />      } else if (object instanceof String) {<br />          return session.createTextMessage((String) object);<br />      } else if (object instanceof Map) {<br />          MapMessage mMsg = session.createMapMessage();<br />          Map src = (Map) object;<br />          //...<br />          return mMsg;<br />      } else if (object instanceof InputStream) {<br />          StreamMessage sMsg = session.createStreamMessage();<br />          InputStream temp = (InputStream) object;<br />          return sMsg;<br />      } else if (object instanceof List) {<br />          StreamMessage sMsg = session.createStreamMessage();<br />          List list = (List) object;<br />          //...<br />          return sMsg;<br />      } else if (object instanceof byte[]) {<br />          BytesMessage bMsg = session.createBytesMessage();<br />          bMsg.writeBytes((byte[]) object);<br />          return bMsg;<br />      } else if (object instanceof Serializable) {<br />          ObjectMessage oMsg = session.createObjectMessage((Serializable) object);<br />          return oMsg;<br />      } else if (object instanceof OutputHandler) {<br />          BytesMessage bMsg = session.createBytesMessage();<br />          //...<br />          return bMsg;<br />      } else {<br />          throw new JMSException("");<br />      }<br />}</pre><br /><br />Something is obviously wrong with this code. When doing OOP you should never depend on exact type of objects, and certainly not ask them about it. In OOP each object should be responsible for itself and make decisions – here, client code makes decision externally. Of course there is no <span style="font-family:courier new;">toJmsMessage()</span> method in Object class (similar to <span style="font-family:courier new;">toString()</span>), ready to be overridden. <a href="http://nurkiewicz.com/2009/03/wzorzec-visitor-realny-przykad.html">Visitor pattern</a> is also not applicable here, so not much can be done. Least we can do is to make this if-else-if-else monster go away. Instead my idea is to use a map from class to class-specific transformer. This map could be modified externally, so other types of JMS messages and supported types can be added without the need to add another conditional branch.<br /><br />This map would look something like this:<br /><br /><pre class="brush: java">private Map&lt;Class&lt;?&gt;, MessageTransformer&gt; transformers = new LinkedHashMap&lt;Class&lt;?&gt;, MessageTransformer&gt;();<br /><br />public Message toMessage(Object object, Session session) throws JMSException {<br />      Validate.notNull(object);<br />      for (Map.Entry&lt;Class&lt;?&gt;, MessageTransformer&gt; transformerEntry : transformers.entrySet()) {<br />          if (transformerEntry.getKey().isInstance(object))<br />              return transformerEntry.getValue().transform(object, session);<br />      }<br />      throw new IllegalArgumentException("No transformer found for type: " + object.getClass().getName() + " ('" + object + "')");<br />}</pre><br /><br />where <span style="font-family:courier new;">MessageTransformer</span> is an abstraction for converting one specific type into <span style="font-family:courier new;">JMSMessage</span> (by the way do you know why I used <a href="http://java.sun.com/javase/6/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a>?) Here is the example:<br /><br /><pre class="brush: java">interface MessageTransformer {<br />    Message transform(Object object, Session session) throws JMSException;<br />}<br /><br />public class StringMessageTransformer implements MessageTransformer {<br /><br />      public Message transform(Object object, Session session) throws JMSException {<br />          return session.createTextMessage((String) object);<br />      }<br /><br />}</pre><br /><br />We successfully replaced 8-level-if with a map, that can be easily injected by any IoC container. Also new implementation of <span style="font-family:courier new;">MessageTransformer </span>might be written and added to transformation algorithm without modifying (adding another if-else construct) the original class. Code is cleaner, more flexible and generic. No code duplication, easier to maintain, <span style="font-style: italic;">blah, blah, blah</span> – really?<br /><br />Look at the original code snippet and the one after my refactorings. Which version is easier to read, in which version would you find the bug earlier? If you were to made some minor change, which code base is more programmer-friendly? One huge if or one interface with eight trivial implementations?<br /><br /><span style="font-weight: bold;">The biggest value of the source code is readability</span>. Not 100% test coverage, because bad code is still hard to maintain when you simply can’t understand the implementation. I would really prefer having easy to understand code with no unit tests (because I can write them as soon as I understand the code) rather than the <span style="font-style: italic;">Rain Forest Class</span>. The <span style="font-style: italic;">Rain Forest Class</span> works perfectly and has a full suite of unit tests; as long as you don’t touch it, it looks beautiful. But as soon as you change the smallest piece of code, the forest collapses, lots of unit tests fail. Great, but you still don’t know how to fix this, because you don’t understand the code. The frustration increases.<br /><br />Writing great code, with absolutely no code duplication, using design patterns and following good practices and principles is a sign of a good programmer. But not the best one. The best programmer knows he is better than most of the people who will read his code in the future and use the language suitable for his "readers". It is like with a database normalization: sometimes <a href="http://www.codinghorror.com/blog/2008/07/maybe-normalizing-isnt-normal.html">denormalized database</a> if faster and the corresponding schema is (you’ve guessed!) easier to understand.<br /><br />I am trying to apply design patterns to become a good programmer. But to become a great one, sometimes I must forget about them and write the simplest code possible. Sacrificing code readability is almost never justified. Strive for simplicity, reduce code duplication and apply patterns only when it is necessary and actually increases readability and maintainability. Don’t think in terms of flexibility and reusability all the time, don’t make unnecessary levels of abstraction. Refactoring of a simple code is much cheaper than using already existing <span style="font-style: italic;">Rain Forest Class</span>:<br /><br /><div style="text-align: right;">"<span style="font-style: italic;">he’s written a bunch of templates, and all you have to do is multiply-inherit from 17 of his templates, each taking an average of 4 arguments, and you barely even have to write the body of the function</span>"<br /><a href="http://www.joelonsoftware.com/items/2009/09/23.html">Joel Spolsky</a><br /></div>