---
layout: post
title: Filtering irrelevant stack trace lines in logs
date: '2012-03-17T23:24:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- stack traces
- logging
- intellij idea
- logback
modified_time: '2012-10-06T12:24:47.993+02:00'
thumbnail: http://1.bp.blogspot.com/-HV3LrnVB4Pk/T2UJ9esYKuI/AAAAAAAAAj4/mKxt_HUMfbI/s72-c/stack.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5484584847872903160
blogger_orig_url: https://www.nurkiewicz.com/2012/03/filtering-irrelevant-stack-trace-lines.html
---

I love stack traces. Not because I love errors, but the moment they occur, stack trace is priceless source of information. For instance in web application the stack trace shows you the complete request processing path, from HTTP socket, through filters, servlets, controllers, services, DAOs, etc. - up to the place, where an error occurred. You can read them as a good book, where every event has cause and effect. I even implemented some enhancements in the way <a href="http://logback.qos.ch/">Logback</a> prints exceptions, see <a href="http://nurkiewicz.com/2011/09/logging-exceptions-root-cause-first.html">Logging exceptions root cause first</a>.<br /><br />But one thing's been bothering me for a while. The infamous “<i>stack trace from hell</i>" symptom – stack traces containing hundreds of irrelevant, cryptic, often auto-generated methods. AOP frameworks and over-engineered libraries tend to produce insanely long execution traces. Let me show a real-life example. In a sample application I am using the following technology stack:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-HV3LrnVB4Pk/T2UJ9esYKuI/AAAAAAAAAj4/mKxt_HUMfbI/s1600/stack.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="259" src="http://1.bp.blogspot.com/-HV3LrnVB4Pk/T2UJ9esYKuI/AAAAAAAAAj4/mKxt_HUMfbI/s400/stack.png" width="200" /></a></div>Colours are important. According to framework/layer colour I painted a sample stack trace, caused by exception thrown somewhere deep while trying to fetch data from the database:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-W7TdPtKPNJA/T2UKKf1GtCI/AAAAAAAAAkE/cL97cDo1c4g/s1600/long-stack.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://3.bp.blogspot.com/-W7TdPtKPNJA/T2UKKf1GtCI/AAAAAAAAAkE/cL97cDo1c4g/s400/long-stack.png" width="256" /></a></div>No longer that pleasant, don't you think? Placing Spring between application and Hibernate in the first diagram was a huge oversimplification. Spring framework is a glue code that wires up and intercepts your business logic with surrounding layers. That is why application code is scattered and interleaved by dozens of lines of technical invocations (see green lines). I put as much stuff as I could into the application (Spring AOP, method-level @Secured annotations, custom aspects and interceptors, etc.) to emphasize the problem – but it is not Spring specific. EJB servers generate equally terrible stack traces (...from hell) between EJB calls. Should I care? Think about it, when you innocently call <code>BookService.listBooks()</code> from <code>BookController.listBooks()</code> do you expect to see this?<br /><a name='more'></a><br /><pre class="brush: plain; highlight: [1, 7, 24]">at com.blogspot.nurkiewicz.BookService.listBooks()<br />at com.blogspot.nurkiewicz.BookService$$FastClassByCGLIB$$e7645040.invoke()<br />at net.sf.cglib.proxy.MethodProxy.invoke()<br />at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint()<br />at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()<br />at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed()<br />at com.blogspot.nurkiewicz.LoggingAspect.logging()<br />at sun.reflect.NativeMethodAccessorImpl.invoke0()<br />at sun.reflect.NativeMethodAccessorImpl.invoke()<br />at sun.reflect.DelegatingMethodAccessorImpl.invoke()<br />at java.lang.reflect.Method.invoke()<br />at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs()<br />at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod()<br />at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke()<br />at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()<br />at org.springframework.aop.interceptor.AbstractTraceInterceptor.invoke()<br />at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()<br />at org.springframework.transaction.interceptor.TransactionInterceptor.invoke()<br />at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()<br />at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke()<br />at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()<br />at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept()<br />at com.blogspot.nurkiewicz.BookService$$EnhancerByCGLIB$$7cb147e4.listBooks()<br />at com.blogspot.nurkiewicz.web.BookController.listBooks()<br /></pre>And have you even noticed there is custom aspect in between? That's the thing, there is so much noise in the stack traces nowadays that following the actual business logic is virtually impossible. One of the best troubleshooting tools we have is bloated with irrelevant framework-related stuff we don't need in 99% of the cases.<br /><br />Tools and IDEs are doing a good job of reducing the noise. <a href="http://www.eclipse.org/">Eclipse</a> has <a href="http://help.eclipse.org/helios/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fref-preferences-junit.htm">stack trace filter patterns for Junit</a>, <a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> supports <a href="http://blogs.jetbrains.com/idea/2010/07/console-folding-customization/">console folding customization</a>. See also: <a href="http://stackoverflow.com/questions/9606614">Cleaning noise out of Java stack traces</a>, which inspired me to write this article. So why not having such possibility at the very root – in the logging framework such as Logback?<br /><br />I implemented a very simple enhancement in Logback. Basically you can define a set of stack trace frame patterns that are suppose to be excluded from stack traces. Typically you will use package or class names that you are not interested in seeing. This is a sample <code>logback.xml</code> excerpt with the new feature enabled:<br /><pre class="brush: plain">&lt;root level="ALL"&gt;<br />  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;<br />    &lt;encoder&gt;<br />      &lt;pattern&gt;%d{HH:mm:ss.SSS} | %-5level | %thread | %logger{1} | %m%n%rEx{full,<br />          java.lang.reflect.Method,<br />          org.apache.catalina,<br />          org.springframework.aop,<br />          org.springframework.security,<br />          org.springframework.transaction,<br />          org.springframework.web,<br />          sun.reflect,<br />          net.sf.cglib,<br />          ByCGLIB<br />        }<br />        &lt;/pattern&gt;<br />    &lt;/encoder&gt;<br />  &lt;/appender&gt;<br />&lt;/root&gt;<br /></pre>I am a bit extreme in filtering almost whole Spring framework + Java reflection and CGLIB classes. But it is just to give you an impression how much can you get. The very same error after applying my enhancement to Logback:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-9nBb0CvqBIg/T2UKV06nD5I/AAAAAAAAAkQ/Pl2Hfj5HUlY/s1600/short-stack.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="269" src="http://2.bp.blogspot.com/-9nBb0CvqBIg/T2UKV06nD5I/AAAAAAAAAkQ/Pl2Hfj5HUlY/s400/short-stack.png" width="400" /></a></div>Just as a reminder, green is our application. Finally in one place, finally you can really see what was your code doing when an error occurred:<br /><pre>at com.blogspot.nurkiewicz.DefaultBookHelper.findBooks()<br />at com.blogspot.nurkiewicz.BookService.listBooks()<br />at com.blogspot.nurkiewicz.LoggingAspect.logging()<br />at com.blogspot.nurkiewicz.web.BookController.listBooks()<br /></pre>Simpler? If you like this feature, I opened a ticket <a href="http://jira.qos.ch/browse/LBCLASSIC-325">LBCLASSIC-325</a>: <em>Filtering out selected stack trace frames</em>. Vote and discuss. This is only a proof-of-concept, but if you like to have a look at the implementation (improvements are welcome!), it is available under <a href="https://github.com/nurkiewicz/logback/tree/LBCLASSIC-325">my fork</a> of Logback (around 20 lines of code).