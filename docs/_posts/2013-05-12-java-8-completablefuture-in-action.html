---
layout: post
title: 'Java 8: CompletableFuture in action'
date: '2013-05-12T23:13:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- multithreading
- java 8
modified_time: '2015-11-29T23:37:57.543+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4806795675644686611
blogger_orig_url: https://www.nurkiewicz.com/2013/05/java-8-completablefuture-in-action.html
---

After thoroughly exploring <a href="http://nurkiewicz.com/2013/05/java-8-definitive-guide-to.html"><code>CompletableFuture</code> API in Java 8</a> we are prepared to write a simplistic web crawler. We solved similar problem already using <a href="http://nurkiewicz.blogspot.no/2013/02/executorcompletionservice-in-practice.html"><code>ExecutorCompletionService</code></a>, <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html">Guava <code>ListenableFuture</code></a> and <a href="http://nurkiewicz.blogspot.no/2013/03/futures-in-akka-with-scala.html">Scala/Akka</a>. I choose the same problem so that it's easy to compare approaches and implementation techniques.<br /><br />First we shall define a simple, blocking method to download the contents of a single URL:<br /><br /><pre class="brush: java">private String downloadSite(final String site) {<br />    try {<br />        log.debug("Downloading {}", site);<br />        final String res = IOUtils.toString(new URL("http://" + site), UTF_8);<br />        log.debug("Done {}", site);<br />        return res;<br />    } catch (IOException e) {<br />        throw Throwables.propagate(e);<br />    }<br />}<br /></pre>Nothing fancy. This method will be later invoked for different sites inside thread pool. Another method parses the <code>String</code> into an XML <code>Document</code> (let me leave out the implementation, no one wants to look at it):<br /><br /><pre class="brush: java">private Document parse(String xml)  //...<br /></pre>Finally the core of our algorithm, function computing <i>relevance</i> of each website taking <code>Document</code> as input. Just as above we don't care about the implementation, only the signature is important:<br /><br /><pre class="brush: java">private CompletableFuture&lt;Double&gt; calculateRelevance(Document doc) //...<br /></pre>Let's put all the pieces together. Having a list of websites our crawler shall start downloading the contents of each web site asynchronously and concurrently. Then each downloaded HTML string will be parsed to XML <code>Document</code> and later <i>relevance</i> will be computed. As a last step we take all computed <i>relevance</i> metrics and find the biggest one. This sounds pretty straightforward to the moment when you realize that both downloading content and computing <i>relevance</i> is asynchronous (returns <code>CompletableFuture</code>) and we definitely don't want to block or busy wait. Here is the first piece:<br /><a name='more'></a><br /><br /><pre class="brush: java">ExecutorService executor = Executors.newFixedThreadPool(4);<br /><br />List&lt;String&gt; topSites = Arrays.asList(<br />        "www.google.com", "www.youtube.com", "www.yahoo.com", "www.msn.com"<br />);<br /><br />List&lt;CompletableFuture&lt;Double&gt;&gt; relevanceFutures = topSites.stream().<br />        map(site -&gt; CompletableFuture.supplyAsync(() -&gt; downloadSite(site), executor)).<br />        map(contentFuture -&gt; contentFuture.thenApply(this::parse)).<br />        map(docFuture -&gt; docFuture.thenCompose(this::calculateRelevance)).<br />        collect(Collectors.&lt;CompletableFuture&lt;Double&gt;&gt;toList());<br /></pre>There is actually <b>a lot</b> going on here. Defining thread pool and sites to crawl is obvious. But there is this chained expression computing <code>relevanceFutures</code>. The sequence of <code>map()</code> and <code>collect()</code> in the end is quite descriptive. Starting from a list of web sites we transform each site (<code>String</code>) into <code>CompletableFuture&lt;String&gt;</code> by submitting asynchronous task (<code>downloadSite()</code>) into thread pool.<br /><br />So we have a list of <code>CompletableFuture&lt;String&gt;</code>. We continue transforming it, this time applying <code>parse()</code> method on each of them. Remember that <code>thenApply()</code> will invoke supplied lambda when underlying future completes and returns <code>CompletableFuture&lt;Document&gt;</code> immediately. Third and last transformation step composes each <code>CompletableFuture&lt;Document&gt;</code> in the input list with <code>calculateRelevance()</code>. Note that <code>calculateRelevance()</code> returns <code>CompletableFuture&lt;Double&gt;</code> instead of <code>Double</code>, thus we use <code>thenCompose()</code> rather than <code>thenApply()</code>. After that many stages we finally <code>collect()</code> a list of <code>CompletableFuture&lt;Double&gt;</code>.<br /><br />Now we would like to run some computations on <i>all</i> results. We have a list of futures and we would like to know when all of them (last one) complete. Of course we can register completion callback on each future and use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html"><code>CountDownLatch</code></a> to block until all callbacks are invoked. I am too lazy for that, let us utilize existing <a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)"><code>CompletableFuture.allOf()</code></a>. Unfortunately it has two minor drawbacks - takes vararg instead of <code>Collection</code> and doesn't return a future of aggregated results but <code>Void</code> instead. By aggregated results I mean: if we provide <code>List&lt;CompletableFuture&lt;Double&gt;&gt;</code> such method should return <code>CompletableFuture&lt;List&lt;Double&gt;&gt;</code>, not <code>CompletableFuture&lt;Void&gt;</code>! Luckily it's easy to fix with a bit of glue code:<br /><br /><pre class="brush: java">private static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futures) {<br />    CompletableFuture&lt;Void&gt; allDoneFuture =<br />        CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));<br />    return allDoneFuture.thenApply(v -&gt;<br />            futures.stream().<br />                    map(future -&gt; future.join()).<br />                    collect(Collectors.&lt;T&gt;toList())<br />    );<br />}<br /></pre>Watch carefully <code>sequence()</code> argument and return types. The implementation is surprisingly simple, the trick is to use existing <code>allOf()</code> but when <code>allDoneFuture</code> completes (which means all underlying futures are done), simply iterate over all futures and <code>join()</code> (blocking wait) on each. However this call is guaranteed not to block because by now all futures completed! Equipped with such utility method we can finally complete our task:<br /><br /><pre class="brush: java">CompletableFuture&lt;List&lt;Double&gt;&gt; allDone = sequence(relevanceFutures);<br />CompletableFuture&lt;OptionalDouble&gt; maxRelevance = allDone.thenApply(relevances -&gt;<br />        relevances.stream().<br />                mapToDouble(Double::valueOf).<br />                max()<br />);<br /></pre>This one is easy - when <code>allDone</code> completes, apply our function that counts maximal relevance in whole set. <code>maxRelevance</code> is still a future. By the time your JVM reaches this line, probably none of the websites are yet downloaded. But we encapsulated business logic on top of futures, stacking them in an event-driven manner. Code remains readable (version without lambda and with ordinary <code>Future</code>s would be at least twice as long) but avoids blocking main thread. Of course <code>allDone</code> can as well be an intermediate step, we can further transform it, not really having the result yet.<br /><br /><h2>Shortcomings</h2><code>CompletableFuture</code> in Java 8 is a huge step forward. From tiny, thin abstraction over asynchronous task to full-blown, functional, feature rich utility. However after few days of playing with it I found few minor disadvantages:<br /><br /><ul><li><a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)"><code>CompletableFuture.allOf()</code></a> returning <code>CompletableFuture&lt;Void&gt;</code> discussed earlier. I think it's fair to say that if I pass a collection of futures and want to wait for all of them, I would also like to extract the results when they arrive easily. It's even worse with <a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#anyOf(java.util.concurrent.CompletableFuture...)"><code>CompletableFuture.anyOf()</code></a>. If I am waiting for <i>any</i> of the futures to complete, I can't imagine passing futures of different types, say <code>CompletableFuture&lt;Car&gt;</code> and <code>CompletableFuture&lt;Restaurant&gt;</code>. If I don't care which one completes first, how am I suppose to handle return type? Typically you will pass a collection of homogeneous futures (e.g. <code>CompletableFuture&lt;Car&gt;</code>) and then <code>anyOf()</code> can simply return future of that type (instead of <code>CompletableFuture&lt;Void&gt;</code> again).<br /><br /></li><li>Mixing <i>settable</i> and <i>listenable</i> abstractions. In Guava there is <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListenableFuture.html"><code>ListenableFuture</code></a> and <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/SettableFuture.html"><code>SettableFuture</code></a> extending it. <code>ListenableFuture</code> allows registering callbacks while <code>SettableFuture</code> adds possibility to set value of the future (resolve it) from arbitrary thread and context. <code>CompletableFuture</code> is equivalent to <code>SettableFuture</code> but there is no limited version equivalent to <code>ListenableFuture</code>. Why is it a problem? If API returns <code>CompletableFuture</code> and then two threads wait for it to complete (nothing wrong with that), one of these threads can resolve this future and wake up other thread, while it's only the API implementation that should do it. But when API tries to resolve the future later, call to <code>complete()</code> is ignored. It can lead to really nasty bugs which are avoided in Guava by separating these two responsibilities.<br /><br /></li><li><code>CompletableFuture</code> is ignored in JDK. <code>ExecutorService</code> was not retrofitted to return <code>CompletableFuture</code>. Literally <code>CompletableFuture</code> is not referenced anywhere in JDK. It's a really useful class, backward compatible with <code>Future</code>, but not really promoted in standard library.<br /><br /></li><li>Bloated API (?) Fifty methods in total, most in three variants. Splitting <i>settable</i> and <i>listenable</i> (see above) would help. Also some methods like <code>runAfterBoth()</code> or <code>runAfterEither()</code> IMHO do not really belong to any <code>CompletableFuture</code>. Is there a difference between <code>fast.runAfterBoth(predictable, ...)</code> and <code>predictable.runAfterBoth(fast, ...)</code>? No, but API favours one or the other. Actually I believe <code>runAfterBoth(fast, predictable, ...)</code> much better expresses my intention.<br /><br /></li><li><a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html#getNow(T)"><code>CompletableFuture.getNow(T)</code></a> should take <code>Supplier&lt;T&gt;</code> instead of raw reference. In the example below <code>expensiveAlternative()</code> is always code, irrespective to whether future finished or not:<br /><br /><pre class="brush: java">future.getNow(expensiveAlternative());<br /></pre>However we can easily tweak this behaviour (I know, there is a small race condition here, but the original <code>getNow()</code> works this way as well):<br /><br /><pre class="brush: java">public static &lt;T&gt; T getNow(<br />            CompletableFuture&lt;T&gt; future, <br />            Supplier&lt;T&gt; valueIfAbsent) throws ExecutionException, InterruptedException {<br />    if (future.isDone()) {<br />        return future.get();<br />    } else {<br />        return valueIfAbsent.get();<br />    }<br />}<br /></pre>With this utility method we can avoid calling <code>expensiveAlternative()</code> when it's not needed:<br /><br /><pre class="brush: java">getNow(future, () -&gt; expensiveAlternative());<br />//or:<br />getNow(future, this::expensiveAlternative);<br /></pre></li></ul>In overall <code>CompletableFuture</code> is a wonderful new tool in our JDK belt. Minor API issues and sometimes too verbose syntax due to limited type inference shouldn't stop you from using it. At least it's a solid foundation for better abstractions and more robust code.<br /><br /><script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>