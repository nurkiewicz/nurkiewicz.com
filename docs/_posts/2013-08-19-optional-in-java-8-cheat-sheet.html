---
layout: post
title: Optional in Java 8 cheat sheet
date: '2013-08-19T16:46:00.003+02:00'
author: Tomasz Nurkiewicz
tags:
- guava
- scala
- java 8
modified_time: '2020-05-14T23:01:07.680+02:00'
thumbnail: http://3.bp.blogspot.com/-pTMCmPJJ7Io/UhIvgg6AxHI/AAAAAAAAA0I/5stUZa95hGU/s72-c/243254_160570284008783_2391880_o.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-8605171111297473894
blogger_orig_url: https://www.nurkiewicz.com/2013/08/optional-in-java-8-cheat-sheet.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-pTMCmPJJ7Io/UhIvgg6AxHI/AAAAAAAAA0I/5stUZa95hGU/s1600/243254_160570284008783_2391880_o.jpg" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://3.bp.blogspot.com/-pTMCmPJJ7Io/UhIvgg6AxHI/AAAAAAAAA0I/5stUZa95hGU/s200/243254_160570284008783_2391880_o.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Maridalsvannet</td></tr></tbody></table><a href="http://download.java.net/jdk8/docs/api/java/util/Optional.html"><code>java.util.Optional&lt;T&gt;</code></a> in Java 8 is a poor cousin of <a href="http://www.scala-lang.org/api/current/index.html#scala.Option"><code>scala.Option[T]</code></a> and <a href="http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Data-Maybe.html"><code>Data.Maybe</code> in Haskell</a>. But this doesn’t mean it’s not useful. If this concept is new to you, imagine <code>Optional</code> as a container that may or may not contain some value. Just like all references in Java can point to some object or be <code>null</code>, <code>Option</code> may enclose some (non-null!) reference or be empty.<br /><br />Turns out that the analogy between <code>Optional</code> and nullable references is quite sensible. <code>Optional</code> was introduced in Java 8 so obviously it is not used throughout the standard Java library - and never will be for the backward compatibility reasons. But I recommend you at least giving it a try and using it whenever you have nullable references. <code>Optional</code> instead of plain <code>null</code> is statically checked at compile time and much more informative as it clearly indicates that a given variable may be present or not. Of course it requires some discipline - you should never assign <code>null</code> to any variable any more.<br /><br />Usage of <i>option</i> (<i>maybe</i>) pattern is quite controversial and I am not going to step into this discussion. Instead I present you with few use-cases of <code>null</code> and how they can be retrofitted to <code>Optional&lt;T&gt;</code>. In the following examples given variables and types are used:<br /><br /><pre class="brush: java">public void print(String s) {<br />    System.out.println(s);<br />}<br /><br />String x = //...<br />Optional&lt;String&gt; opt = //...<br /></pre><code>x</code> is a String that <i>may</i> be <code>null</code>, <code>opt</code> is never <code>null</code>, but may or may not contain some value (<i>present</i> or <i>empty</i>). There are few ways of creating <code>Optional</code>:<br /><a name='more'></a><br /><br /><pre class="brush: java">opt = Optional.of(notNull);<br /><br />opt = Optional.ofNullable(mayBeNull);<br /><br />opt = Optional.empty();<br /></pre>In the first case <code>Optional</code> <i>must</i> contain not <code>null</code> value and will throw an exception if <code>null</code> is passed. <code>ofNullable()</code> will either return empty or present (set) <code>Optional</code>. <code>empty()</code> always return empty <code>Optional</code>, corresponding to <code>null</code>. It’s a singleton because <code>Optional&lt;T&gt;</code> is immutable.<br /><br /><h2><code>ifPresent()</code> - do something when <code>Optional</code> is set</h2>Tedious <code>if</code> statement:<br /><br /><pre class="brush: java">if (x != null) {<br />    print(x);<br />}<br /></pre>can be replaced with higher-order function <code>ifPresent()</code>:<br /><br /><pre class="brush: java">opt.ifPresent(x -&gt; print(x));<br />opt.ifPresent(this::print);<br /></pre>The latter syntax (method reference) can be used when lambda argument (<code>String x</code>) matches function formal parameters.<br /><br /><h2><code>filter()</code> - reject (filter out) certain <code>Optional</code> values.</h2>Sometimes you want to perform some action not only when a reference is set but also when it meets certain condition:<br /><br /><pre class="brush: java">if (x != null &amp;&amp; x.contains("ab")) {<br />    print(x);<br />}<br /></pre>This can be replaced with <code>Optional.filter()</code> that turns present (set) <code>Optional</code> to empty <code>Optional</code> if underlying value does not meet given predicate. If input <code>Optional</code> was empty, it is returned as-is:<br /><br /><pre class="brush: java">opt.<br />   filter(x -&gt; x.contains("ab")).<br />   ifPresent(this::print);<br /></pre>This is equivalent to more imperative:<br /><br /><pre class="brush: java">if(opt.isPresent() &amp;&amp; opt.get().contains("ab")) {<br />    print(opt.get());<br />}<br /></pre><h2><code>map()</code> - transform value if present</h2>Very often you need to apply some transformation on a value, but only if it’s not <code>null</code> (avoiding <code>NullPointerException</code>):<br /><br /><pre class="brush: java">if (x != null) {<br />    String t = x.trim();<br />    if (t.length() &gt; 1) {<br />        print(t);<br />    }<br />}<br /></pre>This can be done in much more declarative way using <code>map()</code>:<br /><br /><pre class="brush: java">opt.<br />    map(String::trim).<br />    filter(t -&gt; t.length() &gt; 1).<br />    ifPresent(this::print);<br /></pre>This becomes tricky. <code>Optional.map()</code> applies given function on a value inside <code>Optional</code> - but only if <code>Optional</code> is present. Otherwise nothing happens and <code>empty()</code> is returned. Remember that the transformation is type-safe - look at generics here:<br /><br /><pre class="brush: java">Optional&lt;String&gt;  opt = //...<br />Optional&lt;Integer&gt; len = opt.map(String::length);<br /></pre>If <code>Optional&lt;String&gt;</code> is present <code>Optional&lt;Integer&gt; len</code> is present as well, wrapping length of a <code>String</code>. But if <code>opt</code> was empty, <code>map()</code> over it does nothing except changing generic type.<br /><br /><h2><code>orElse()</code>/<code>orElseGet()</code> - turning empty <code>Optional&lt;T&gt;</code> to default <code>T</code></h2>At some point you may wish to unwrap <code>Optional</code> and get a hold of real value inside. But you can’t do this if <code>Optional</code> is empty. Here is a pre-Java 8 way of handling such scenario:<br /><br /><pre class="brush: java">int len = (x != null)? x.length() : -1;<br /></pre>With <code>Optional</code> we can say:<br /><br /><pre class="brush: java">int len = opt.map(String::length).orElse(-1);<br /></pre>There is also a version that accepts <a href="http://download.java.net/jdk8/docs/api/java/util/function/Supplier.html"><code>Supplier&lt;T&gt;</code></a> if computing default value is slow, expensive or has side-effects:<br /><br /><pre class="brush: java">int len = opt.<br />    map(String::length).<br />    orElseGet(() -&gt; slowDefault());     //orElseGet(this::slowDefault)<br /></pre><h2><code>flatMap()</code> - we need to go deeper</h2>Imagine you have a function that does not accept <code>null</code> but may produce one:<br /><br /><pre class="brush: java">public String findSimilar(@NotNull String s) //...<br /></pre>Using it is a bit cumbersome:<br /><br /><pre class="brush: java">String similarOrNull = x != null? findSimilar(x) : null;<br /></pre>With <code>Optional</code> it is a bit more straighforward:<br /><br /><pre class="brush: java">Optional&lt;String&gt; similar = opt.map(this::findSimilar);<br /></pre>If the function we <code>map()</code> over returns <code>null</code>, the result of <code>map()</code> is an empty <code>Optional</code>. Otherwise it’s the result of said function wrapped with (present) <code>Optional</code>. So far so good but why do we return <code>null</code>-able value if we have <code>Optional</code>?<br /><br /><pre class="brush: java">public Optional&lt;String&gt; tryFindSimilar(String s)  //...<br /></pre>Our intentions are clear but using <code>map()</code> fails to produce correct type. Instead we must use <code>flatMap()</code>:<br /><br /><pre class="brush: java">Optional&lt;Optional&lt;String&gt;&gt; bad = opt.map(this::tryFindSimilar);<br />Optional&lt;String&gt; similar =       opt.flatMap(this::tryFindSimilar);<br /></pre>Do you see double <code>Optional&lt;Optional&lt;...&gt;&gt;</code>? Definitely not what we want. If you are mapping over a function that returns <code>Optional</code>, use <code>flatMap</code> instead. Here is a simplified implementation of this function:<br /><br /><pre class="brush: java">public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;T, Optional&lt;U&gt;&gt; mapper) {<br />    if (!isPresent())<br />        return empty();<br />    else {<br />        return mapper.apply(value);<br />    }<br />}<br /></pre><h2><code>orElseThrow()</code> - lazily throw exceptions on empty <code>Optional</code></h2>Often we would like to throw an exception if value is not available:<br /><br /><pre class="brush: java">public char firstChar(String s) {<br />    if (s != null &amp;&amp; !s.isEmpty())<br />        return s.charAt(0);<br />    else<br />        throw new IllegalArgumentException();<br />}<br /></pre>This whole method can be replaced with the following idiom:<br /><br /><pre class="brush: java">opt.<br />    filter(s -&gt; !s.isEmpty()).<br />    map(s -&gt; s.charAt(0)).<br />    orElseThrow(IllegalArgumentException::new);<br /></pre>We don’t want to create an instance of exception in advance because <a href="https://nurkiewicz.com/2012/10/where-do-stack-traces-come-from.html">creating an exception has significant cost</a>.<br /><br /><h2>Bigger example</h2>Imagine we have a <code>Person</code> with an <code>Address</code> that has a <code>validFrom</code> date. All of these can be <code>null</code>. We would like to know whether <code>validFrom</code> is set and in the past:<br /><br /><pre class="brush: java">private boolean validAddress(NullPerson person) {<br />    if (person != null) {<br />        if (person.getAddress() != null) {<br />            final Instant validFrom = person.getAddress().getValidFrom();<br />            return validFrom != null &amp;&amp; validFrom.isBefore(now());<br />        } else<br />            return false;<br />    } else<br />        return false;<br />}<br /></pre>Quite ugly and defensive. Alternatively but still ugly:<br /><br /><pre class="brush: java">return person != null &amp;&amp;<br />       person.getAddress() != null &amp;&amp;<br />       person.getAddress().getValidFrom() != null &amp;&amp;<br />       person.getAddress().getValidFrom().isBefore(now());<br /></pre>Now imagine all of these (<code>person</code>, <code>getAddress()</code>, <code>getValidFrom()</code>) are <code>Optional</code>s of appropriate types, clearly indicating they may not be set:<br /><br /><pre class="brush: java">class Person {<br /><br />    private final Optional&lt;Address&gt; address;<br /><br />    public Optional&lt;Address&gt; getAddress() {<br />        return address;<br />    }<br /><br />    //...<br />}<br /><br />class Address {<br />    private final Optional&lt;Instant&gt; validFrom;<br /><br />    public Optional&lt;Instant&gt; getValidFrom() {<br />        return validFrom;<br />    }<br /><br />    //...<br />}<br /></pre>Suddenly the computation is much more streamlined:<br /><br /><pre class="brush: java">return person.<br />        flatMap(Person::getAddress).<br />        flatMap(Address::getValidFrom).<br />        filter(x -&gt; x.before(now())).<br />        isPresent();<br /></pre>Is it more readable? Hard to tell. But at least it’s impossible to produce <code>NullPointerException</code> when <code>Optional</code> is used consistently.<br /><br /><h2>Converting <code>Optional&lt;T&gt;</code> to <code>List&lt;T&gt;</code></h2>I sometimes like to think about <code>Optional</code> as a collection<sup>1</sup> having either 0 or 1 elements. This may make understanding of <code>map()</code> and <code>flatMap()</code> easier. Unfortunately <code>Optional</code> doesn’t have <code>toList()</code> method, but it’s easy to implement one:<br /><br /><pre class="brush: java">public static &lt;T&gt; List&lt;T&gt; toList(Optional&lt;T&gt; option) {<br />    return option.<br />            map(Collections::singletonList).<br />            orElse(Collections.emptyList());<br />}<br /></pre>Or less idiomatically:<br /><br /><pre class="brush: java">public static &lt;T&gt; List&lt;T&gt; toList(Optional&lt;T&gt; option) {<br />    if (option.isPresent())<br />        return Collections.singletonList(option.get());<br />    else<br />        return Collections.emptyList();<br />}<br /></pre>But why limit ourselves to <code>List&lt;T&gt;</code>? What about <code>Set&lt;T&gt;</code> and other collections? Java 8 already abstracts creating arbitrary collection via <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html"><code>Collectors</code> API</a>, introduced for <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html"><code>Stream</code>s</a>. The API is hideous but comprehensible:<br /><br /><pre class="brush: java">public static &lt;R, A, T&gt; R collect(Optional&lt;T&gt; option, Collector&lt;? super T, A, R&gt; collector) {<br />    final A container = collector.supplier().get();<br />    option.ifPresent(v -&gt; collector.accumulator().accept(container, v));<br />    return collector.finisher().apply(container);<br />}<br /></pre>We can now say:<br /><br /><pre class="brush: java">import static java.util.stream.Collectors.*;<br /><br />List&lt;String&gt; list = collect(opt, toList());<br />Set&lt;String&gt;  set  = collect(opt, toSet());<br /></pre><h2>Summary</h2><code>Optional&lt;T&gt;</code> is not nearly as powerful as <code>Option[T]</code> in Scala (but at least it <a href="http://www.cakesolutions.net/teamblogs/2013/04/20/this-week-in-scala-19042013/">doesn’t allow wrapping <code>null</code></a>). The API is not as straightforward as <code>null</code>-handling and probably much slower. But the benefit of compile-time checking plus readability and documentation value of <code>Optional</code> used consistently greatly outperforms disadvantages. Also it will probably replace nearly identical <a href="https://guava.dev/releases/23.0/api/docs/com/google/common/base/Optional.html"><code>com.google.common.base.Optional&lt;T&gt;</code> from Guava</a><br /><br />PS: Thank you&nbsp;Java Developer Central for fixing broken links. Also check out&nbsp;<a href="https://javadevcentral.com/optional-new-methods">Optional – New methods in Java 9 through 11</a>&nbsp;from that site.<br /><br /><sup>1 - from theoretical point of view both <i>maybe</i> and <i>sequence</i> abstractions are <i>monads</i>, that’s why they share some functionality</sup><br /><br /><script>SyntaxHighlighter.highlight();</script>