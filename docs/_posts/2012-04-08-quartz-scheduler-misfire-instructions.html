---
layout: post
title: Quartz scheduler misfire instructions explained
date: '2012-04-08T18:22:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- quartz
modified_time: '2012-04-08T21:03:44.125+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7693779563697766034
blogger_orig_url: https://www.nurkiewicz.com/2012/04/quartz-scheduler-misfire-instructions.html
---

Sometimes Quartz is not capable of running your job at the time when you desired. There are three reasons for that:<br /><ul> <li>all worker threads were busy running other jobs (probably with higher priority)</li> <li>the scheduler itself was down</li> <li>the job was scheduled with start time in the past (probably a coding error)</li></ul>You can increase the number of worker threads by simply customizing the <code>org.quartz.threadPool.threadCount</code> in <code>quartz.properties</code> (default is 10). But you cannot really do anything when the whole application/server/scheduler was down. The situation when Quartz was incapable of firing given trigger is called <i>misfire</i>. Do you know what Quartz is doing when it happens? Turns out there are various strategies (called <i>misfire instructions</i>) Quartz can take and also there are some defaults if you haven't thought about it. But in order to make your application robust and predictable (especially under heavy load or maintenance) you should really make sure your triggers and jobs are configured conciously.<br /><br />There are different configuration options (available <i>misfire instructions</i>) depending on the trigger chosen. Also Quartz behaves differently depending on trigger setup (so called <i>smart policy</i>). Although the misfire instructions are described in the documentation, I found it hard to understand what do they really mean. So I created this small summary article.<br /><br />Before I dive into the details, there is yet another configuration option that should be described. It is <code>org.quartz.jobStore.misfireThreshold</code> (in milliseconds), defaulting to 60000 (a minute). It defines how late the trigger should be to be considered <i>misfired</i>. With default setup if trigger was suppose to be fired 30 seconds ago, Quartz will happily just run it. Such delay is not considered misfiring. However if the trigger is discovered 61 seconds after the scheduled time - the special misfire handler thread takes care of it, obeying the misfire instruction. For test purposes we will set this parameter to 1000 (1 second) so that we can test misfiring quickly.<br /><h4>  Simple trigger without repeating</h4>In our first example we will see how misfiring is handled by simple triggers scheduled to run only once: <br /><pre class="brush: scala">val trigger = newTrigger().<br />        startAt(DateUtils.addSeconds(new Date(), -10)).<br />        build()<br /></pre>The same trigger but with explicitly set misfire instruction handler:<br /><pre class="brush: scala">val trigger = newTrigger().<br />        startAt(DateUtils.addSeconds(new Date(), -10)).<br />        withSchedule(<br />            simpleSchedule().<br />                withMisfireHandlingInstructionFireNow()  //MISFIRE_INSTRUCTION_FIRE_NOW<br />            ).<br />        build()<br /></pre>For the purpose of testing I am simply scheduling the trigger to run 10 seconds ago (so it is 10 seconds late by the time it is created!) In real world you would normally never schedule triggers like that. Instead imagine the trigger was set correctly but by the time it was scheduled the scheduler was down or didn't have any free worker threads. Nevertheless, how will Quartz handle this extraordinary situation? In the first code snippet above no misfire handling instruction is set (so called <i>smart policy</i> is used in that case). The second code snippet explicitly defines what kind of behaviour do we expect when misfiring occurs. See the table:<br /><a name='more'></a><br /><table border="1"> <tbody> <tr>  <th>Instruction</th><th>Meaning</th> </tr> <tr>  <th><i>smart policy</i> - default</th>  <td>See: <code>withMisfireHandlingInstructionFireNow</code></td></tr> <tr> </tr> <tr>  <th>withMisfireHandlingInstructionFireNow<br />   <code>MISFIRE_INSTRUCTION_FIRE_NOW</code></th>  <td>The job is executed immediately after the scheduler discovers misfire situation. This is the <i>smart policy</i>.<br />   <b>Example scenario:</b> you have scheduled some system clean up at 2 AM. Unfortunately the application was down due to maintenance by that time and brought back on 3 AM. So the trigger misfired and the scheduler tries to save the situation by running it as soon as it can - at 3 AM.</td></tr> <tr>  <th>withMisfireHandlingInstructionIgnoreMisfires<br />   <code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY</code> <a href="https://jira.terracotta.org/jira/browse/QTZ-283"><sup>QTZ-283</sup></a></th>  <td>See: <code>withMisfireHandlingInstructionFireNow</code></td></tr> <tr>  <th>withMisfireHandlingInstructionNextWithExistingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT</code></th>  <td>See: <code>withMisfireHandlingInstructionNextWithRemainingCount</code></td></tr> <tr>  <th>withMisfireHandlingInstructionNextWithRemainingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT</code></th>  <td>Does nothing, misfired execution is ignored and there is no next execution. Use this instruction when you want to completely discard the misfired execution.<br />   <b>Example scenario:</b> the trigger was suppose to start recording of a program in TV. There is no point of  starting recording when the trigger misfired and is already 2 hours late.</td></tr> <tr>  <th>withMisfireHandlingInstructionNowWithExistingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT</code></th>  <td>See: <code>withMisfireHandlingInstructionFireNow</code></td></tr> <tr>  <th>withMisfireHandlingInstructionNowWithRemainingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT</code></th>  <td>See: <code>withMisfireHandlingInstructionFireNow</code></td> </tr> </tbody></table><h4>  Simple trigger repeating fixed number of times</h4>This scenario is much more complicated. Imagine we have scheduled some job to repeat fixed number of times:<br /><pre class="brush: scala">val trigger = newTrigger().<br />    startAt(dateOf(9, 0, 0)).<br />    withSchedule(<br />        simpleSchedule().<br />            withRepeatCount(7).<br />            withIntervalInHours(1).<br />            WithMisfireHandlingInstructionFireNow()  //or other<br />    ).<br />    build()<br /></pre>In this example the trigger is suppose to fire 8 times (first execution + 7 repetitions) every hour, beginning at 9 AM today (<code>startAt(dateOf(9, 0, 0))</code>. Thus the last execution should occur at 4 PM. However assume that due to some reason the scheduler was not capable of running jobs at 9 and 10 AM and it discovered that fact at 10:15 AM, i.e. 2 firings misfired. How will the scheduler behave in this situation?<br /><table border="1"> <tbody> <tr>  <th>Instruction</th><th>Meaning</th> </tr> <tr>  <th><i>smart policy</i> - default</th>  <td>See: <code>withMisfireHandlingInstructionNowWithExistingCount</code></td></tr> <tr> </tr> <tr>  <th>withMisfireHandlingInstructionFireNow<br />   <code>MISFIRE_INSTRUCTION_FIRE_NOW</code></th>  <td>See: <code>withMisfireHandlingInstructionNowWithRemainingCount</code></td></tr> <tr>  <th>withMisfireHandlingInstructionIgnoreMisfires<br />   <code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY</code><a href="https://jira.terracotta.org/jira/browse/QTZ-283"><sup>QTZ-283</sup></a></th>  <td>Fires all triggers that were missed as soon as possible and then goes back to ordinary schedule.<br />   <b>Example scenario:</b> With this strategy in our example the scheduler will fire jobs scheduled at 9 and 10 AM immediately. Then it will wait to 11 AM and go back to ordinary schedule.<br />   <b>Note: </b> When handling misfires it is equally important to realize that the actual job execution time might be way after the scheduled time. This means you cannot simply rely on current system date, but you need to use <code>JobExecutionContext .getScheduledFireTime()</code>:<br /><pre class="brush: scala">def execute(context: JobExecutionContext) {<br />    val date = context.getScheduledFireTime<br />    //...<br />}<br /></pre>  </td></tr> <tr>  <th>withMisfireHandlingInstructionNextWithExistingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT</code></th>  <td>The scheduler won't do anything immediately. Instead it will wait for next scheduled time and run all triggers with scheduled intervals. See also: <code>withMisfireHandlingInstructionNextWithRemainingCount</code><br />   <b>Example scenario:</b> at 10:15 the scheduler discovers 2 misfired executions. It waits until next scheduled time (11 AM) and fires all 8 scheduled executions every hour, stopping at 6 PM (the trigger should have stopped at 4 PM). </td></tr> <tr>  <th>withMisfireHandlingInstructionNextWithRemainingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT</code></th>  <td>The scheduler discards misfired executions and waits for the next scheduled time. The total number of trigger executions will be less then configured.<br />   <b>Example scenario:</b> at 10:15 two misfired executions are discarded. The scheduler waits for next scheduled time (11 AM) and fires remaining triggers up to 4 PM. Effectively it behaves as if misfire never occurred.</td></tr> <tr>  <th>withMisfireHandlingInstructionNowWithExistingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT</code></th>  <td>First misfired trigger is executed immediately. Then the scheduler waits desired interval and executes all remaining triggers. Effectively the first fire time of the misfired trigger is moved to current time with no other changes.<br />   <b>Example scenario:</b> at 10:15 the scheduler runs the first misfired execution. Then it waits 1 hour and fires the second one at 11:15 AM. All 8 executions are performed, the last one at 5:15 PM</td></tr> <tr>  <th>withMisfireHandlingInstructionNowWithRemainingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT</code></th>  <td>First misfired execution runs immediately. Remaining misfired executions are discarded. Triggers that were not misfired are executed with desired interval.<br />   <b>Example scenario:</b> at 10:15 the scheduler runs the first misfired execution (from 9 AM). It discards remaining misfired executions (the one from 10 AM) and waits 1 hour to execute six more triggers: 11:15, 12:15, … 4:15 PM</td> </tr> </tbody></table><h4>  Simple trigger repeating infinitely</h4>In this scenario trigger repeats infinite number of times at a given interval:<br /><pre class="brush: scala">val trigger = newTrigger().<br />    startAt(dateOf(9, 0, 0)).<br />    withSchedule(<br />        simpleSchedule().<br />            withRepeatCount(SimpleTrigger.REPEAT_INDEFINITELY).<br />            withIntervalInHours(1).<br />            WithMisfireHandlingInstructionFireNow()  //or other<br />    ).<br />    build()<br /></pre>Once again trigger should fire on every hour, beginning at 9 AM today (<code>startAt(dateOf(9, 0, 0))</code>. However the scheduler was not capable of running jobs at 9 and 10 AM and it discovered that fact at 10:15 AM, i.e. 2 firings misfired. This is a more general situation compared to simple trigger running fixed number of times.<br /><table border="1"> <tbody> <tr>  <th>Instruction</th><th>Meaning</th> </tr> <tr>  <th><i>smart policy</i> - default</th>  <td>See: <code>withMisfireHandlingInstructionNextWithRemainingCount</code></td></tr> <tr> </tr> <tr>  <th>withMisfireHandlingInstructionFireNow<br />   <code>MISFIRE_INSTRUCTION_FIRE_NOW</code></th>  <td>See: <code>withMisfireHandlingInstructionNowWithRemainingCount</code></td></tr> <tr>  <th>withMisfireHandlingInstructionIgnoreMisfires<br />   <code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY</code><a href="https://jira.terracotta.org/jira/browse/QTZ-283"><sup>QTZ-283</sup></a></th>  <td>The scheduler will immediately run all misfired triggers, then continue on schedule.<br />   <b>Example scenario:</b> the triggers scheduled at 9 and 10 AM are executed immediately. Future invocations (next scheduled at 11 AM) are executed according to the plan.</td></tr> <tr>  <th>withMisfireHandlingInstructionNextWithExistingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT</code></th>  <td>See: <code>withMisfireHandlingInstructionNextWithRemainingCount</code></td></tr> <tr>  <th>withMisfireHandlingInstructionNextWithRemainingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT</code></th>  <td>Does nothing, misfired executions are discarded. Then the scheduler waits for next scheduled interval and goes back to schedule.<br />   <b>Example scenario:</b> Misfired execution at 9 and 10 AM are discarded. The first execution occurs at 11 AM.</td></tr> <tr>  <th>withMisfireHandlingInstructionNowWithExistingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT</code></th>  <td>See: <code>withMisfireHandlingInstructionNowWithRemainingCount</code></td></tr> <tr>  <th>withMisfireHandlingInstructionNowWithRemainingCount<br />   <code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT</code></th>  <td>The first misfired execution is run immediately, remaining are discarded. Next execution happens after desired interval. Effectively the first execution time is moved to current time.<br />   <b>Example scenario:</b> the scheduler fires misfired trigger immediately at 10:15 AM. Then waits an hour and runs the second one at 11:15 AM and continues with 1 hour interval.</td></tr> </tbody></table><h4>  CRON triggers</h4>CRON triggers are the most popular ones amongst Quartz users. However there are also two other available triggers: <a href="http://quartz-scheduler.org/api/2.1.0/org/quartz/DailyTimeIntervalTrigger.html"><code>DailyTimeIntervalTrigger</code></a> (e.g. <i>fire every 25 minutes</i>) and <a href="http://quartz-scheduler.org/api/2.1.0/org/quartz/CalendarIntervalTrigger.html"><code>CalendarIntervalTrigger</code></a> (e.g. <i>fire every 5 months</i>). They support triggering policies not possible in both CRON and simple triggers. However they understand the same misfire handling instructions as CRON trigger.<br /><pre class="brush: scala">val trigger = newTrigger().<br /> withSchedule(<br />  cronSchedule("0 0 9-17 ? * MON-FRI").<br />   withMisfireHandlingInstructionFireAndProceed()  //or other<br /> ).<br /> build()<br /></pre>In this example the trigger should fire every hour between 9 AM and 5 PM, from Monday to Friday. But once again first two invocations were missed (so the trigger misfired) and this situation was discovered at 10:15 AM. Note that available misfire instructions are different compared to simple triggers:<br /><table border="1"> <tbody> <tr>  <th>Instruction</th><th>Meaning</th> </tr> <tr>  <th><i>smart policy</i> - default</th>  <td>See: <code>withMisfireHandlingInstructionFireAndProceed</code></td></tr> <tr> </tr> <tr>  <th>withMisfireHandlingInstructionIgnoreMisfires<br />   <code>MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY</code><a href="https://jira.terracotta.org/jira/browse/QTZ-283"><sup>QTZ-283</sup></a></th>  <td>All misfired executions are immediately executed, then the trigger runs back on schedule.<br />   <b>Example scenario:</b> the executions scheduled at 9 and 10 AM are executed immediately. The next scheduled execution (at 11 AM) runs on time.</td></tr> <tr>  <th>withMisfireHandlingInstructionFireAndProceed<br />   <code>MISFIRE_INSTRUCTION_FIRE_ONCE_NOW</code></th>  <td>Immediately executes first misfired execution and discards other (i.e. all misfired executions are merged together). Then  back to schedule. No matter how many trigger executions were missed, only single immediate execution is performed.<br />   <b>Example scenario:</b> the executions scheduled at 9 and 10 AM are merged and executed only once (in other words: the execution scheduled at 10 AM is discarded). The next scheduled execution (at 11 AM) runs on time.</td></tr> <tr>  <th>withMisfireHandlingInstructionDoNothing<br />   <code>MISFIRE_INSTRUCTION_DO_NOTHING</code></th>  <td>All misfired executions are discarded, the scheduler simply waits for next scheduled time.<br />   <b>Example scenario:</b> the executions scheduled at 9 and 10 AM are discarded, so basically nothing happens. The next scheduled execution (at 11 AM) runs on time.</td></tr> </tbody></table><a href="https://jira.terracotta.org/jira/browse/QTZ-283"><sup>QTZ-283</sup></a><b>Note</b>: <a href="https://jira.terracotta.org/jira/browse/QTZ-283"><i>QTZ-283: MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY not working with JDBCJobStore</i></a> - apparently there is a bug when <a href="http://nurkiewicz.com/2012/04/quartz-scheduler-plugins-hidden.html"><code>JDBCJobStore</code></a> is used, keep an eye on that issue.<br /><br />As you can see various triggers behave differently based on the actual setup. Moreover, even though the so called <i>smart policy</i> is provided, often the decision is based on business requirements. Essentially there are three major strategies: <i>ignore</i>, <i>run immediately and continue</i> and <i>discard and wait for next</i>. They all have different use-cases:<br /><br />Use <i>ignore</i> policies when you want to make sure all scheduled executions were triggered, even if it means multiple misfired triggers will fire. Think about a job that generates report every hour based on orders placed during that last hour. If the server was down for 8 hours, you still want to have that reports generated, as soon as you can. In this case the <i>ignore</i> policies will simply run all triggers scheduled during that 8 hour as fast as scheduler can. They will be several hours late, but will eventually be executed.<br /><br />Use <i>now*</i> policies when there are jobs executing periodically and upon misfire situation they should run as soon as possible, but only once. Think of a job that cleans <code>/tmp</code> directory every minute. If the scheduler was busy for 20 minutes and finally can run this job, you don't want to run in 20 times! One is enough, but make sure it runs as fast it can. Then back to your normal one-minute intervals.<br /><br />Finally <i>next*</i> policies are good when you want to make sure your job runs at particular points in time. For example you need to fetch stock prices quarter past every hour. They change rapidly so if your job misfired and it is already 20 minutes past full hour, don't bother. You missed the correct time by 5 minutes and now you don't really care. It is better to have a gap rather than an inaccurate value. In this case Quartz will skip all misfired executions and simply wait for the next one.