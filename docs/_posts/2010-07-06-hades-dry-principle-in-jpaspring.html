---
layout: post
title: 'Hades: DRY principle in JPA/Spring development'
date: '2010-07-06T23:11:00.006+02:00'
author: Tomasz Nurkiewicz
tags:
- jpa
- spring
- hades
modified_time: '2010-07-06T23:42:10.834+02:00'
thumbnail: http://4.bp.blogspot.com/_P3ewsGQzHn0/TDOc1Bj2PWI/AAAAAAAAAWE/t7wRzGF28LI/s72-c/Hades.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4222227573134757128
blogger_orig_url: https://www.nurkiewicz.com/2010/07/hades-dry-principle-in-jpaspring.html
---

It's almost two weeks after great <a href="http://javarsovia.pl">Javarsovia 2010</a> conference, but before I write few words about this event, let me mention about really clever library called <a href="http://redmine.synyx.org/projects/hades">Hades</a>. I owe you this after my attendance in <a href="http://nurkiewicz.blogspot.com/2010/05/impressions-after-geecon-2010.html">GeeCON 2010</a>, where I discovered this tool during its author talk.<br /><br />DRY stands for <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don't Repeat Yourself</a> and if you were developing in JPA for a while you have violated this principal several times. Take for example this piece of code:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_P3ewsGQzHn0/TDOc1Bj2PWI/AAAAAAAAAWE/t7wRzGF28LI/s1600/Hades.png"><img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 400px; height: 64px;" src="http://4.bp.blogspot.com/_P3ewsGQzHn0/TDOc1Bj2PWI/AAAAAAAAAWE/t7wRzGF28LI/s400/Hades.png" alt="" id="BLOGGER_PHOTO_ID_5490904805460557154" border="0" /></a><br /><br /><br />Although IntelliJ IDEA has a wonderful <a href="http://www.jetbrains.com/idea/features/jpa_hibernate.html">support for JPA</a> (have you noticed this little popup suggesting me the proper named query parameter  name <span style="font-style: italic;">since</span>?), I still have to write the same boilerplate code over and over. Basically for each entity object I need a DAO class and 90% of them look the same except they have different entity type. Same CRUD, same paging and sorting logic, same unit tests, similar queries. We are getting bored after writing fifth or tenth DAO like this, especially if we are lazy (which is good!) So Hades provides nice abstraction, at least all your DAOs would follow same naming convention:<br /><br /><pre class="brush: java">public interface GenericDao&lt;T, PK extends Serializable&gt; {<br />    T save(final T entity);<br />    List&lt;T&gt; save(final List&lt;T&gt; entities);<br />    T saveAndFlush(final T entity);<br />    T readByPrimaryKey(final PK primaryKey);<br />    boolean exists(final PK primaryKey);<br />    List&lt;T&gt; readAll();<br />    List&lt;T&gt; readAll(final Sort sort);<br />    Page&lt;T&gt; readAll(final Pageable pageable);<br />    Long count();<br />    void delete(final T entity);<br />    void delete(final List&lt;T&gt; entities);<br />    void deleteAll();<br />    void flush();<br />}</pre><br /><br />Nice, but you probably came out with similar generic interface long time ago. But Hades goes one step further and it automatically implements this interface for you… For any entity bean you provide!<br /><br /><pre class="brush: java">public interface MoneyTransferDao extends GenericDao&lt;MoneyTransfer, Long&gt; {}</pre><br /><br />But let's start from the beginning. First get necessary dependencies:<br /><br /><pre class="brush: xml">&lt;!-- Spring --&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;<br />    &lt;version&gt;3.0.3.RELEASE&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br />    &lt;version&gt;3.0.3.RELEASE&lt;/version&gt;<br />    &lt;scope&gt;test&lt;/scope&gt;<br />&lt;/dependency&gt;<br /><br />&lt;!-- Persistence --&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br />    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br />    &lt;version&gt;1.1.119&lt;/version&gt;<br />    &lt;scope&gt;runtime&lt;/scope&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;<br />    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;<br />    &lt;version&gt;1.4&lt;/version&gt;<br />    &lt;scope&gt;runtime&lt;/scope&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.hibernate.java-persistence&lt;/groupId&gt;<br />    &lt;artifactId&gt;jpa-api&lt;/artifactId&gt;<br />    &lt;version&gt;2.0-cr-1&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br />    &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br />    &lt;version&gt;3.5.1-Final&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.synyx.hades&lt;/groupId&gt;<br />    &lt;artifactId&gt;org.synyx.hades&lt;/artifactId&gt;<br />    &lt;version&gt;2.0.0.RC2&lt;/version&gt;<br />    &lt;exclusions&gt;<br />        &lt;exclusion&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;org.springframework.orm&lt;/artifactId&gt;<br />        &lt;/exclusion&gt;<br />    &lt;/exclusions&gt;<br />&lt;/dependency&gt;<br /><br />&lt;!-- ... --&gt;<br /><br />&lt;repository&gt;<br />    &lt;id&gt;repo.synyx.de&lt;/id&gt;<br />    &lt;name&gt;Synyx Maven2 Repository&lt;/name&gt;<br />    &lt;url&gt;http://repo.synyx.org&lt;/url&gt;<br />&lt;/repository&gt;</pre><br /><br />All other dependencies necessary to run Spring-managed integration test with JPA 2.0 backed by Hibernate 3.5 will be downloaded transitively. You also need logging dependencies, take a look <a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-use-appropriate.html">here</a>.<br /><br />As an example we are going to use these two entities:<br /><br /><pre class="brush: java">public class MoneyTransfer implements Serializable {<br />    private long id;<br />    private Account from;<br />    private Account to;<br />    private BigDecimal amount;<br />    private Calendar date;<br /><br />    //get/set<br /><br />}</pre><br /><br /><pre class="brush: java">public class Account implements Serializable {<br />    private int id;<br />    private String ownerName;<br /><br />    //get/set<br /><br />}</pre><br /><br />Personally, I find JPA annotations great for rapid prototyping, but awful in production code, especially when fine-tuning your mapping (database sequence names in Java annotations attributes?!?) So here is my orm.xml excerpt:<br /><br /><pre class="brush: xml">&lt;entity class="com.blogspot.nurkiewicz.hades.MoneyTransfer"&gt;<br />    &lt;attributes&gt;<br />        &lt;id name="id"&gt;<br />            &lt;generated-value/&gt;<br />        &lt;/id&gt;<br />        &lt;basic name="date" optional="false"&gt;<br />            &lt;temporal&gt;DATE&lt;/temporal&gt;<br />        &lt;/basic&gt;<br />        &lt;basic name="amount" optional="false"&gt;<br />            &lt;column precision="20" scale="2"/&gt;<br />        &lt;/basic&gt;<br />        &lt;many-to-one name="from" optional="false"&gt;<br />            &lt;cascade&gt;<br />                &lt;cascade-all/&gt;<br />            &lt;/cascade&gt;<br />        &lt;/many-to-one&gt;<br />        &lt;many-to-one name="to" optional="false"&gt;<br />            &lt;cascade&gt;<br />                &lt;cascade-all/&gt;<br />            &lt;/cascade&gt;<br />        &lt;/many-to-one&gt;<br />    &lt;/attributes&gt;<br />&lt;/entity&gt;<br /><br />&lt;entity class="com.blogspot.nurkiewicz.hades.Account"&gt;<br />    &lt;attributes&gt;<br />        &lt;id name="id"&gt;<br />            &lt;generated-value/&gt;<br />        &lt;/id&gt;<br />        &lt;basic name="ownerName" optional="false"&gt;<br />            &lt;column length="120"/&gt;<br />        &lt;/basic&gt;<br />    &lt;/attributes&gt;<br />&lt;/entity&gt;</pre><br /><br />We all love XML, admit it! And finally unit test itself:<br /><br /><pre class="brush: java; highlight: [10]">@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration<br />@Transactional<br />public class MoneyTransferDaoTest {<br /><br />    @PersistenceContext<br />    private EntityManager em;<br /><br />    @Resource<br />    private MoneyTransferDao dao;<br /><br />    @Resource<br />    private AccountDao accountDao;<br /><br />    @Test<br />    public void shouldReturnNothingWhenReadingNotExistingMoneyTransfer() throws Exception {<br />        //when<br />        final MoneyTransfer moneyTransfer = dao.readByPrimaryKey(17L);<br /><br />        //then<br />        assertThat(moneyTransfer).isNull();<br />    }<br /><br />    @Test<br />    public void shouldReturnExistingMoneyTransfer() throws Exception {<br />        //given<br />        final MoneyTransfer newTransfer = new MoneyTransfer();<br />        em.persist(newTransfer);<br /><br />        //when<br />        final MoneyTransfer moneyTransfer = dao.readByPrimaryKey(newTransfer.getId());<br /><br />        //then<br />        assertThat(moneyTransfer).isNotNull();<br />        assertThat(moneyTransfer.getId()).isEqualTo(newTransfer.getId());<br />    }<br /><br />//...<br /><br />}</pre><br /><br />Following Spring unit test naming convention, this test case will start Spring context located in <span style="font-style: italic;">MoneyTransferDaoTest-context.xml</span>:<br /><br /><pre class="brush: xml; highlight: [39]">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xmlns:tx="http://www.springframework.org/schema/tx" xmlns:hades="http://schemas.synyx.org/hades"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<br />            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<br />            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd http://schemas.synyx.org/hades http://schemas.synyx.org/hades/hades.xsd"&gt;<br /><br />    &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;<br />    &lt;context:annotation-config/&gt;<br /><br />    &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;<br />    &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;<br /><br />    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver"/&gt;<br />        &lt;property name="url" value="jdbc:h2:mem:moneytransfers;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;<br />        &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;<br />        &lt;property name="dataSource" ref="dataSource"/&gt;<br />        &lt;property name="jpaVendorAdapter" ref="jpaAdapter"/&gt;<br />        &lt;property name="jpaProperties"&gt;<br />            &lt;props&gt;<br />                &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt;<br />                &lt;prop key="hibernate.ejb.naming_strategy"&gt;org.hibernate.cfg.DefaultComponentSafeNamingStrategy&lt;/prop&gt;<br />                &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;<br />            &lt;/props&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jpaAdapter" class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"/&gt;<br /><br />    &lt;hades:dao-config base-package="com.blogspot.nurkiewicz.hades"/&gt;<br /><br />&lt;/beans&gt;</pre><br /><br />Now run the test, it should pass. That's right, we haven't written even single line of DAO code and still our <span style="font-style: italic;">MoneyTransferDao</span>, injected in line 10, works perfectly! The whole magic is hidden under line 39 of Spring context file. hades:dao-config element discovers all interfaces extending <span style="font-style: italic;">org.synyx.hades.dao.GenericDao&lt;T, PK extends Serializable&gt;</span> and dynamically implements them based on their generic types. We automatically get methods like:<br /><br /><pre class="brush: java">public interface MoneyTransferDao extends GenericDao&lt;MoneyTransfer, Long&gt; {<br />    MoneyTransfer readByPrimaryKey(final Long primaryKey);<br />    Page&lt;MoneyTransfer&gt; readAll(final Pageable pageable);<br /> //...<br />}<br /></pre><br /><br />Yep, Hades also provides built in support for paging and sorting – especially annoying when has to be implemented and tested manually for several entities.<br /><br />OK, to be honest, there was no magic in what we have seen until now and you might have even written similar utilities for your internal usage. Although <span style="font-style: italic;">GenericDao</span> has some built in methods that cover, let's say, 50% of typical queries, what about the rest? What if I would like to find all money transfers with amount greater than given value?<br /><br /><pre class="brush: java">public interface MoneyTransferDao extends GenericDao&lt;MoneyTransfer, Long&gt; {<br />    List&lt;MoneyTransfer&gt; findByAmountGreaterThan(BigDecimal amount);<br />}</pre><br /><br />Where to put the implementation of this custom DAO method? Well, now the magic part begins – nowhere! Similar to GORM, Hades will parse this method name and create the query for you. All you have to do is to follow some naming convention. No custom queries, no boilerplate code. Hades will even set the parameter for you. It's such a clever tool, that simply by adding argument of type Pageable Hades will include paging clauses (like TOP, LIMIT, OFFSET, etc.):<br /><br /><pre class="brush: java">public interface MoneyTransferDao extends GenericDao&lt;MoneyTransfer, Long&gt; {<br />    List&lt;MoneyTransfer&gt; findByDateGreaterThan(Calendar date, Pageable page);<br /> //...<br />}<br /></pre><br /><br /><pre class="brush: java">moneyTransferDao.findByDateGreaterThan(<br />        Calendar.getInstance(),<br />        new PageRequest(1, 20, new Sort(Order.ASCENDING, "amount")));</pre><br /><br />So, Hades can transparently implement basic CRUD operations with sorting/paging support. It can also synthesize queries based only on interface method name and arguments. But once you discover that this feature is very limited (for instance it does not support <span style="font-style: italic;">Not</span>, <span style="font-style: italic;">Like</span>, <span style="font-style: italic;">IsNull</span>, <span style="font-style: italic;">In</span> and other modifiers known from <a href="http://www.grails.org/GORM">GORM</a>, see issue <a href="http://redmine.synyx.org/issues/274">#274</a>), you'll eventually end up with a need for a custom JPA query like this:<br /><br /><pre class="brush: xml">&lt;named-query name="MoneyTransfer.getAverageTransferAmountSince"&gt;<br />    &lt;query&gt;<br />        SELECT AVG(transfer.amount)<br />        FROM MoneyTransfer transfer<br />        WHERE transfer.date &gt; ?1<br />    &lt;/query&gt;<br />&lt;/named-query&gt;</pre><br /><br />Now we add method in our DAO interface that will execute this query:<br /><br /><pre class="brush: java">public interface MoneyTransferDao extends GenericDao&lt;MoneyTransfer, Long&gt; {<br />    BigDecimal getAverageTransferAmountSince(Calendar since);<br /> //...<br />}</pre><br /><br />The implementation is trivial (see screenshot at the beginning of this article), so Hades implements this method for us as well. Name of the method matches name of the named query (prefixed by the  entity name), which is enough for Hades. Few lines of code (repeated hundreds of times) are saved.<br /><br />But what if you really want to implement custom DAO method, but still having all other methods implemented for you? There are two reasons: do some validation and parameters transformation before the query is executed and post-process results after query execution.  The latter reason can be often eliminated using not very well known JPA query language feature. Take for instance this query:<br /><br /><pre class="brush: plain">SELECT transfer.amount, transfer.from.id, transfer.to.id<br />FROM MoneyTransfer transfer</pre><br /><br />It will return <span style="font-style: italic;">List&lt;Object[]&gt;</span>, which isn't very object-orientish. Instead, our DAO layer should do some transformation and return more user friendly object. JPA can do this for you with this simple expression:<br /><br /><pre class="brush: plain">SELECT NEW RawMoneyTransfer(transfer.amount, transfer.from.id, transfer.to.id)<br />FROM MoneyTransfer transfer</pre><br /><br /><span style="font-style: italic;">RawMoneyTransfer</span> is any Java object (not necessarily JPA entity) with constructor matching given parameters being only requirement. But once again, what if you really need custom DAO method? For example JPA does not define any date expressions, so there is no straightforward way to define "<span style="font-style: italic;">30 days before today</span>" when generating report for last month in JPA QL. Unfortunately, Hades way of defining custom DAO methods is troublesome and a bit counterintuitive. I will open an issue and try to introduce simpler (although harder in implementation) solution. Meanwhile take a look at great Hades reference <a href="http://redmine.synyx.org/projects/hades/wiki">documentation</a> for further details.<br /><br />Hades also has support for entity auditing, but <a href="http://www.jboss.org/envers">Envers</a>, being part of Hibernate portfolio, is probably more mature solution. As of version 2.0 it also has built in support to participate in Spring transactions. As you have seen, Hades aims to increase your productivity by writing less code, less unit tests (comprehensive unit testing of Hades-generated methods isn't necessary) and promoting convention over configuration approach. It still has some limitations but give it a try, I recently will.