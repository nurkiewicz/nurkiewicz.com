---
layout: post
title: Injecting methods at runtime to Java class in Groovy
date: '2009-09-03T22:16:00.004+02:00'
author: Tomasz Nurkiewicz
tags:
- groovy
- grails
- gorm
modified_time: '2009-09-04T08:20:57.848+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2901628059548618993
blogger_orig_url: https://www.nurkiewicz.com/2009/09/injecting-methods-at-runtime-to-java.html
---

I recently finished reading "<a href="http://www.amazon.com/Programming-Groovy-Productivity-Developer-Programmers/dp/1934356093"><span style="font-style: italic;">Programming Groovy: Dynamic Productivity for the Java Developer</span></a>" and this book really opened my eyes on what Groovy language really is. Most tutorials or lectures I have attended are focused on syntactical sugar: closures, operator overloading, easier access to bean properties or maps. Elvis operator, spread operator, spaceship operator...<br /><br />But the strength of Groovy is not syntactic sugar on a Java cake. Groovy is a brand new dish with really exotic taste, which not everybody would enjoy. The gap between Java and Groovy is really huge, although they integrate tightly and seamlessly. But remember, Firefox did not became so popular because it was so similar to IE, but because it was different <a href="http://linux.oneandoneis2.org/LNW.htm"><span style="font-style: italic;">[1]</span></a>. Maybe Groovy is not better than Java, but is certainly worth trying. Thanks to "<span style="font-style: italic;">Programming Groovy...</span>" I realized what amazing things can be done using Groovy which you would never even thought about in Java.<br /><br />As Chinese said, Java code is worth more than a thousand words (or something like that<a href="http://en.wikipedia.org/wiki/A_picture_is_worth_a_thousand_words">...</a>), I’ll give you some short example announced in post title. Suppose you have some POJO:<br /><br /><pre name="code" class="java">public class Person {<br />  private String name;<br />  private Calendar dateOfBirth;<br />  private BigDecimal salary;<br /><br />  public String getName() {<br />   return name;<br />  }<br /><br />  public void setName(String name) {<br />   this.name = name;<br />  }<br /><br />  public Calendar getDateOfBirth() {<br />   return dateOfBirth;<br />  }<br /><br />  public void setDateOfBirth(Calendar dateOfBirth) {<br />   this.dateOfBirth = dateOfBirth;<br />  }<br /><br />  public BigDecimal getSalary() {<br />   return salary;<br />  }<br /><br />  public void setSalary(BigDecimal salary) {<br />   this.salary = salary;<br />  }<br />}</pre><br /><br />Yes, this is Java class, remember that. Our task is to create simple validator, which will check whether all properties are not-null of a particular Java Bean instance (e.g <span style="font-family:courier new;">Person</span>). If any null field found, exception should be thrown.<br /><br />Doing this in the classic way, you would write some sort of utility class with method like:<br /><br /><pre name="code" class="java">public static void validate(Object pojo) throws IllegalStateException {/*...*/}</pre><br /><br />This approach is so obvious, that I won’t even explain this API. Behind the scenes some nasty reflection with tons of exception handling and method name parsing code will be used to make the method generic. If you are clever, you would use <a href="http://commons.apache.org/beanutils/api/org/apache/commons/beanutils/PropertyUtils.html">Commons-BeanUtils</a>. But this is still poor object-oriented design, as data (properties of a JavaBean) and operations (<span style="font-family:courier new;">validate()</span> method operating on data) are separated. Wouldn’t it be great to have <span style="font-family:courier new;">validate()</span> method in <span style="font-family:courier new;">Person </span>and every other bean you wish?  To achieve this, you would probably think about inheritance and placing <span style="font-family:courier new;">validate()</span> in some abstract base class of all your Java Beans.<br /><br />No, stop that! This is still bad design, although much more subtle. Inheritance represents is-a relationship. If you want to use the same operation in many objects, you should rather use delegation. See "Replace Inheritance with Delegation" chapter in Fowler’s "<a href="http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672">Refactoring: improving the design of existing code</a>" (I know, I know, some parts of the book are not so <a href="http://nurkiewicz.blogspot.com/2009/08/java-concurrency-in-practice-written-by.html">outdated </a>:-)). But if you are not so sensitive about code design (why?!?), there is another problem – this approach cannot be applied to third-party classes, which you are not allowed to change.<br /><br />This is the place where Groovy comes in with its amazing dynamic capabilities. First I will prepare some Groovy test case, which will explain what I am trying to achieve. Test-driven development, anybody?<br /><br /><pre name="code" class="java">public class PersonTest extends GroovyTestCase {<br /><br />void testAllPropertiesNullShouldThrow() {<br /> def person = new Person();<br /> shouldFail(IllegalStateException) {person.validate()}<br />}<br /><br />void testSingleNullPropertyShouldThrow() {<br /> def person = new Person(name: "John Smith", salary: 1234d)<br /> shouldFail(IllegalStateException) {person.validate()}<br />}<br /><br />void testAllPropertiesSetShouldNotThrow() {<br /> def person = new Person(name: "John Smith", dateOfBirth: Calendar.instance, salary: 1234d)<br /> person.validate()<br />}<br /><br />}</pre><br /><br />Read those tests carefully. Not because I use elegant <span style="font-family:courier new;">shouldFail()</span> template nor very concise way of initializing POJO (even though it does not have any non-default constructor!) The most surprising fact is that I run <span style="font-family:courier new;">validate()</span> method on <span style="font-family:courier new;">Person </span>class instance and the code compiles just fine! It doesn’t matter this method does not exist on compile time, even if it is Java object. Groovy’s dynamic. But what happen if I run this test?<br /><br /><pre name="code" class="java">groovy.lang.MissingMethodException: No signature of method: Person.validate() is applicable for argument types: () values: []<br />at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)<br />at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:46)<br />at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)<br />at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)<br />at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:121)<br />at PersonTest.testAllPropertiesSetShouldNotThrow(PersonTest.groovy:30)<br />at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br />at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br />at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:40)<br />at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br />at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br />at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br />at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)</pre><br /><br />Surely, <span style="font-family:courier new;">Person </span>Java class does not have <span style="font-family:courier new;">validate()</span> method, even if Groovy compiler assumed differently. So you might ask yourself, what is the purpose of such a weak compilation? Well, now comes the best part:<br /><br /><pre name="code" class="java">void setUp() {<br /> Person.metaClass.validate = {-><br />     delegate.properties.each {property, value -><br />         if (value == null)<br />             throw new java.lang.IllegalStateException("Property $property is null")<br />     }<br /> }<br />}</pre><br /><br />What I’ve done here is I injected method called <span style="font-family:courier new;">validate()</span> to meta class of <span style="font-family:courier new;">Person </span>Java class at runtime. Since now, every instance of Person class is capable of handling <span style="font-family:courier new;">validate()</span> method even though this method has not been known during compilation. Quick test case execution and... success, not only the method is known, but it works as expected.<br /><br />I won’t discuss details of <span style="font-family:courier new;">validate()</span> implementation, simply try to rewrite it in Java, you’ll see the difference. But it is not the point! I created brand new method and applied it to arbitrary Java class (of course, if <span style="font-family:courier new;">Person </span>was Groovy class, it would work as well). This is absolutely impossible in static Java. And if I add that by implementing <span style="font-family:courier new;">methodMissing()</span> object could handle ANY nonexistent method call...<br /><br />You might ask yourself once again, what is the purpose of such a dangerous and unpredictable toy? Well, I am about to obtain "<a style="font-style: italic;" href="http://www.amazon.com/Definitive-Grails-Second-Experts-Development/dp/1590599950">The Definitive Guide to Grails</a>"*, which also explains GORM framework. If you would like to make <span style="font-family:courier new;">Person </span>class persistent, Groovy ORM will automatically inject <span style="font-family:courier new;">save()</span> method to Person class, so you could write:<br /><br /><pre name="code" class="java">new Person(name: "John Smith").save()</pre><br /><br />No DAO, no session, na <span style="font-family:courier new;">EntityManager</span>. But you could also write:<br /><br /><pre name="code" class="java">def list = Person.findByNameLikeAndSalaryGreaterThan("John%", 1000)</pre><br /><br />Where is the implementation of this <span style="font-style: italic;">not-so-simple</span> method? You don’t have to implement it, Groovy will! It will discover that such a method does not exist in <span style="font-family:courier new;">Person</span> class, parse the name and create proper SQL with <span style="font-family:courier new;">AND </span>and <span style="font-family:courier new;">LIKE </span>operators on <span style="font-family:courier new;">Person </span>table, issue SQL and map to a list of <span style="font-family:courier new;">Person </span>instances. If this is not magic, go back to your Hibernate, as I find such features absolutely exciting and innovative.<br /><br />I am just playing with Groovy, but I found this language to have many unexpectedly interesting parts. It is not a replacement of Java, but a great tool to combine and interact with its older brother.<br /><br /><span style="font-size:11px;">* many thanks to my <a href="http://www.javart.com.pl">employer</a> for sponsoring aforementioned books</span><br /><p> </p>