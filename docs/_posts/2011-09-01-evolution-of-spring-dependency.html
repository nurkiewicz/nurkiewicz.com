---
layout: post
title: The evolution of Spring dependency injection techniques
date: '2011-09-01T22:01:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- scala
- spring
modified_time: '2011-11-17T19:27:22.781+01:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2618588514620661673
blogger_orig_url: https://www.nurkiewicz.com/2011/09/evolution-of-spring-dependency.html
---

<div>Looking back at the history of Spring framework you will find out that the number of ways you can implement dependency injection is growing in every release. If you've been working with this framework for more than a month you'll probably find nothing interesting in this retrospective article. Nothing hopefully except the last example in Scala, language that accidentally works great with Spring.</div><div><br /></div><h4>   First there was XML [<a href="https://github.com/nurkiewicz/spring-di/tree/xml">full source</a>]:</h4><div><br /></div><div><pre class="brush: xml"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd "&gt;<br /><br />    &lt;bean id="foo" class="com.blogspot.nurkiewicz.Foo"&gt;<br />        &lt;property name="bar" ref="bar"/&gt;<br />        &lt;property name="jdbcOperations" ref="jdbcTemplate"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="bar" class="com.blogspot.nurkiewicz.Bar" init-method="init"/&gt;<br /><br />    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver"/&gt;<br />        &lt;property name="url" value="jdbc:h2:mem:"/&gt;<br />        &lt;property name="username" value="sa"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;<br />        &lt;constructor-arg ref="dataSource"/&gt;<br />    &lt;/bean&gt;<br />&lt;/beans&gt;<br /><br /></pre></div><div><br /></div><div><br />This simple application only fetches H2 database server time and prints it with full formatting:</div><a name='more'></a><div><br /></div><div><pre class="brush: java"><br />public class Foo {<br /><br />    private Bar bar;<br /><br />    private JdbcOperations jdbcOperations;<br /><br />    public String serverTime() {<br />        return bar.format(<br />                jdbcOperations.queryForObject("SELECT now()", Date.class)<br />        );<br />    }<br /><br />    public void setBar(Bar bar) {<br />        this.bar = bar;<br />    }<br /><br />    public void setJdbcOperations(JdbcOperations jdbcOperations) {<br />        this.jdbcOperations = jdbcOperations;<br />    }<br />}<br /></pre></div><div><br /></div><div><pre class="brush: java"><br />public class Bar {<br /><br />    private FastDateFormat dateFormat;<br /><br />    public void init() {<br />        dateFormat = FastDateFormat.getDateTimeInstance(FULL, FULL);<br />    }<br /><br />    public String format(Date date) {<br />        return dateFormat.format(date);<br />    }<br />}<br /></pre></div><div><br /></div><div>There is something disturbing about this code. First of all there is surprisingly a lot of XML. It is still less compared to similar EJB 2.1 application (with <a href="https://github.com/nurkiewicz/spring-di/tree/spring-1.2.6">minor changes</a> this code runs on Spring 1.2.6 dating back to 2006), but it just feels wrong. The public setters are even more disturbing – why are we forced to expose the ability to override object dependencies at any time and by anyone? By the way I never really understood why Spring does not allow injecting dependencies directly to private fields when &lt;property&gt; tag is used since it is possible with...</div><div><br /></div><h4>   Annotations [<a href="https://github.com/nurkiewicz/spring-di/tree/annotations">full source</a>]</h4><div>Java 5 and Spring 2.5 brought support for annotation-driven dependency injection:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;context:annotation-config/&gt;<br /><br />&lt;!-- or even: --&gt;<br /><br />&lt;context:component-scan base-package="com.blogspot.nurkiewicz"/&gt;<br /></pre></div><div><br /></div><div>Take the first line and you no longer have to define &lt;property&gt; tags in your XML, only &lt;bean&gt;s. The framework will pick up standard @Resource annotations. Replace it with the second line and you don't even have to specify beans in your XML at all:</div><div><br /></div><div><pre class="brush: java"><br />@Service<br />public class Foo {<br /><br />    @Resource<br />    private Bar bar;<br /><br />    @Resource<br />    private JdbcOperations jdbcOperations;<br /><br />    public String serverTime() {<br />        return bar.format(<br />                jdbcOperations.queryForObject("SELECT now()", Date.class)<br />        );<br />    }<br />}<br /></pre></div><div><br /></div><div><pre class="brush: java"><br />@Service<br />public class Bar {<br /><br />    private FastDateFormat dateFormat;<br /><br />    @PostConstruct<br />    public void init() {<br />        dateFormat = FastDateFormat.getDateTimeInstance(FULL, FULL);<br />    }<br /><br />    public String format(Date date) {<br />        return dateFormat.format(date);<br />    }<br />}<br /></pre></div><div><br /></div><div>Of course you are not impressed! <i>Nihil novi</i>. Also we still have to live with XML because we have no control over 3rd party classes (like data source and <a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html">JdbcTemplate</a>), hence we can't annotate them. But Spring 3.0 introduced:</div><div><br /></div><h4>   @Configuration [<a href="https://github.com/nurkiewicz/spring-di/tree/at-configuration">full source</a>]</h4><div>I've been already exploring the <a href="http://nurkiewicz.com/2011/01/spring-framework-without-xml-at-all.html">@Configuration/@Bean</a>support, so this time please focus on how we start the application context. Do you see any reference to the XML file? The applicationContext.xml descriptor is gone completely:</div><div><pre class="brush: java"><br />@ComponentScan("com.blogspot.nurkiewicz")<br />public class Bootstrap {<br /><br />    private static final Logger log = LoggerFactory.getLogger(Bootstrap.class);<br /><br />    @Bean<br />    public DataSource dataSource() {<br />        final BasicDataSource dataSource = new BasicDataSource();<br />        dataSource.setDriverClassName("org.h2.Driver");<br />        dataSource.setUrl("jdbc:h2:mem:");<br />        dataSource.setUsername("sa");<br />        return dataSource;<br />    }<br /><br />    @Bean<br />    public JdbcTemplate jdbcTemplate() {<br />        return new JdbcTemplate(dataSource());<br />    }<br /><br />    public static void main(String[] args) {<br />        final AbstractApplicationContext applicationContext = new AnnotationConfigApplicationContext(Bootstrap.class);<br />        final Foo foo = applicationContext.getBean(Foo.class);<br /><br />        log.info(foo.serverTime());<br /><br />        applicationContext.close();<br />    }<br />}<br /><br /></pre></div><div><br /></div><div>As you can see Spring came quite a long road from XML-heavy to XML-free framework. But the most exciting part is that you can you use whichever style you prefer or even mix them. You can take legacy Spring application and start using annotations or switch to XML for god knows what reasons here or there.</div><div><br /></div><div>One technique I haven't mentioned is constructor injection. It has some great benefits (see <a href="http://tech.finn.no/2011/05/13/dependency-injection-with-constructors/"><i>Dependency Injection with constructors?</i></a>), like ability to mark dependencies as final and forbidding to create uninitialized objects:</div><div><br /></div><div><pre class="brush: java"><br />@Service<br />public class Foo {<br /><br />    private final Bar bar;<br /><br />    private final JdbcOperations jdbcOperations;<br /><br />    @Autowired<br />    public Foo(Bar bar, JdbcOperations jdbcOperations) {<br />        this.bar = bar;<br />        this.jdbcOperations = jdbcOperations;<br />    }<br /><br />    //...<br /><br />}<br /></pre></div><div><br /></div><div>I would love constructor injection, however once again I feel a bit disappointed. Each and every object dependency requires (a) constructor parameter, (b) final field and (c) assignment operation in constructor. We end up with ten lines of code that don't do anything yet. This chatty code  overcomes all the advantages. Of course no object should have more than <i>(put your number here)</i> dependencies – and thanks to constructor injection you immediately <b>see</b> that the object has too many – but still I find this code introducing too much ceremony.</div><div><br /></div><h4>   Spring constructor injection with Scala [<a href="https://github.com/nurkiewicz/spring-di/tree/scala">full source</a>]</h4>One feature of Scala fits perfectly into Spring framework: each argument of any Scala object by default creates final field named the same as this argument. What does this mean in our case? Look at Foo class translated to Scala:<br /><br /><br /><br /><pre class="brush: scala"><br />@Service<br />class Foo @Autowired() (bar: Bar, jdbcOperations: JdbcOperations) {<br /><br />    def serverTime() = bar.format(jdbcOperations.queryForObject("SELECT now()", classOf[Date]))<br /><br />}<br /></pre><br /><br /><br /><br /><div>Seriously? But... how? Before we dive into advantages of Scala here, look at the equivalent Java code as generated by Java decompiler:</div><div><br /></div><div><pre class="brush: java"><br />@Service<br />public class Foo implements ScalaObject<br />{<br />    private final Bar bar;<br />    private final JdbcOperations jdbcOperations;<br /><br />    @Autowired<br />    public Foo(Bar bar, JdbcOperations jdbcOperations)<br />    {<br />        this.bar = bar;<br />        this.jdbcOperations = jdbcOperations;<br />    }<br /><br />    public String serverTime()<br />    {<br />        return this.bar.format(this.jdbcOperations.queryForObject("SELECT now()", Date.class));<br />    }<br /><br />}<br /></pre></div><div><br /></div><div>Almost exactly the same code as we would have written in Java. With all the advantages: dependencies are final making our services truly immutable and stateless; dependencies are private and not exposed to the outside world; literally no extra code to manage dependencies: just add constructor argument, Scala will take care of the rest.</div><div><br /></div><div>To wrap things up – you have a wide range of possibilities. From XML, through Java code to Scala. The last approach is actually very tempting as it saves you from all the boilerplate and allows you to focus on business functionality. The <a href="https://github.com/nurkiewicz/spring-di">full source code</a>is available under my GitHub repository, each step is tagged so you can compare and choose whichever approach you like the most.</div>