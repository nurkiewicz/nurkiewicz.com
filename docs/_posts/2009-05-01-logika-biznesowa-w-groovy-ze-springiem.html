---
layout: post
title: Logika biznesowa w Groovy ze Springiem i JPA część 1/2
date: '2009-05-01T19:30:00.008+02:00'
author: Tomasz Nurkiewicz
tags:
- groovy
- jpa
- spring
modified_time: '2009-05-01T21:18:35.300+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-149155473742187100
blogger_orig_url: https://www.nurkiewicz.com/2009/05/logika-biznesowa-w-groovy-ze-springiem.html
---

Na początek scenka rodzajowa: w pewnym systemie istotną rolę odgrywała wstępna weryfikacja klienta opisanego następującym obiektem:<br /><pre name="code" class="java">public class CustomerProfile {<br />  private long pesel;<br />  private int age;<br />  private BigDecimal salary;<br />  private Locale country;<br />  //get/set<br />}<br /></pre>Komponent realizujący weryfikację ma intuicyjny interfejs:<br /><pre name="code" class="java">public interface CustomerVerifier {<br />  boolean verify(CustomerProfile profile);<br />}</pre>W pierwszej wersji systemu wystarczyła zwykła implementacja i wpis w deskryptorze springowym:<br /><pre name="code" class="xml">&lt;bean id="customerVerifier " class="com.blogspot.nurkiewicz.customer.CustomerVerifierImpl"></pre>Życie jednak pokazało, że logika biznesowa dokonująca weryfikacji zmienia się jak w kalejdoskopie. Dochodzą nowe warunki, zmieniają się parametry, coraz nowe komponenty biorą udział w weryfikacji. Jasnym stało się, że zamiast sztywnego kodu w Javie potrzebny jest bardziej elastyczny kod skryptowy, niezależny od aplikacji i możliwy do modyfikacji bez ponownego wdrażania. Szczęściem w nieszczęściu wystarczy zmiana w XMLu:<br /><pre name="code" class="xml">&lt;lang:groovy id="customerVerifier" script-source="/scripts/CustomerVerifier.groovy"<br />   refresh-check-delay="1000" autowire="byType" /></pre>Zamiast zwykłego beanu odwołujemy się do pliku z kodem źródłowym w Groovy gdzieś na dysku:<br /><pre name="code" class="java">class GroovyCustomerVerifier implements CustomerVerifier {<br /><br />  boolean verify(CustomerProfile profile)    {<br />     return profile.age in (24..56)<br />  }<br />}</pre>Potęga Groovy w połączeniu ze Springiem jest widoczna od razu: po pierwsze klasa w Groovy implementuje interfejs biznesowy w Javie - z punktu widzenia użytkownika komponentu <span style="font-family:courier new;">CustomerVerifier </span>(a zatem i reszty istniejącego kodu) nie widać różnicy. Poza tym zwróćcie uwagę jak wygodną składnię daje Groovy w dostępie do <span style="font-family:courier new;">CustomerProfile</span>.<br /><br />Dobrze, to było trywialne. Ale stary komponent <span style="font-family:courier new;">CustomerVerifierImpl </span>miał dodatkowo wstrzyknięty bean (już w Javie) implementujący interfejs <span style="font-family:courier new;">CustomerBlackList </span>(implementacja trywialna, semantyka oczywista :-)):<br /><pre name="code" class="java">public interface CustomerBlackList {<br />  boolean isBlackListed(long pesel);<br />}</pre>Jak skorzystać z dobrodziejstw DI w Groovim? Tutaj Spring znowu pokazuje pazur:<br /><pre name="code" class="java">class GroovyCustomerVerifier implements CustomerVerifier {<br /> CustomerBlackList customerBlackList<br /><br /> boolean verify(CustomerProfile profile)    {<br />     return !customerBlackList.isBlackListed(profile.pesel) &amp;&amp; profile.age in (24..56)<br /> }<br /><br />}</pre>Wystarczyło dodać pole w klasie Groovy i już, można w skrypcie korzystać z beanu springowego! Mało tego, w ten sam sposób można wstrzyknąć do skryptu dowolny bean, a nawet <span style="font-family:courier new;">EntityManager </span>ze specyfikacji JPA. Mało tego, możemy użyc adnotacji <span style="font-family:courier new;">@Transactional</span> i objąć metody w Groovy transakcjami springowymi! Daje to ogromne możliwości twórcom skryptów zwłaszcza, że nie wymaga ponownego wdrażania aplikacji. A wszystko dzięki atrybutowi<span style="font-family:courier new;">  autowire="byType"</span>.<br /><br />Jest już całkiem nieźle - logika została wyniesiona do pliku, można korzystać do woli z pozostałych komponentów w naszej aplikacji. Jest tylko mały problem - niemal niczego jeszcze nie osiągnęliśmy… Logika co prawda jest na zewnątrz, ale utrzymanie plików ze skryptem gdzieś na dysku i ich ręczna edycja to kiepski pomysł. Niewygodnie się to klastruje, nie pozwala na kontrolę dostępu, historię, transakcyjność… Słowem: potrzebujemy bazy danych do przechowywania naszych skryptów. I tu niemiły zgrzyt: Spring wspiera jedynie pobieranie skryptów z dysku lub wpisywanie ich bezpośrednio w deskryptorze <span style="font-family:courier new;">applicationContext.xml</span> - czyli jeszcze gorzej*. I tu zaczyna się cała zabawa! Jak zmusić Springa do ładowania (i odświeżania!) skryptów zapisanych w bazie danych - w <a href="http://nurkiewicz.blogspot.com/2009/05/logika-biznesowa-w-groovy-ze-springiem_01.html">następnym wpisie</a>.<br /><br />* Przynajmniej do czasu rozwiązania <a href="http://jira.springframework.org/browse/SPR-5106">SPR-5106</a>, czyli wersji 3.1 Springa...