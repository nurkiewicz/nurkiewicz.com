---
layout: post
title: Three flavours of request-response pattern in Akka
date: '2014-01-08T22:19:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- akka
- scala
modified_time: '2014-01-08T23:50:03.828+01:00'
thumbnail: http://4.bp.blogspot.com/-7Xbe4g85cWg/Us3WEVRSjLI/AAAAAAAAA7w/3F-TzQzi-DQ/s72-c/actors2.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5678947259668429807
blogger_orig_url: https://www.nurkiewicz.com/2014/01/three-flavours-of-request-response.html
---

Imagine a simple Akka actor system consisting of two parties: <code>MonitoringActor</code> and <code>NetworkActor</code>. Whenever someone (<i>client</i>) sends <code>CheckHealth</code> to the former one it asks the latter by sending <code>Ping</code>. <code>NetworkActor</code> is obligated to reply with <code>Pong</code> as soon as possible (scenario [A]). Once <code>MonitoringActor</code> receives such a reply it immediately replies to the client with <code>Up</code> status message. However <code>MonitoringActor</code> is obligated to send <code>Down</code> reply if <code>NetworkActor</code> failed to respond with <code>Pong</code> within one second (scenario [B]). Both workflows are depicted below:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-7Xbe4g85cWg/Us3WEVRSjLI/AAAAAAAAA7w/3F-TzQzi-DQ/s1600/actors2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-7Xbe4g85cWg/Us3WEVRSjLI/AAAAAAAAA7w/3F-TzQzi-DQ/s1600/actors2.png" height="223" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><br /></div><h1></h1>Apparently there are at least three ways to implement this simple task in Akka and we shall study their pros and cons.<br /><br /><h2>Ordinary actor</h2>In this scenario <code>MonitoringActor</code> listens for <code>Pong</code> directly without any intermediaries:<br /><br /><pre class="brush: scala">class MonitoringActor extends Actor with ActorLogging {<br /><br />  private val networkActor = context.actorOf(Props[NetworkActor], "network")<br />  private var origin: Option[ActorRef] = None<br /><br />  def receive = {<br />    case CheckHealth =&gt;<br />      networkActor ! Ping<br />      origin = Some(sender)<br />    case Pong =&gt;<br />      origin.foreach(_ ! Up)<br />      origin = None<br />  }<br />}<br /></pre>The implementation of <code>NetworkActor</code> is irrelevant, just assume it responds with <code>Pong</code> for each <code>Ping</code>. As you can see <code>MonitoringActor</code> handles two messages: <code>CheckHealth</code> sent by the client and <code>Pong</code> sent presumably by the <code>NetworkActor</code>. Sadly we had to store the client reference under <code>origin</code> field because it would have been lost otherwise once <code>CheckHealth</code> was handled. So we added a bit of state. The implementation is quite straightforward but has quite a few issues:<br /><br /><ul><li>Subsequent <code>CheckHealth</code> will overwrite previous <code>origin</code></li><li><code>CheckHealth</code> should not really be allowed when waiting for <code>Pong</code> </li><li>If <code>Pong</code> never arrives we are left in inconsistent state</li><li>...because we don't have 1 second timeout condition yet</li></ul>But before we implement timeout condition let's refactor our code a little bit to make state more explicit and type-safe:<br /><br /><pre class="brush: scala">class MonitoringActor extends Actor with ActorLogging {<br /><br />  private val networkActor = context.actorOf(Props[NetworkActor], "network")<br /><br />  def receive = waitingForCheckHealth<br /><br />  private def waitingForCheckHealth: Receive = {<br />    case CheckHealth =&gt;<br />      networkActor ! Ping<br />      context become waitingForPong(sender)<br />  }<br /><br />  private def waitingForPong(origin: ActorRef): Receive = {<br />    case Pong =&gt;<br />      origin ! Up<br />      context become waitingForCheckHealth<br />  }<br />}<br /></pre><code>context.become()</code> allows to <a href="http://nurkiewicz.com/2012/11/becomeunbecome-discovering-akka.html">change the behaviour of actor on the fly</a>. In our case we either wait for <code>CheckHealth</code> or for <code>Pong</code> - but never both. But where did the state (<code>origin</code> reference) go? Well, it's cleverly hidden. <code>waitingForPong()</code> method takes <code>origin</code> as parameter and returns a <code>PartialFunction</code>. This function closes over that parameter, thus actor-global variable is no longer necessary. OK, now we are ready to implement 1 second timeout when waiting for <code>Pong</code>:<br /><br /><pre class="brush: scala">def receive = waitingForCheckHealth<br /><br />private def waitingForCheckHealth: Receive = {<br />  case CheckHealth =&gt;<br />    networkActor ! Ping<br />    implicit val ec = context.dispatcher<br />    val timeout = context.system.scheduler.<br />      scheduleOnce(1.second, self, Down)<br />    context become waitingForPong(sender, timeout)<br />}<br /><br />private def waitingForPong(origin: ActorRef, timeout: Cancellable): Receive = LoggingReceive {<br />  case Pong =&gt;<br />    timeout.cancel()<br />    origin ! Up<br />    context become receive<br />  case Down =&gt;<br />    origin ! Down<br />    context become receive<br />}<br /></pre>After sending <code>Ping</code> we immediately schedule sending <code>Down</code> message to ourselves after precisely one second. Then we go into <code>waitingForPong</code>. If <code>Pong</code> arrives we cancel scheduled <code>Down</code> and send <code>Up</code> instead. However if we first received <code>Down</code> it means one second elapsed. So we forward <code>Down</code> back to the client. Is it just me or maybe such a simple task should not require that amount of code?<br /><br />Moreover please notice that our <code>MonitoringActor</code> is not capable of handling more than one client at a time. Once <code>CheckHealth</code> was received no more clients are allowed until <code>Up</code> or <code>Down</code> is sent back. Seems quite limiting. <br /><br /><h2>Composing futures</h2>Another approach to the very same problem is employing <code>ask</code> pattern and futures. Suddenly the code becomes much shorter and easier to read:<br /><br /><pre class="brush: scala">def receive = {<br />  case CheckHealth =&gt;<br />    implicit val timeout: Timeout = 1.second<br />    implicit val ec = context.dispatcher<br />    val origin = sender<br />    networkActor ? Ping andThen {<br />      case Success(_) =&gt; origin ! Up<br />      case Failure(_) =&gt; origin ! Down<br />    }<br />}<br /></pre>That's it! We <i>ask</i> <code>networkActor</code> by sending <code>Ping</code> <i>and then</i> when response arrives we reply to the client. In case it was a <code>Success(_)</code> (<code>_</code> placeholder stands for <code>Pong</code> but we don't really care) we send <code>Up</code>. If it was a <code>Failure(_)</code> (where <code>_</code> most probably holds <code>AskTimeout</code> thrown after one second without reply) we forward <code>Down</code>. There is one enormous trap in this code. In both success and failure callbacks we can't use <code>sender</code> directly because these pieces of code can be executed much later by another thread. <code>sender</code>'s value is transient and by the time <code>Pong</code> arrives it might point to any other actor that happened to send us something. Thus we have to keep original <code>sender</code> in <code>origin</code> local variable and capture that one instead.<br /><br />If you find this annoying you might play with <code>pipeTo</code> pattern:<br /><br /><pre class="brush: scala">def receive = LoggingReceive {<br />  case CheckHealth =&gt;<br />    implicit val ec = context.dispatcher<br />    networkActor.ask(Ping)(1.second).<br />      map{_ =&gt; Up}.<br />      recover{case _ =&gt; Down}.<br />      pipeTo(sender)<br />}<br /></pre>Same as before we <code>ask</code> (synonym to <code>?</code> method) <code>networkActor</code> with a timeout. If correct reply arrives we map it to <code>Up</code>. If instead future ends with exception we recover from it by mapping it to <code>Down</code> message. No matter which "branch" was exercised the result is <i>piped</i> to <code>sender</code>.<br /><br />You should ask yourself a question: why code above is fine despite using <code>sender</code> while the previous one would have been broken? If you look closely at the declarations you'll notice that <code>pipeTo()</code> takes an <code>ActorRef</code> by value, not by name. This means that <code>sender</code> is evaluated immediately when the expression is executed - not later when replies return. We are walking on a thin ice here so please be careful when making such assumptions. <br /><br /><h2>Dedicated actor</h2>Actors are lightweight so why not create one just for the sake of a single health check? This throw-away actor would be responsible for communicating with <code>NetworkActor</code> and pushing reply back to the client. The only responsibility of <code>MonitoringActor</code> would be to create an instance of this one time actor:<br /><br /><pre class="brush: scala">class MonitoringActor extends Actor with ActorLogging {<br /><br />  def receive = {<br />    case CheckHealth =&gt;<br />      context.actorOf(Props(classOf[PingActor], networkActor, sender))<br />  }<br /><br />}<br /></pre><code>PingActor</code> is quite simple and similar to the very first solution:<br /><br /><pre class="brush: scala">class PingActor(networkActor: ActorRef, origin: ActorRef) extends Actor with ActorLogging {<br /><br />  networkActor ! Ping<br />  context.setReceiveTimeout(1.second)<br /><br />  def receive = {<br />    case Pong =&gt;<br />      origin ! Up<br />      self ! PoisonPill<br />    case ReceiveTimeout =&gt;<br />      origin ! Down<br />      self ! PoisonPill<br />  }<br />}<br /></pre>When the actor is created we send <code>Ping</code> to <code>NetworkActor</code> but also schedule timeout message. Now we wait either for <code>Pong</code> or for timeouted <code>Down</code>. In both cases we stop ourselves in the end because <code>PingActor</code> is no longer needed. Of course <code>MonitoringActor</code> can create multiple independent <code>NetworkActor</code>s at the same time.<br /><br />This solution combines simplicity and purity of the first one but is robust as the second one. Of course it also requires most code. It's up to you which technique you employ in real life use cases. BTW after writing this article I came across <a href="http://techblog.net-a-porter.com/2013/12/ask-tell-and-per-request-actors/">Ask, Tell and Per-request Actors</a> which touches the same problem and introduces similar approaches. Definitely look at it as well!<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>