---
layout: post
title: Chain of responsibility pattern meets Spring, JPA, Wicket and Apache CXF part
  2/2
date: '2009-12-01T20:35:00.009+01:00'
author: Tomasz Nurkiewicz
tags:
- groovy
- jpa
- wicket
- design patterns
- spring
- h2
modified_time: '2009-12-01T21:08:17.085+01:00'
thumbnail: http://1.bp.blogspot.com/_P3ewsGQzHn0/SxV0O4TanyI/AAAAAAAAAQI/nLxYAk2ddJc/s72-c/squirrel.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2670750540575753289
blogger_orig_url: https://www.nurkiewicz.com/2009/12/chain-of-responsibility-pattern-meets.html
---

In the <a href="http://nurkiewicz.com/2009/11/chain-of-responsibility-pattern-meets.html">first part</a> of this article I have shown a semi-real life example of the Chain of responsibility pattern (also mentioning about Iterator, Adapter and DTO). This behavioral design pattern has been used to control the process of registering a car, consisting of several steps. Everything worked es expected but modifying the chain configuration required application restart. Also not everyone might enjoy editing Spring context XML files. We will address this issues and make our application more dynamic.<br /><br />If not storing the chain configuration in Spring file directly, then where? Of course in the database, preferably using JPA. This is the JPA entity that will serve as a single handler configuration:<br /><br /><pre class="brush: java">public class RegistrationChainHandlerConfig implements Serializable {<br />    private int id;<br />    private String handlerName;<br />    private int priority;<br />    private boolean enabled;<br />    /* getters/setters */<br />}</pre><br /><br />Each handler configured as a Spring bean is going to have a corresponding <span style="font-family:courier new;">RegistrationChainHandlerConfig</span> instance (and database row as well). <span style="font-family:courier new;">handlerName </span>is a Spring bean name, priority is simply used to control the order of handlers. The bigger priority, the sooner this handler will be executed. Also enabled attribute has been introduced – instead of decreasing the priority (probably moving the handler after <span style="font-family:courier new;">CatchAllHandler</span>) it can be simply disabled and temporarily ignored.<br /><br />The configuration is moved to the database, but how this particular table is going to be populated? We can provide SQL script and update it every time new handler is added or removed from the application. But it is cumbersome and easy to miss when updating the application. We could also provide web user interface to provide <span style="font-style: italic;">CRUD </span>functionality on this table. Actually we will, but with a functionality limited to modifying existing entities (<span style="font-style: italic;">-RU-</span>). So how is the data going to be initially populated with handlers configuration? Well, we are going to <span style="font-weight: bold;">discover</span> all available handlers at application startup and keep them in sync without any user or administrator attention! Thanks to this brilliant mechanism whenever developer adds any new Spring bean implementing <span style="font-family:courier new;">RegistrationChainHandler</span>, it is going to be picked up and ready to serve in chain. So let’s go!<br /><br />The first step and a sad part already: Spring does not have a built-in support for running code (preferably given method of arbitrary Spring bean) after the context has successfully started. You can use init-method attribute, <a href="http://java.sun.com/javaee/5/docs/api/javax/annotation/PostConstruct.html">@PostContruct</a> <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html">[1]</a> or <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/InitializingBean.html">InitializingBean</a> to perform some logic after particular bean is created. But, as far as I know, no such option exist to run some logic after whole context is set up. Luckily, all you need (<a href="http://en.wikipedia.org/wiki/All_You_Need_Is_Love">except love</a> of course) to work around this problem is to subclass <a href="http://static.springsource.org/spring/docs/2.5.6/api/org/springframework/web/context/ContextLoaderListener.html">ContextLoaderListener</a> and override <span style="font-family:courier new;">contextInitialized()</span> with a very awkward code:<br /><br /><pre class="brush: java">public class CarRegistrationContextLoaderListener extends ContextLoaderListener {<br /><br />    @Override<br />    public void contextInitialized(ServletContextEvent event) {<br />        super.contextInitialized(event);<br />        ApplicationContext context = WebApplicationContextUtils.getRequiredWebApplicationContext(event.getServletContext());<br /><br />        refreshRegistrationChainHandlers(context);<br />    }<br /><br />    private void refreshRegistrationChainHandlers(ApplicationContext context) {<br />        RegistrationChainRefresher refresher = (RegistrationChainRefresher) context.getBean("databaseRegistrationChainProvider");<br />        refresher.refreshHandlers();<br />    }<br />}</pre><br /><br />This is horrible for two reasons: first is using awkward <a href="http://static.springsource.org/spring/docs/2.5.6/api/org/springframework/web/context/support/WebApplicationContextUtils.html">WebApplicationContextUtils</a> and obtaining bean by name. The second reason is that running <span style="font-family:courier new;">super()</span> in overridden method is actually an <a href="http://en.wikipedia.org/wiki/Call_super">anti-pattern</a>. But I hope this tremendous code is justified by the fact, that I am only working around featureless Spring. If you know a better way, please enlighten me! Oh, you must of course point newly created class in web.xml:<br /><br /><pre class="brush: xml">&lt;listener&gt;<br />    &lt;listener-class&gt;com.blogspot.nurkiewicz.cars.CarRegistrationContextLoaderListener&lt;/listener-class&gt;<br />&lt;/listener&gt;</pre><br /><br />You probably wonder how does the implementation of <span style="font-family:courier new;">RegistrationChainRefresher </span>look like. Everything for you, my dearest Reader:<br /><br /><br /><pre class="brush: java">public class DatabaseRegistrationChainProvider implements RegistrationChainRefresher {<br /><br />    @Resource<br />    private RegistrationChainDao registrationChainDao;<br /><br />    @Resource<br />    private ListableBeanFactory beanFactory;<br /><br />    @Override<br />    @Transactional<br />    public void refreshHandlers() {<br />        List&lt;String&gt; existingHandlers = registrationChainDao.getAllHandlersNames();<br />        Map&lt;String, Object&gt; handlersMap = beanFactory.getBeansOfType(RegistrationChainHandler.class);<br />        List&lt;String&gt; availableHandlers = new ArrayList&lt;String&gt;(handlersMap.keySet());<br />        removeNotAvailableHandlers(existingHandlers, availableHandlers);<br />        addNewAvailableHandlers(existingHandlers, availableHandlers);<br />    }<br />    /* ... */<br />}</pre><br /><br />The code is not so sophisticated as it sounded, although I skipped logging and huge part of logic, but core has left. As you can see first we load all the handlers in the database (<span style="font-family:courier new;">existingHandlers</span>) – this list is empty when running for the first time. Then we obtain all Spring beans which implement <span style="font-family:courier new;">RegistrationChainHandler </span>(<span style="font-family:courier new;">availableHandlers</span>). This sounds complicated but is actually very simple since Spring provides <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/ListableBeanFactory.html#getBeansOfType%28java.lang.Class%29">utility</a> for that. Simply inject <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/ListableBeanFactory.html">ListableBeanFactory</a> or implement <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/BeanFactoryAware.html">BeanFactoryAware</a>.<br /><br />I hope that names <span style="font-family:courier new;">removeNotAvailableHandlers()</span> and <span style="font-family:courier new;">addNewAvailableHandlers()</span> are descriptive enough and speak for themselves. First one scans through the handlers already found in the database and removes those, which are no longer present in Spring application context. The second one does the opposite: it goes through all Spring beans implementing handler interface and, if they yet do not exist in the database, adding them with default configuration. The defaults are: biggest priority (beginning of the chain) but disabled.<br /><br />If you wonder why not simply clear the database table and repopulate it each time the application is started, the answer is very simple. When this process adds new handler, it puts it at the beginning of the chain. But since the order in which Spring beans are processed is undetermined, you end up with some random chain configuration. It is up to user (by using the GUI which is just about to be implemented) to customize the chain and persist it. If the database was cleared every time, the user would have to configure the chain all over.<br /><br />I skipped lots of code here, but before we see it in action, there is one important thing left: constructing the chain. In the first approach chain (called <span style="font-family:courier new;">handlersList</span>) was just a list of Spring beans constructed by the Spring framework. Now we have a database table holding bean names. It can be retrieved using the following EJB QL query:<br /><br /><br /><pre class="brush: xml">&lt;named-query name="RegistrationChainHandlerConfig.handlerChain"&gt;<br />    &lt;query&gt;&lt;![CDATA[<br />        SELECT config.handlerName<br />        FROM RegistrationChainHandlerConfig config<br />        WHERE config.enabled = true<br />        ORDER BY config.priority DESC<br />    ]]&gt;&lt;/query&gt;<br />&lt;/named-query&gt;</pre><br /><br /><br />This query returns Spring bean names every time new request (car) is handled by the web service and needs to be handled by our chain. Being familiar with <span style="font-family:courier new;">BeanFactory</span> interface, we can load the actual bean instances based on their Spring symbolic names:<br /><br /><pre class="brush: java">private List&lt;RegistrationChainHandler&gt; resolveHandlersByName(List&lt;String&gt; handlersNames) {<br />    List&lt;RegistrationChainHandler&gt; handlers = new ArrayList&lt;RegistrationChainHandler&gt;(handlersNames.size());<br />    for (String handlerName : handlersNames)<br />        handlers.add((RegistrationChainHandler) beanFactory.getBean(handlerName, RegistrationChainHandler.class));<br />    return handlers;<br />}</pre><br /><br />BTW the same code using Groovy, aren’t closures great?<br /><br /><pre class="brush: groovy">private List&lt;RegistrationChainHandler&gt; resolveHandlersByName(List&lt;String&gt; handlersNames) {<br />    handlersNames.collect { beanFactory.getBean(it, RegistrationChainHandler) }<br />}</pre><br /><br />Having all this we run the application and see what’s in the database. This time I used <a href="http://www.h2database.com/">H2</a> database because I didn’t want to install any full-fledged relational database on my old laptop. H2 not only can be used within JUnit in in-memory mode, but also can be run as a stand-alone, transactional (ACID!), persistent data store with its own web interface. Look how easy it is:<br /><br /><pre class="brush: xml">&lt;bean id="h2Server" class="org.h2.tools.Server" factory-method="createTcpServer" init-method="start" destroy-method="stop" depends-on="h2WebServer"&gt;<br />    &lt;constructor-arg value="-tcp,-tcpAllowOthers,true,-tcpPort,9092,-baseDir,~/.cars/db"/&gt;<br />&lt;/bean&gt;<br />&lt;bean id="h2WebServer" class="org.h2.tools.Server" factory-method="createWebServer" init-method="start" destroy-method="stop"&gt;<br />    &lt;constructor-arg value="-web,-webAllowOthers,true,-webPort,8082"/&gt;<br />&lt;/bean&gt;<br /><br />&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close" depends-on="h2Server"&gt;<br />    &lt;property name="driverClass" value="org.h2.Driver"/&gt;<br />    &lt;property name="jdbcUrl" value="jdbc:h2:tcp://localhost:9092/cars"/&gt;<br />    &lt;property name="user" value="sa"/&gt;<br />    &lt;property name="acquireRetryAttempts" value="1"/&gt;<br />&lt;/bean&gt;</pre><br /><br />This is enough to:<br /><ul><li>start the database that listens on 9092 TCP port</li><li>start embedded web server on 8082 port (interactive web console with auto-completion!)</li><li>create a DataSource using this database</li></ul><br />Database is embedded within the application (it starts and stops together with Spring application context) and stores data in specified directory (<span style="font-family:courier new;">/cars/db</span> in current user home directory). Despite that, it works like a charm, see for youself:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_P3ewsGQzHn0/SxV0O4TanyI/AAAAAAAAAQI/nLxYAk2ddJc/s1600/squirrel.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 118px;" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/SxV0O4TanyI/AAAAAAAAAQI/nLxYAk2ddJc/s200/squirrel.png" alt="" id="BLOGGER_PHOTO_ID_5410358326336331554" border="0" /></a><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxV0DyCPWlI/AAAAAAAAAP4/7tjpRKJHeb0/s1600/h2connect.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 182px; height: 200px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxV0DyCPWlI/AAAAAAAAAP4/7tjpRKJHeb0/s200/h2connect.png" alt="" id="BLOGGER_PHOTO_ID_5410358135675116114" border="0" /></a><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxV0Ipa4lbI/AAAAAAAAAQA/2WdVbn1dE8Y/s1600/h2view.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 197px; height: 200px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxV0Ipa4lbI/AAAAAAAAAQA/2WdVbn1dE8Y/s200/h2view.png" alt="" id="BLOGGER_PHOTO_ID_5410358219261908402" border="0" /></a><br />Also you can see the random chain configuration. If we were to run our <a href="http://www.soapui.org/">SoapUI</a> functional test prepared in previous article, familiar error message would appear that the end of chain has been reached. Actually, the request road wasn’t so long – since all handlers are disabled by default, no handler has been executed before reaching the end.<br /><br />Although we could actually configure the chain now using <a href="http://squirrel-sql.sourceforge.net/">SquirrelSQL</a> or H2 web UI manually, we will develop web interface in <a href="http://wicket.apache.org/">Wicket</a> in just a moment. First please take a look at two handlers which were not mentioned in the first part of this article:<br /><br /><br /><pre class="brush: java">public class FakeHandler implements RegistrationChainHandler {<br /><br />    @Override<br />    public long handle(Car car, RegistrationChain chain) throws Exception {<br />        car.setId(RandomUtils.nextLong());<br />        return car.getId();<br />    }<br />}</pre><br /><br />This is a solution for a common problem in my job: during functional or load-testing some external systems which we integrate with are too hard to configure or simply unavailable. Because the tests must go on, we build fakes and mocks that mimic the behavior of external, third-party system and work on them as long as the real system is not available. Sometimes we even build several fakes, some with hardcoded data while others are configured from a flat file. But the biggest problem is switching the implementations back and forth. Even when both fake and real implementations have the same abstract interface (so switching the implementation has no impact on the rest of the code), the application must somehow discover which implementation to use at the moment (Spring context XML, properties file, JNDI property, etc.) Using the chain of responsibility pattern makes this usage scenario very clear and easy to develop. When you want to use fake, simply enable its handler (and make sure it comes before the real implementation handler). But when the real implementation should be used, disable fakeHandler and let the control pass through to the right handlers. You might even develop few fake handlers and enable/disable/arrange them in any way you want.<br /><br />The second new handler is just a demonstration of Java/Spring/Groovy integration and it implements the retry-after-failure behavior:<br /><br /><pre class="brush: java">public class GroovyHandler implements RegistrationChainHandler {<br /><br />    private static final Logger log = LoggerFactory.getLogger(GroovyHandler.class);<br /><br />    int count = 5<br /><br />    public long handle(Car car, RegistrationChain chain) {<br />        def ex<br />        for (int attemptNo = 1; attemptNo &lt;= count; ++attemptNo)<br />            try {<br />                log.trace "Running next handler attempt $attemptNo/$count"<br />                return chain.proceed(car)<br />            } catch (Exception e) {<br />                log.warn "Attempt $attemptNo/$count failed", e<br />                car.id = 0<br />                car.registrationNo = 0<br />                ex = e<br />            }<br />        throw new CarRegistrationException("Car registration failed after $count attempts. Last error: $ex", ex);<br />    }<br /><br />}</pre><br /><br />Not much is saved thanks to Groovy, but this is just a example. Declaring Spring bean based on this source code is as follows (note the count property being injected by Spring):<br /><br /><pre class="brush: xml">&lt;lang:groovy id="groovyHandler" script-source="classpath: GroovyHandler.groovy"&gt;<br />    &lt;lang:property name="count" value="2"/&gt;<br />&lt;/lang:groovy&gt;</pre><br /><br /><br />Now the promised web interface in Wicket. The idea is to allow system/business administrator to alter the car registration chain configuration by moving handlers and enabling/disabling them straight from user-friendly, web-based interface. This also happens to be my first (but certainly not last!) Wicket web application. We start by creating HTML view. That’s right, no JSP, EL, JSTL, Taglibs, scriptles, templates, tag files, etc. Pure HTML:<br /><br /><pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd"&gt;<br />&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;<br />&lt;head&gt;<br />    &lt;title&gt;Car registration handlers chain configuration&lt;/title&gt;<br />    &lt;style type="text/css"&gt;&lt;!-- --&gt;&lt;/style&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />    &lt;table&gt;<br />        &lt;thead&gt;<br />            &lt;tr&gt;<br />                &lt;th&gt;Id&lt;/th&gt;<br />                &lt;th&gt;Handler name&lt;/th&gt;<br />                &lt;th&gt;Priority&lt;/th&gt;<br />                &lt;th&gt;Enabled?&lt;/th&gt;<br />                &lt;th&gt;Actions&lt;/th&gt;<br />            &lt;/tr&gt;<br />        &lt;/thead&gt;<br />    &lt;span wicket:id="handlersList"&gt;<br />        &lt;tr&gt;<br />            &lt;td&gt;&lt;span wicket:id="id"&gt;1&lt;/span&gt;&lt;/td&gt;<br />            &lt;td&gt;&lt;span wicket:id="handlerName"&gt;fakeHandler&lt;/span&gt;&lt;/td&gt;<br />            &lt;td&gt;&lt;span wicket:id="priority"&gt;8&lt;/span&gt;&lt;/td&gt;<br />            &lt;td&gt;&lt;span wicket:id="enabled"&gt;yes &lt;/span&gt; (&lt;a href="#" wicket:id="disableLink"&gt;disable&lt;/a&gt;&lt;a href="#" wicket:id="enableLink"&gt;enable&lt;/a&gt;)&lt;/td&gt;<br />            &lt;td&gt;&lt;a href="#" wicket:id="upLink"&gt;up&lt;/a&gt; &lt;a href="#" wicket:id="downLink"&gt;down&lt;/a&gt;&lt;/td&gt;<br />        &lt;/tr&gt;<br />    &lt;/span&gt;<br />    &lt;/table&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</pre><br /><br />Nothing fancy. Now the corresponding page implementation:<br /><br /><br /><pre class="brush: java">public class RegistrationChainConfigPage extends WebPage {<br /><br />    private List&lt;RegistrationChainHandlerConfig&gt; handlersConfig = new ArrayList&lt;RegistrationChainHandlerConfig&gt;();<br /><br />    @SpringBean<br />    private RegistrationChainConfiguration chainConfigration;<br />    private final HandlersListView handlersListView;<br /><br />    public RegistrationChainConfigPage() {<br />        handlersListView = new HandlersListView();<br />        loadConfigs();<br />        add(handlersListView);<br />    }<br /><br />    private void loadConfigs() {<br />        handlersConfig = chainConfigration.getAllHandlersConfig();<br />        handlersListView.setModelObject(handlersConfig);<br />    }<br /><br />    private class HandlersListView extends ListView&lt;RegistrationChainHandlerConfig&gt; {<br /><br />    public HandlersListView() {<br />        super("handlersList", handlersConfig);<br />    }<br /><br />    @Override<br />    protected void populateItem(ListItem&lt;RegistrationChainHandlerConfig&gt; item) {<br />        RegistrationChainHandlerConfig config = item.getModelObject();<br />        item.add(new Label("id", new Model&lt;Integer&gt;(config.getId())));<br />        item.add(new Label("handlerName", config.getHandlerName()));<br />        item.add(new Label("priority", new Model&lt;Integer&gt;(config.getPriority())));<br />        item.add(new Label("enabled", BooleanUtils.toStringYesNo(config.isEnabled())));<br />        item.add(new EnableDisableLink(config, true));<br />        item.add(new EnableDisableLink(config, false));<br />        item.add(new SwitchPriorityLink(item.getIndex(), true));<br />        item.add(new SwitchPriorityLink(item.getIndex(), false));<br />    }<br /><br />    private class EnableDisableLink extends Link {<br /><br />        private final RegistrationChainHandlerConfig config;<br /><br />        public EnableDisableLink(RegistrationChainHandlerConfig config, boolean enable) {<br />            super(enable ? "enableLink" : "disableLink");<br />            this.config = config;<br />            setVisible(config.isEnabled() &amp;&amp; !enable || !config.isEnabled() &amp;&amp; enable);<br />        }<br /><br />        @Override<br />        public void onClick() {<br />            config.setEnabled(!config.isEnabled());<br />            chainConfigration.update(config);<br />        }<br />    }<br /><br />    private class SwitchPriorityLink extends Link {<br /><br />        RegistrationChainHandlerConfig first;<br />        RegistrationChainHandlerConfig second;<br /><br />        public SwitchPriorityLink(int index, boolean up) {<br />            super(up ? "upLink" : "downLink");<br />            first = handlersConfig.get(index);<br />            if (up) {<br />                if (index &gt; 0)<br />                    second = handlersConfig.get(index - 1);<br />                else<br />                    setVisible(false);<br />            } else {<br />                if (index + 1 &lt; handlersConfig.size())<br />                    second = handlersConfig.get(index + 1);<br />                else<br />                    setVisible(false);<br />            }<br />        }<br /><br />        @Override<br />        public void onClick() {<br />            chainConfigration.switchPriorities(first, second);<br />            loadConfigs();<br />        }<br />    }<br /><br />    }<br />}</pre><br /><br />So much has been said lately about Wicket that explaining this code is pointless. Actually, it is rather easy to read and understand, especially read together with corresponding HTML (focus on wicket:id attributes). Enough to say is that this page displays database-backed table with a few links controlling each handlers’ position and availability.<br /><br />In about 100 lines of Java code (service layer RegistrationChainConfiguration class has been skipped ) and a pure HTML I have created web page from scratch, implementing two use cases. And all that with tiny Wicket background. I am starting to shiver when thinking about the same task in Struts 2...<br /><br />Finally! Here is the result and the final chain configuration few clicks later:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_P3ewsGQzHn0/SxV1GC0RuzI/AAAAAAAAAQY/971Lmg4rfzM/s1600/wicket1.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 194px; height: 200px;" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/SxV1GC0RuzI/AAAAAAAAAQY/971Lmg4rfzM/s200/wicket1.png" alt="" id="BLOGGER_PHOTO_ID_5410359274051320626" border="0" /></a><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_P3ewsGQzHn0/SxV1C7l5sgI/AAAAAAAAAQQ/7dZt6DY5tzE/s1600/wicket2.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 188px; height: 200px;" src="http://4.bp.blogspot.com/_P3ewsGQzHn0/SxV1C7l5sgI/AAAAAAAAAQQ/7dZt6DY5tzE/s200/wicket2.png" alt="" id="BLOGGER_PHOTO_ID_5410359220572369410" border="0" /></a><br /><br />Was it all worth it? All this logic, DAO, web interface – since all we had to do was to implement a simple business process with few steps? Well, stories that you can turn logging and validation on and off at runtime might not convince you. Also the ability to change the order of some operations might not be sufficient. But what about this scenario? A new team member has been given a task of implementing another step in car registration process: if the car has been manufactured more than 20 years ago, the registration should fail immediately. If the car is between 10 and 20 years, registration should succeed, but JMS message containing newly registered car must be sent for further validation.<br /><br />In a traditional approach a new developer would find some place in web service implementation and inject his or her code in a reasonably looking place. This is not only complicated, because lots of existing code must be studied, but also error-prone, very likely breaking existing functionality. But when using chain of responsibility pattern, each handler is decoupled from the others, so the developer only focuses on the handler he or she creates. The handler can be easily unit tested, without worrying about other handlers behavior.<br /><br />So the developer sat for a day or two, quickly discovered how <span style="font-family:courier new;">RegistrationChainHandler</span> interface work and wrote new handler:<br /><br /><br /><br /><pre class="brush: java">@Service<br />public class DateManufacturedValidatorHandler implements RegistrationChainHandler {<br /><br />    private int warnIfOlderThanYears = 10;<br />    private int failIfOlderThanYears = 20;<br /><br />    @Resource<br />    private JmsTemplate jmsTemplate;<br /><br />    public long handle(Car car, RegistrationChain chain) throws Exception {<br />        failIfTooOld(car);<br />        chain.proceed(car);<br />        warnIfTooOld(car);<br />        return car.getId();<br />    }<br /><br />    private void failIfTooOld(Car car) {<br />        if (beforeGivenYearsToPresent(car.getDateManufactued(), failIfOlderThanYears))<br />            throw new CarRegistrationException("Car has been manufactured more than " + failIfOlderThanYears + " years ago");<br />    }<br /><br />    private void warnIfTooOld(final Car car) {<br />        if (beforeGivenYearsToPresent(car.getDateManufactued(), warnIfOlderThanYears))<br />            jmsTemplate.send(car);<br />    }<br /><br />    private static boolean beforeGivenYearsToPresent(Calendar date, int years) {<br />        Calendar beforeDate = Calendar.getInstance();<br />        beforeDate.add(Calendar.YEAR, -years);<br />        return date.before(beforeDate);<br />    }<br />}</pre><br /><br />Pretty straightforward. Developer showed this class to his/her boss and asked how to plug this handler to existing ones, having no idea about this whole auto-discovery, database-backed, web controlled process. The boss just smiled, built the application with a single new a class and run it. No existing classes were changed, not even a single XML line not mentioning the database. But the new handler has been picked up after application restart, ready to be configured and serve:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxV1hOFq-CI/AAAAAAAAAQg/r8C6C98CH1c/s1600/wicket3.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 188px; height: 200px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxV1hOFq-CI/AAAAAAAAAQg/r8C6C98CH1c/s200/wicket3.png" alt="" id="BLOGGER_PHOTO_ID_5410359740933535778" border="0" /></a><br />The boss put the new handler between transactionalHandler and <span style="font-family:courier new;">storeCarHandler </span>and enabled it. Few days later he changed his mind, moving <span style="font-family:courier new;">dateManufacturedValidatorHandler</span> before <span style="font-family:courier new;">transactionalHandler</span>, as it does not have to participate in a transaction (just one click in user interface). Unfortunately, after going on production administrators discovered JMS connection leak. Sending JMS messages must have been temporarily disabled. Guess how? Are you still not convinced? You must admit the concept is tempting...