---
layout: post
title: Skrypty Groovy na żądanie w Springu
date: '2009-05-22T22:12:00.010+02:00'
author: Tomasz Nurkiewicz
tags:
- bezpieczeństwo
- struts2
- groovy
- aop
- jpa
- spring
modified_time: '2009-05-22T22:38:26.780+02:00'
thumbnail: http://1.bp.blogspot.com/_P3ewsGQzHn0/ShcH35lgUFI/AAAAAAAAANM/v47ArUoFE6k/s72-c/groovy.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4632032431243975623
blogger_orig_url: https://www.nurkiewicz.com/2009/05/skrypty-groovy-na-zadanie-w-springu.html
---

W poprzednich <a href="http://nurkiewicz.com/2009/05/logika-biznesowa-w-groovy-ze-springiem.html">artykułach</a> udało nam się nakłonić Springa do załadowania skryptu w Groovim z bazy danych i uruchomienia go. Jednak to nie wszystko - chcielibyśmy również w łatwy sposób móc testować nasze skrypty przed umieszczeniem ich w bazie danych. Konkretnie dążymy do stworzenia webowego ekranu, w którym w przeglądarce będzie można wpisywać treść skryptu, uruchomić go na serwerze i obejrzeć wyniki. Zacznijmy od końca, czyli od uruchomienia:<br /><br /><pre name="code" class="java">public interface AutowiredScriptExecutor {<br /><br />  Object execute(String source) throws ScriptCompilationException, ScriptExecutionException;<br /><br />  &lt;T&gt; T execute(String source, Class&lt;T&gt; returnType) throws ScriptCompilationException, ScriptExecutionException;<br /><br />}</pre>Interfejs dość oczywisty: jako argument podajemy kod źródłowy np. w Groovy a zwracany jest rezultat wykonania skryptu (skrypt musi zapewnić jakiś mechanizm zwracania danych). Przeciążona wersja uchroni nas od rzutowania w dół z <span style="font-family:courier new;">Object</span>, jeśli skrypt zwraca znany, konkretny typ. Przejdźmy do nie do końca trywialnej implementacji:<br /><br /><pre name="code" class="java">public class GroovyScriptExecutor implements AutowiredScriptExecutor, BeanFactoryAware {<br /><br />   private AutowireCapableBeanFactory beanFactory;<br /><br />  @Override<br />  @SuppressWarnings("unchecked")<br />  public &lt;T&gt; T execute(String source, Class&lt;T&gt; returnType) throws ScriptCompilationException, ScriptExecutionException {<br />     Callable&lt;T&gt; scriptedObject;<br />     try {<br />         StaticScriptSource scriptSource = new StaticScriptSource(source);<br />         ScriptFactory scriptFactory = new GroovyScriptFactory(source);<br />         scriptedObject = (Callable&lt;T&gt;) scriptFactory .getScriptedObject(scriptSource, null);<br />     } catch (IOException ioEx) {<br />         throw new ScriptCompilationException("Error loading script", ioEx);<br />     }<br />     beanFactory.autowireBeanProperties(scriptedObject, AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE, false);<br />     scriptedObject = (Callable&lt;T&gt;) beanFactory.initializeBean(scriptedObject, "script/" + scriptedObject.getClass().getName());<br />     try {<br />         return scriptedObject.call();<br />     } catch (Exception e) {<br />         throw new ScriptExecutionException(e);<br />     }<br />  }<br /><br />  @Override<br />  public Object execute(String source) throws ScriptCompilationException, ScriptExecutionException {<br />      return execute(source, Object.class);<br />  }<br /><br />  @Override<br />  public void setBeanFactory(BeanFactory beanFactory) throws BeansException {<br />      this.beanFactory = ((AutowireCapableBeanFactory)beanFactory);<br />  }<br /><br />}</pre><br /><br />Na początek widać, że wstrzykujemy interfejs <span style="font-family:courier new;">BeanFactory</span>, który można bezpiecznie zrzutować do <span style="font-family:courier new;">AutowireCapableBeanFactory</span>. Samo uruchomienie skryptu należy podzielić na dwa etapy. Po pierwsze ładujemy skrypt i kompilujemy go (<span style="font-family:courier new;">scriptFactory.getScriptedObject()</span>), otrzymując w wyniku pełnoprawną klasę Java, a ściślej interfejs. Przyjąłem bowiem, że przekazana klasa w Groovy musi implementować interfejs <span style="font-family:courier new;">java.util.concurrent.Callable&lt;T&gt;</span>; <span style="font-family:courier new;">java.lang.Runnable</span> wydaje się gorszym wyborem, bowiem nie potrafi zwracać wyniku (patrz wyżej) oraz nie deklaruje rzucania żadnych sprawdzanych wyjątków.<br /><br />Drugi etap to "usprignowienie" stworzonej klasy w języku Groovy. Dwa tajemnicze polecenia pozyskanego interfejsu <span style="font-family:courier new;">AutowireCapableBeanFactory </span>odpowiednio: wstrzykują zależności oraz wykonują post procesory (transakcje, adnotacje, security). Daje to niezwykłe możliwości; trzeba jedynie pamiętać, że ponieważ <span style="font-family:courier new;">initializeBean()</span> z dużym prawdopodobieństwem opakuje nasz obiekt nakładając nań aspekty, musimy użyć obiektu zwróconego przez tą metodę, a nie tego oryginalnego. Inaczej metoda się napracuje, a i tak nie nie skorzystamy z jej efektów. Na koniec uruchamiamy skrypt - ponieważ założyliśmy, że implementuje on interfejs <span style="font-family:courier new;">Callable</span>, wystarczy wywołać jego metodę <span style="font-family:courier new;">call()</span>.<br /><br />Mamy usługę, pora na widok. Przypominam, że celem jest webowy formularz w naszej aplikacji, umożliwiający wpisanie dowolnego skryptu i uruchomienie go. Zacznijmy od akcji Struts2:<br /><br /><pre name="code" class="java">public class ScriptTestAction extends ActionSupport {<br /><br />  private static final Logger log = Logger.getLogger(ScriptTestAction.class);<br /><br />  private AutowiredScriptExecutor scriptExecutor;<br /><br />  private String source;<br /><br />  @Override<br />  public String execute() throws Exception {<br />     try {<br />         String result = scriptExecutor.execute(source).toString();<br />         addActionMessage(result);<br />     } catch (Exception e) {<br />         log.warn(e, e);<br />     }<br />     return SUCCESS;<br />  }<br /><br />  public void setScriptExecutor(AutowiredScriptExecutor scriptExecutor) {<br />     this.scriptExecutor = scriptExecutor;<br />  }<br /><br />  public void setSource(String source) {<br />     this.source = source;<br />  }<br /><br />  @RequiredStringValidator(message = "Source is requeired")<br />  public String getSource() {<br />     return source;<br />  }<br /><br />}</pre><br /><br />Nawet nie ma czego tłumaczyć: wstrzykujemy stworzony przed chwilą komponent implementujący <span style="font-family:courier new;">AutowiredScriptExecutor</span> , tworzymy pole <span style="font-family:courier new;">source </span>odpowiadające polu tekstowemu na formularzu i w <span style="font-family:courier new;">execute()</span> uruchamiamy skrypt. Efekty jego działania dodajemy jako komunikat. Skróciłem nieco kod na potrzeby artykułu, ale błędy również powinny w przystępny sposób trafiać do klienta. Na koniec szczypta konfiguracji:<br /><br /><pre name="code" class="xml">&lt;package name="admin" extends="default" namespace="/admin"&gt;<br />  &lt;action name="script/input"&gt;<br />     &lt;result&gt;/WEB-INF/jsp/admin/scriptInput.jsp&lt;/result&gt;<br />  &lt;/action&gt;<br />  &lt;action name="script/exec" class="admin.scriptTestAction"&gt;<br />     &lt;result&gt;/WEB-INF/jsp/admin/scriptInput.jsp&lt;/result&gt;<br />     &lt;result name="input"&gt;/WEB-INF/jsp/admin/scriptInput.jsp&lt;/result&gt;<br />  &lt;/action&gt;<br />&lt;/package&gt;</pre><br /><br />...i jesteśmy gotowi do testów. Poniżej kod w Groovy, jaki wpisałem w formularzu oraz efekt po uruchomieniu. Przyjrzyjcie się uważnie temu skryptowi... tak, wszystko co najlepsze w Springu! Wstrzykujemy usługi za pomocą <span style="font-family:courier new;">@Autowired</span> czy wręcz <span style="font-family:courier new;">EntityManager </span>z adnotacją <span style="font-family:courier new;">PersistenceContext</span>. Mało tego, możemy nawet włączyć deklaratywne transakcje - słowem, całe dobrodziejstwo Springa ma tutaj zastosowanie. Dlatego tyle pisałem o metodzie <span style="font-family:courier new;">initializeBean()</span>, to ona zdziałała te cuda :-). A jakby tego było mało, zobaczcie jak zwięzły jest kod w Groovim. Ile w "oldschoolowej" Javie zajęłoby Wam następujące zadanie: <span style="font-style: italic;">dla każdego numeru PESEL z kolekcji wywołaj metodę <span style="font-family:courier new;">isBlackListed()</span>, a jej wynik dodaj do listy wynikowej</span>? Jeśli kod jest dla Was niezrozumiały, podpowiedź: <span style="font-family:courier new;">isBlackListed()</span> zwraca <span style="font-family:courier new;">boolean</span>, a nasza metoda <span style="font-family:courier new;">call()</span> powinna zwrócić <span style="font-family:courier new;">List&lt;Boolean&gt;</span> (dlaczego?)<br /><br /><pre name="code" class="java">import java.util.concurrent.Callable;<br /><br />import javax.persistence.EntityManager;<br />import javax.persistence.PersistenceContext;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.transaction.annotation.Transactional;<br /><br />import com.blogspot.nurkiewicz.filmportal.customer.CustomerBlackList;<br /><br />public class GroovyScript implements Callable&lt;List&lt;Boolean&gt;&gt; {<br /><br /> @Autowired<br /> CustomerBlackList blackList;<br /><br /> @PersistenceContext<br /> EntityManager em;<br /><br /> @Override<br /> @Transactional<br /> def call() {<br />     def peselNumbers = em.createQuery("SELECT pesel FROM User WHERE pesel IS NOT NULL").resultList<br />     return peselNumbers.collect{blackList.isBlackListed(it)}<br /> }<br /><br />}</pre>Na zrzucie ekranu widać wynik już wykonanego skryptu: dwuelementowa lista wartości logicznych:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_P3ewsGQzHn0/ShcH35lgUFI/AAAAAAAAANM/v47ArUoFE6k/s1600-h/groovy.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 172px;" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/ShcH35lgUFI/AAAAAAAAANM/v47ArUoFE6k/s200/groovy.png" alt="" id="BLOGGER_PHOTO_ID_5338744540203339858" border="0" /></a><br /><br />Na koniec mała perełka. Zapewne zauważyliście, że taki ekran w aplikacji to nie tyle wygodne miejsce do debugowania skryptów. W rzeczywistości z jego pomocą można zrobić w aplikacji WSZYSTKO - odwołać się do każdego komponentu, wstrzyknąć sobie <span style="font-family:courier new;">EntityManager</span> czy wręcz <span style="font-family:courier new;">DataSource </span>i grzebać w bazie do woli. Słowem - kolosalne ryzyko. Jak zabezpieczyć taki delikatny komponent? Oprócz zabezpieczenia URL proponuję:<br /><br /><pre name="code" class="java">@RolesAllowed("ROLE_ADMIN")<br />public class GroovyScriptExecutor implements AutowiredScriptExecutor, BeanFactoryAware {<br />  //...<br />}</pre><br /><br />Tak, tak - jeśli teraz zaloguję się do aplikacji użytkownikiem nieposiadającym roli <span style="font-family:courier new;">ROLE_ADMIN</span>:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_P3ewsGQzHn0/ShcH7GoR6dI/AAAAAAAAANU/pESvBaNXya8/s1600-h/groovy_security.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 172px;" src="http://3.bp.blogspot.com/_P3ewsGQzHn0/ShcH7GoR6dI/AAAAAAAAANU/pESvBaNXya8/s200/groovy_security.png" alt="" id="BLOGGER_PHOTO_ID_5338744595244247506" border="0" /></a><br /><br />Żeby ta magia zadziałała (nie przypomina Wam to pewnej innej technologii?), wystarczy w springowym deskryptorze dodać (tag z przestrzeni nazw Spring Security):<br /><br /><pre name="code" class="xml">&lt;global-method-security secured-annotations="enabled" jsr250-annotations="enabled" /&gt;</pre><br /><br />JSR 250 definiuje kilkadziesiąt ciekawych adnotacji, zresztą Spring udostępnia własną <span style="font-family:courier new;">@Secured</span> o takiej samej semantyce. Prawda, że Groovy + Spring + Spring Security + Struts2 wybornie się komponują? :-)