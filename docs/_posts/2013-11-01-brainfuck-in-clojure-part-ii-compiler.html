---
layout: post
title: 'brainfuck in Clojure. Part II: compiler'
date: '2013-11-01T17:17:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- brainfuck
- clojure
- functional programming
modified_time: '2013-11-01T17:17:16.819+01:00'
thumbnail: http://1.bp.blogspot.com/-yHfjRO-8azM/UnPThOClbdI/AAAAAAAAA2c/9PJwI7-g5qs/s72-c/oslo-2.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-5674229437406956868
blogger_orig_url: https://www.nurkiewicz.com/2013/11/brainfuck-in-clojure-part-ii-compiler.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-yHfjRO-8azM/UnPThOClbdI/AAAAAAAAA2c/9PJwI7-g5qs/s1600/oslo-2.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="149" src="http://1.bp.blogspot.com/-yHfjRO-8azM/UnPThOClbdI/AAAAAAAAA2c/9PJwI7-g5qs/s200/oslo-2.jpg" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Oslofjord</td></tr></tbody></table>Last time we developed <a href="http://nurkiewicz.com/2013/10/brainfuck-in-clojure-part-i-interpreter.html">brainfuck interpreter in Clojure</a>. This time we will write a compiler. Compilation has two advantages over interpretation: the resulting program tends to be faster and source program is lost/obscured in binary. It turns out that a <a href="http://en.wikipedia.org/wiki/Brainfuck">brainfuck</a> compiler (to any assembly/bytecode) is not really that complex - brainfuck is very low level and similar to typical CPU architectures (chunk of mutable memory, modified one cell at a time). Thus we will go for something slightly different. Instead of producing JVM bytecode (which some <a href="https://github.com/joegallo/brainfuck/blob/master/src/brain/fuck.clj">already did</a>) we shall write a Clojure macro that will generate code equivalent to any brainfuck program. In other words we will produce Clojure source equivalent to brainfuck source - at compile time.<br />This task is actually more challenging because idiomatic Clojure is much different from idiomatic brainfuck (if such thing as "<i>idiomatic brainfuck</i>" ever existed). Let's first think how such a Clojure code could look like and then write generator/translator. In essence every brainfuck program is a sequence of steps, each mutating state (or producing new state based on the current one). For example (please refer to <a href="http://esolangs.org/wiki/Brainfuck#Language_overview">brainfuck language overview</a> if you haven't yet, there are just 8 commands) the translation from "<code>++&gt;-&lt;</code>" in brainfuck to Clojure might look like this:<br /><br /><pre class="brush: java">(let [state {:ptr 0, :cells [0N]}]<br />  (-&gt; state <br />    cell-inc <br />    cell-inc<br />    move-right<br />    cell-dec<br />    move-left)<br /></pre>First we define immutable <code>state</code> (an array of <code>cells</code> with one item and a <code>ptr</code> (index) to the current cell) and then apply a sequence of transformations on top of it. Each transformation yields new state. The <code>-&gt;</code> macro is a syntactic sugar, more readable than:<br /><br /><pre class="brush: java">    (move-left<br />      (cell-dec<br />        (move-right<br />          (cell-inc<br />            (cell-inc state))<br /></pre>OK, so let's define all these transformations:<br /><br /><pre class="brush: java">(let [state {:ptr 0, :cells [0N]}<br />    cell-inc (fn [state] (update-in state [:cells (:ptr state)] inc))<br />    cell-dec (fn [state] (update-in state [:cells (:ptr state)] dec))<br />    move-right (fn [state] (update-in state [:ptr] inc))<br />    move-left  (fn [state] (update-in state [:ptr] dec))]<br />  (-&gt; state <br />    cell-inc <br />    cell-inc<br />    move-right<br />    cell-dec<br />    move-left))<br /></pre><code>move-right</code> is actually more complex because it has to grow <code>cells</code> when needed but it's irrelevant here. With these helper functions it's easy to translate any brainfuck program into Clojure - simply by replacing <code>+</code>, <code>-</code>, <code>&gt;</code> and <code>&lt;</code> operators with corresponding functions. Well, we aren't quite there yet. In order to be <a href="http://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a> brainfuck needs some form of conditional statement. brainfuck has two conditional jump instructions, <code>[</code> and <code>]</code>. For our purposes we can treat each pair of square brackets as a single instruction (conceptually it is a <code>while</code> loop statement). So for example <code>++[&gt;+&lt;-]&gt;</code> has four instructions:<br /><br /><pre class="brush: java">(let [state {:ptr 0, :cells [0N]}]<br />  (-&gt; state <br />    cell-inc <br />    cell-inc<br />    loop-nested  ; [&gt;+&lt;-]<br />    move-right<br />    )<br /></pre><code>loop-nested</code> is a generated function that encapsulates instructions inside square brackets. Such a loop terminates when it encounters <code>0</code> at current cell:<br /><br /><pre class="brush: java">(let<br />    [state {:ptr 0, :cells [0N]}<br />    (letfn [<br />        (loop-nested [state]<br />          (loop [state state]<br />            (if (zero? (nth (:cells state) (:ptr state)))<br />              state<br />              (recur<br />                (-&gt; state<br />                    move-right<br />                    cell-inc<br />                    move-left<br />                    cell-dec)))))]<br />    (-&gt; state <br />        cell-inc <br />        cell-inc<br />        loop-nested<br />        move-right)))<br /></pre>Look carefully! The program starts at the bottom. When it reaches <code>loop-nested</code> function (state transformation) it enters nested loop defined above. The loop first checks current cell - if it's zero, present <code>state</code> is returned. Otherwise a sequence of <code>state</code> transformations defined within nested loop are executed. Once they are all performed <code>recur</code> is called in order to start subsequent iteration. Sooner or later <code>loop-nested</code> exits and <code>move-right</code> (last line above) will execute.<br /><br />Of course we can nest loops just like in any other programming language, for example: <code>&gt;+&gt;+++[-&lt;[-&lt;+++++&gt;]&lt;++[-&gt;+&lt;]&gt;&gt;]&lt;</code> is probably the shortest known brainfuck program that generates... 187 constant. You can see outer loop enclosing two nested loops. The equivalent Clojure code we would like to generate looks like that:<br /><br /><pre class="brush: java">(let<br />  [state {:ptr 0, :cells [0N]}]<br />      (letfn [<br />        (loop1279 [state]   ; [-&lt;[-&lt;+++++&gt;]&lt;++[-&gt;+&lt;]&gt;&gt;]<br />          (loop [state state]<br />            (if (zero? (nth (:cells state) (:ptr state)))<br />              state<br />              (recur<br />                (letfn [<br />                    (loop1280 [state]   ; [-&lt;+++++&gt;]<br />                      (loop [state state]<br />                        (if (zero? (nth (:cells state) (:ptr state)))<br />                          state<br />                          (recur<br />                            (-&gt; state   ; -&lt;+++++&gt;<br />                              cell-dec move-left cell-inc cell-inc cell-inc cell-inc cell-inc move-right)))))<br />                    (loop1281 [state]   ; [-&gt;+&lt;]<br />                      (loop [state state]<br />                        (if (zero? (nth (:cells state) (:ptr state)))<br />                          state<br />                          (recur<br />                            (-&gt; state   ; -&gt;+&lt;<br />                              cell-dec move-right cell-inc move-left)))))]<br />                  (-&gt; state   ; -&lt;[...]&lt;++[...]&gt;&gt;<br />                    cell-dec move-left loop1280 move-left cell-inc cell-inc loop1281 move-right move-right))))))]<br />    (-&gt; state   ;  &gt;+&gt;+++[...]&lt;<br />      move-right cell-inc move-right cell-inc cell-inc cell-inc loop1279 move-left))) <br /></pre>I left comments to guide you which parts correspond to which pieces of brainfuck. Start reading from the very bottom. I guess now we can fully appreciate the conciseness of brainfuck. OK, just joking.<br /><br /><hr />Right, so we see how brainfuck can be translated into Clojure. Let's implement such a translator (which I called a <i>compiler</i> in the title since it sounds better). It might seem complex, especially after seeing code sample above, but the whole translator <a href="https://github.com/nurkiewicz/brainfuck.clj/blob/master/src/com/blogspot/nurkiewicz/brainfuck/compiler.clj">fits on one screen</a>!<br /><br />The implementation consists of two main parts - generating code for a block of brainfuck source and injecting function for nested loop. The first part, simplified for clarity:<br /><br /><pre class="brush: java">(defn- translate-block [brainfuck-source]<br />  (apply list<br />    (loop [code [`letfn [] `[-&gt; ~'state]], program brainfuck-source]<br />      (condp = (first program)<br />        \&gt; (recur (append-cmd code `~'move-right) (rest program))<br />        \&lt; (recur (append-cmd code `~'move-left) (rest program))<br />        \+ (recur (append-cmd code `~'cell-inc) (rest program))<br />        \- (recur (append-cmd code `~'cell-dec) (rest program))<br />        \[ (let [loop-name (gensym "loop")]<br />              (recur <br />                (insert-loop-fun loop-name program code)<br />                source-after-loop))<br />        nil code<br />        (recur code (rest program))))))<br /></pre>Observe how we iterate over characters of brainfuck source and append appropriate commands to Clojure <code>code</code> being incrementally built (initially set to <code>(letfn [] ())</code>). Opening square bracket (<code>[</code>) appends auto-generated loop in <code>insert-loop-fun</code> function:<br /><br /><pre class="brush: java">(defn- insert-loop-fun [loop-name brainfuck-source code]<br />  (let [loop-body "..." <br />    loop-body-code (translate-block loop-body)<br />    loop-code <br />      `(loop [~'state ~'state]<br />        (if (zero? (nth (:cells ~'state) (:ptr ~'state)))<br />          ~'state<br />          (recur ~loop-body-code)))]<br />    `(~loop-name [~'state] ~loop-code)))<br /></pre>Code above is also simplified for readability. Two important steps are performed: generating code for loop body using recursive call to <code>translate-block</code> and wrapping final Clojure code with a loop template. Whole, working source code is <a href="https://github.com/nurkiewicz/brainfuck.clj/blob/master/src/com/blogspot/nurkiewicz/brainfuck/compiler.clj">available on GitHub</a>. Let's take this macro for a test drive. Notice that we no longer need to escape brainfuck code as a string, we can place it <i>directly</i> in Clojure!<br /><br /><pre class="brush: java">(is (= <br />  (brainfuck +&gt;-&lt;+) <br />  {:ptr 0 :cells [2 -1]}))<br /><br />(is (= <br />  (brainfuck &gt;&gt;+&gt;&gt;-) <br />  {:ptr 4 :cells [0 0 1 0 -1]}))<br /><br />(is (= <br />  (brainfuck <br />      &gt;+&gt;+++[<br />        -&lt;[<br />          -&lt;+++++&gt;<br />        ]<br />        &lt;++[<br />          -&gt;+&lt;<br />        ]<br />      &gt;&gt;<br />      ]<br />    &lt;<br />  ) <br />  {:ptr 1 :cells [0 187 0]}))<br /></pre>As you can see invoking <code>brainfuck</code> macro yields final state of the program. I/O is not implemented but easy to add. <br /><br />To recap: we managed to build a Clojure program in less than 60 lines of code that translates any brainfuck source into valid Clojure source. Later Clojure compiler turns this into JVM bytecode. Source code for both <a href="https://github.com/nurkiewicz/brainfuck.clj/blob/master/src/com/blogspot/nurkiewicz/brainfuck/interpreter.clj">interpreter</a> and <a href="https://github.com/nurkiewicz/brainfuck.clj/blob/master/src/com/blogspot/nurkiewicz/brainfuck/compiler.clj">compiler</a> (plus <a href="https://github.com/nurkiewicz/brainfuck.clj/tree/master/test/com/blogspot/nurkiewicz/brainfuck">test cases</a>) is <a href="https://github.com/nurkiewicz/brainfuck.clj">available on GitHub</a>. <br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>