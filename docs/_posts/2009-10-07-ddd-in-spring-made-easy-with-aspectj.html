---
layout: post
title: DDD in Spring made easy with AspectJ
date: '2009-10-07T00:03:00.003+02:00'
author: Tomasz Nurkiewicz
tags:
- aop
- spring
- ddd
- aspectj
- maven
modified_time: '2013-04-07T13:23:57.668+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3593673006013287599
blogger_orig_url: https://www.nurkiewicz.com/2009/10/ddd-in-spring-made-easy-with-aspectj.html
---

<blockquote><p>UPDATE: Over the years I learnt that the solution provided below is not really an example of domain-driven design. It's more like an <a href="http://en.wikipedia.org/wiki/Active_record"><em>active record</em></a> implementation on top of Spring. But the technical part of the article is still relevant, so I keep it intact.</p></blockquote> Before I start the main topic, I would like you to think for a while about the best JEE application design you can imagine. No matter you use Spring or EJB3, as they are very similar, probably you would suggest similar approach. Starting from the back you have:<br /><br /><ul><li> <span style="font-weight: bold;">domain objects</span>, which are simple POJOs mapped directly to database relations. POJOs are great because JavaBean-style properties are well understood be many frameworks.</li><li><span style="font-weight: bold;"> data access layer</span> – typically stateless services, which wrap up database access code (JDBC, Hibernate, JPA, iBatis or whatever you want) hiding its complexity and providing some level of (leaky) abstraction. DAOs are great because they hide nasty and awkward JDBC logic (that is why some question the need for DAOs when using JPA, but this is out of scope of this post), serving as a, more-or-less, translator between database and objects.</li><li><span style="font-weight: bold;">business services layer</span> – another set of stateless services, which operate on domain objects. Typical design introduces a graph of objects that take or return domain objects and perform some logic on them, again, typically accessing database via data access layer. Service layer is great because it focuses on business logic, delegating technical details to DAO layer.</li><li><span style="font-weight: bold;">user interface</span> – nowadays, typically via web browser. User interface is great because... just the fact it is.<br /></li></ul>Beautiful, isn’t it? Now open your eyes, it is time for a cold shower.<br /><br />Both services and DAOs are stateless, because Spring and EJB3 favors such classes - so we learnt to live with it. On the other hand, POJOs are "<span style="font-style: italic;">logicless</span>" – they only contain data, maintain their state without operating on it and introducing no logic. If we think about introducing "reservation" domain object to our application, we immediately think of Reservation POJOs mapped to <span style="font-family:courier new;">RESERVATIONS</span> database table, <span style="font-family:courier new;">ReservationDao</span>, <span style="font-family:courier new;">ReservationService</span>, <span style="font-family:courier new;">ReservationController</span>, etc.<br /><br />Still don’t see the problem, Java, thus OOP programmer? How would you describe "object"? It is some virtual being having internal (encapsulation) state and some public operations, which have explicit access to the state. Most fundamental concept of object-based programming is to take data and procedures operating on that data together and close them tightly. Now take a look at your best design ever, do you really need objects? This is the dark secret of Spring, EJB3, Hibernate and other well established frameworks. The secret, which all of us subconsciously try to forget: we are not OOP programmers anymore!<br /><br />POJOs are not objects, they are simply data structures, collections of data. Getters and setters are not true methods, actually, when was the last time you wrote them by hand?  In fact, the need to autogenerate them (and refactor, add and remove when attributes change) sometimes happen to be very frustrating. Wouldn’t it be simpler just to use structures with public fields by default?<br /><br />On the other hand, look at all those great stateless services. They do not have any state. Although they operate on domain objects, they are not part of them or not even aggregate them (low cohesion). All the data is passed explicitly through the method parameters. They aren’t objects as well – they are simply collection of procedures arbitrary gathered together on a common namespace, corresponding to class name. In contracts, methods in OOP are also procedures behind the scenes, but having implicit access to <span style="font-style: italic;font-family:courier new;" >this </span>reference, which points to the object instance. Whenever we call <span style="font-family:courier new;">ReservationService </span>or <span style="font-family:courier new;">ReservationDao </span>providing <span style="font-family:courier new;">Reservation </span>POJO reference explicitly as one of the arguments, we actually reinvent OOP and code it manually.<br /><br />Let’s face it, we are not OOP programmers, as everything we need are structures and procedures, invented fifty years ago... How many Java programmers are using inheritance and polymorphism in a day-to-day basis? When was the last time you wrote object having private state without getters/setters with only few method having access to it? When was the last time you created object with non-default constructor?<br /><br />Luckily, what Spring have taken, it brings back with even more power. The power is called AspcetJ.<br /><br />In my <a href="http://nurkiewicz.com/2009/09/state-pattern-introducing-domain-driven.html">last post</a> I created <span style="font-family:courier new;">Reservation </span>entity having three business methods:<span style="font-family:courier new;"> accept()</span>, <span style="font-family:courier new;">charge()</span> and <span style="font-family:courier new;">cancel()</span>. It looks really good to have business methods concerning domain object placed directly in that object. Instead of calling <span style="font-family:courier new;">reservationService.accept(reservation)</span>, we simply run <span style="font-family:courier new;">reservation.accept()</span>, which is much more intuitive and less noisy. Even better, what about writing:<br /><br /><pre name="code" class="java">Reservation res = new Reservation()<br />//...<br />res.persist()</pre><br /><br />instead of calling DAO or <span style="font-family:courier new;">EntityManager </span>directly? I don’t know much about domain-driven design, but I found this fundamental refactoring to be the first gate you must walk through to enter the DDD world (and go back to OOP as well).<br /><br />So, if having business methods directly on domain objects is so great, why not everybody’s doing it? The answer is very straightforward and down-to-earth – because they don’t know how! Reservations’<span style="font-family:courier new;"> accept()</span> method will eventually need to delegate some logic to external services, like accounting or sending e-mails. Naturally, this logic is not part of <span style="font-family:courier new;">Reservation</span> domain object and should be implemented elsewhere (high cohesion). But most Spring programmers don’t know how or are scared of injecting other services to domain objects. When all services are managed by Spring, everything is simple. But when Hibernate creates domain objects itself or the object is created using <span style="font-family:courier new;">new </span>operator, Spring has no knowledge of this instance and cannot handle dependency injection. So how would Reservation POJO obtain Spring beans or <span style="font-family:courier new;">EntityManager </span>encapsulating necessary logic?<br /><br />...<br /><br />First, add <a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Configurable.html"><span style="font-family:courier new;">@Configurable</span></a> annotation to your domain object:<br /><br /><pre name="code" class="java">@Configurable<br />@Entity<br />public class Reservation implements Serializable {<br />  //...<br />}</pre><br /><br />This tells Spring that Reservation POJO should be managed by Spring. But, as mentioned above, Spring has no knowledge of Reservation instances being created, so it has no occasion to autowire and inject dependencies. This is where AspectJ comes in. All you need to do is to add:<br /><br /><pre name="code" class="xml">&lt;context:load-time-weaver/&gt;</pre><br /><br />To your Spring XML descriptor. This extremely short XML snippet tells Spring that it should use AspectJ load-time weaving (LTW).  Now, when you run you application:<br /><br /><span style="font-family:courier new;">java.lang.IllegalStateException: ClassLoader [org.apache.catalina.loader.WebappClassLoader] does NOT provide an 'addTransformer(ClassFileTransformer)' method. Specify a custom LoadTimeWeaver or start your Java virtual machine with Spring's agent: -javaagent:spring-agent.jar</span><br /><span style="font-family:courier new;">    at org.springframework.context.weaving.DefaultContextLoadTimeWeaver.setBeanClassLoader(DefaultContextLoadTimeWeaver.java:82)</span><br /><span style="font-family:courier new;">    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1322)</span><br /><span style="font-family:courier new;">    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:473)</span><br /><span style="font-family:courier new;">    ... 59 more</span><br /><br />It will fail... Java is not magic, so before we proceed, few words of explanation – don’t be impatient. Adding XML snippet above does not solve anything. It simply tells Spring that we are using AspectJ LTW. But when application starts up, it does not find AspectJ and tells us about it decently. What happens if we add -javaagent:spring-agent.jar to our JVM command line parameters as suggested? This Java agent is simply a plugin to JVM that overrides loading of every class. When <span style="font-family:courier new;">Reservation </span>class is loaded for the first time, agent discovers <span style="font-family:courier new;">@Configurable</span> annotation and applies some special AspectJ aspect to this class.<br /><br />To be more precise: bytecode of <span style="font-family:courier new;">Reservation </span>class is being modified, overriding all constructors and deserialization routines. Thanks to this modification, whenever new <span style="font-family:courier new;">Reservation </span>class is being instantiated, apart from normal initialization, those additional routines added by the Spring-provided aspect perform dependency injection. So since now enhanced <span style="font-family:courier new;">Reservation </span>class is Spring-aware. It does not matter whether reservation has been created by Hibernate, Struts2 or using new operator. Hidden aspect code always takes care of calling Spring <span style="font-family:courier new;">ApplicationContext </span>and ask it to inject all dependencies to domain object. Let us take it for a test drive:<br /><br /><pre name="code" class="java">@Configurable<br />@Entity<br />public class Reservation implements Serializable {<br /><br />  @PersistenceContext<br />  private transient EntityManager em;<br /><br />  @Transactional<br />  public void persist() {<br />      em.persist(this);<br />  }<br />//...<br />}</pre><br /><br />This is not a mistake – I injected <span style="font-family:courier new;">EntityManger </span>from JPA specification directly to domain object. I also put <span style="font-family:courier new;">@Transactional</span> annotation over <span style="font-family:courier new;">persist()</span> method. This is not possible in ordinary Spring, but since we used <span style="font-family:courier new;">@Configurable</span> annotation and AspectJ LTW, code below is completely valid and works as expected, issuing SQL and committing transaction against the database:<br /><br /><pre name="code" class="java">Reservation res = new Reservation()<br />//...<br />res.persist()</pre><br /><br />Of course, you can also inject regular dependencies (other Spring beans) to your domain objects. You have choice of using autowiring (<a href="http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/Autowired.html"><span style="font-family:courier new;">@Autowire</span></a> or even better <a href="http://java.sun.com/javaee/5/docs/api/javax/annotation/Resource.html"><span style="font-family:courier new;">@Resource</span></a> annotations) or setting properties manually. The latter approach gives you more control, but forces you to add setter for Spring bean in domain object and define another bean corresponding to domain object:<br /><br /><pre name="code" class="xml">&lt;bean class=" com.blogspot.nurkiewicz.reservations.Reservation "&gt;<br />  &lt;!-- ... --&gt;<br />&lt;/bean&gt;</pre><br /><br />Please note that I haven’t provided name/id for this bean. If I would, the same name should be passed to <span style="font-family:courier new;">@Configurable</span> annotation.<br /><br />Everything works like a charms, but how to use this amazing feature in your real life work? First of all, you must setup your unit tests to use Java agent. In IntelliJ IDEA I simply added:<br /><br /><span style="font-family:courier new;">-javaagent:D:/my/maven/repository/org/springframework/spring-agent/2.5.6/spring-agent-2.5.6.jar</span><br /><br />to <span style="font-style: italic;">VM parameters</span> text field in JUnit run configuration. If you add this to default ("<span style="font-style: italic;">Edit defaults</span>" button), this parameter will be applied to every new unit test you run. But configuring IDE is not as much important as configuring your build tool (hopefully maven). First of all you must ensure that Spring Java agent is downloaded and available. Thanks to maven dependency resolution, this can be easily achieved by adding dependency:<br /><br /><pre name="code" class="xml">&lt;dependency&gt;<br />      &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />      &lt;artifactId&gt;spring-agent&lt;/artifactId&gt;<br />      &lt;version&gt;2.5.6&lt;/version&gt;<br />      &lt;scope&gt;test&lt;/scope&gt;<br />&lt;/dependency&gt;</pre><br /><br />The JAR is not actually needed by test code, but by adding this dependency we guarantee that it is downloaded before tests run. Then, simple tweak in surefire plugin configuration:<br /><br /><pre name="code" class="xml">&lt;plugin&gt;<br />  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br />  &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;<br />  &lt;configuration&gt;<br />      &lt;forkMode&gt;always&lt;/forkMode&gt;<br />      &lt;argLine&gt;<br />          -javaagent:${settings.localRepository}/org/springframework/spring-agent/2.5.6/spring-agent-2.5.6.jar<br />      &lt;/argLine&gt;<br />  &lt;/configuration&gt;<br />&lt;/plugin&gt;</pre><br /><br />Really simple – location of <span style="font-family:courier new;">spring-agent.jar</span> can be safely constructed using maven repository path. Also <span style="font-family:courier new;">forkMode </span>must be set in order to reload classes (and cause LTW to happen) each test is executed. I think configuring your app server and/or startup scripts does not need any further explanation.<br /><br />That is all about Spring and AspectJ integration via load-time weaving. Few simple configuration steps and a whole new world of domain-driven design welcomes. Our domain model is no longer weak, entities are "smart" and business code is more intuitive. And last but not least – your code would be back object-oriented, not procedural.<br /><br />Of course, you might not like load-time weaving, as it interferes with JVM class loading. There is another approach, called <span style="font-style: italic;">compile-time weaving</span>, which weaves aspects on compile time rather than class loading time. Both methods have pros and cons, I will try to compare both of them in the future.