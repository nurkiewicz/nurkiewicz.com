---
layout: post
title: 'Clean code, clean logs: tune your pattern (6/10)'
date: '2010-05-15T15:53:00.005+02:00'
author: Tomasz Nurkiewicz
tags:
- logging
- logback
- slf4j
modified_time: '2010-05-20T18:39:40.208+02:00'
thumbnail: http://1.bp.blogspot.com/_P3ewsGQzHn0/S-6oCHu8FZI/AAAAAAAAAUs/CjXX0FCGMwY/s72-c/class_info.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-7257385972050391509
blogger_orig_url: https://www.nurkiewicz.com/2010/05/clean-code-clean-logs-tune-your-pattern.html
---

Logging pattern is a wonderful tool, that transparently adds meaningful context to every logging statement you make. But you must consider very carefully which information to include in your pattern. For example, logging date when your logs roll every hour is pointless as the date is already included in the log file name. On the contrary, without logging thread name you would be unable to track any process using logs when two threads work concurrently – the logs will overlap. This might be fine in single-threaded applications – that are almost dead nowadays.<br /><br />From my experience, ideal logging pattern should include (of course except the logged message itself): current time (without date, milliseconds precision), logging level (if you <a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-logging-levels.html">pay attention to it</a>), name of the thread, simple logger name (not fully qualified) and the message. In <a href="http://logback.qos.ch/">Logback</a> it is something like:<br /><br /><pre class="brush: xml">&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;<br />    &lt;encoder&gt;<br />        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level [%thread][%logger{0}] %m%n&lt;/pattern&gt;<br />    &lt;/encoder&gt;<br />&lt;/appender&gt;</pre><br /><br /><br />You should <span style="font-weight: bold;">never</span> include file name, class name and line number, although it’s very tempting. I have even seen empty log statements issued from the code:<br /><br /><pre class="brush: java">log.info("");</pre><br /><br />because the programmer assumed that the line number will be a part of the logging pattern and he knew that "If empty logging message appears in 67th line of the file (in <span style="font-family:courier new;">authenticate()</span> method), it means that the user is authenticated". Besides, logging class name, method name and/or line number has a serious performance impact. I have prepared some simple benchmark with the following configuration:<br /><br /><pre class="brush: xml">&lt;appender name="CLASS_INFO" class="ch.qos.logback.core.OutputStreamAppender"&gt;<br />    &lt;encoder&gt;<br />        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level [%thread][%class{0}.%method\(\):%line][%logger{0}] %m%n&lt;/pattern&gt;<br />    &lt;/encoder&gt;<br />    &lt;outputStream class="org.apache.commons.io.output.NullOutputStream"/&gt;<br />&lt;/appender&gt;<br />&lt;appender name="NO_CLASS_INFO" class="ch.qos.logback.core.OutputStreamAppender"&gt;<br />    &lt;encoder&gt;<br />        &lt;pattern&gt;%d{HH:mm:ss.SSS} %-5level [%thread][LoggerTest.testClassInfo\(\):30][%logger{0}] %m%n&lt;/pattern&gt;<br />    &lt;/encoder&gt;<br />    &lt;outputStream class="org.apache.commons.io.output.NullOutputStream"/&gt;<br />&lt;/appender&gt;</pre><br /><br /><a href="http://commons.apache.org/io/apidocs/org/apache/commons/io/output/NullOutputStream.html">NullOutputStream</a> is used to eliminate I/O overhead during the test. The following micro benchmark issues 1,5 million logging statements to <span style="font-family:courier new;">CLASS_INFO</span> and 30 million statements to <span style="font-family:courier new;">NO_CLASS_INFO</span> logger. The latter one places some static text instead of dynamically generated class information. First 1/3 of iterations were discarded to allow JVM warm-up.<br /><br /><pre class="brush: java">import org.junit.Test;<br />import org.perf4j.StopWatch;<br />import org.perf4j.slf4j.Slf4JStopWatch;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br /><br />public class LoggerTest {<br /><br />    private static final Logger log = LoggerFactory.getLogger(LoggerTest.class);<br />    private static final Logger classInfoLog = LoggerFactory.getLogger("CLASS_INFO");<br />    private static final Logger noClassInfoLog = LoggerFactory.getLogger("NO_CLASS_INFO");<br /><br />    private static final int REPETITIONS = 15;<br />    private static final int COUNT = 100000;<br /><br />    @Test<br />    public void testClassInfo() throws Exception {<br />        for (int test = 0; test &lt; REPETITIONS; ++test)<br />            testClassInfo(COUNT);<br />    }<br /><br />    private void testClassInfo(final int count) {<br />        StopWatch watch = new Slf4JStopWatch("Class info");<br />        for (int i = 0; i &lt; count; ++i)<br />            classInfoLog.info("Example message");<br />        printResults(count, watch);<br />    }<br /><br />    @Test<br />    public void testNoClassInfo() throws Exception {<br />        for (int test = 0; test &lt; REPETITIONS; ++test)<br />            testNoClassInfo(COUNT * 20);<br />    }<br /><br />    private void testNoClassInfo(final int count) {<br />        StopWatch watch = new Slf4JStopWatch("No class info");<br />        for (int i = 0; i &lt; count; ++i)<br />            noClassInfoLog.info("Example message");<br />        printResults(count, watch);<br />    }<br /><br />    private void printResults(int count, StopWatch watch) {<br />        log.info("Test {} took {}ms (avg. {} ns/log)", new Object[]{<br />                watch.getTag(),<br />                watch.getElapsedTime(),<br />                watch.getElapsedTime() * 1000 * 1000 / count});<br />    }<br /><br />}</pre><br /><br />As it turned out, on my computer the logger that produces class information reflectively worked 13 times slower (115 vs. 8.8 microseconds per logging statement, see chart below). Being a Java developer suggests that 100 microseconds is acceptable, but this also means more than 1% of the server time is wasted when logging , let’s say, 100 statements per second. Is it worth it?<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_P3ewsGQzHn0/S-6oCHu8FZI/AAAAAAAAAUs/CjXX0FCGMwY/s1600/class_info.png"><img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 128px; height: 200px;" src="http://1.bp.blogspot.com/_P3ewsGQzHn0/S-6oCHu8FZI/AAAAAAAAAUs/CjXX0FCGMwY/s200/class_info.png" alt="" id="BLOGGER_PHOTO_ID_5471495351690859922" border="0" /></a><br /><br />Somewhat more advanced feature of logging frameworks is Mapped Diagnostic Context. <a href="http://www.slf4j.org/api/org/slf4j/MDC.html">MDC</a> is simply a map managed on a thread-local basis. You can put any key-value pair in this map and since then every logging statement issued from this thread is going to have this value attached as part of the pattern. I need some more complex, multi threaded example to show you the benefits of this utility, so please be so kind and wait for my next articles.<br /><br /><br /><ul><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-use-appropriate.html">Clean code, clean logs: use appropriate tools (1/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-logging-levels.html">Clean code, clean logs: logging levels are there for you (2/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-do-you-know-what.html">Clean code, clean logs: do you know what you are logging? (3/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-avoid-side.html">Clean code, clean logs: avoid side effects (4/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-concise-and.html">Clean code, clean logs: concise and descriptive (5/10)</a></li><br /><li>Clean code, clean logs: tune your pattern (6/10)</li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-log-method.html">Clean code, clean logs: log method arguments and return values (7/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-watch-out-for.html">Clean code, clean logs: watch out for external systems (8/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-log-exceptions.html">Clean code, clean logs: log exceptions properly (9/10)</a></li><br /><li><a href="http://nurkiewicz.blogspot.com/2010/05/clean-code-clean-logs-easy-to-read-easy.html">Clean code, clean logs: easy to read, easy to parse (10/10)</a></li><br /></ul>