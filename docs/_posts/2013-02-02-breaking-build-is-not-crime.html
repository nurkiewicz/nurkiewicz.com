---
layout: post
title: Breaking build is not a crime
date: '2013-02-02T22:38:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- git
- bamboo
- continuous integration
modified_time: '2013-02-02T22:38:27.339+01:00'
thumbnail: http://4.bp.blogspot.com/-xieZCMhcciw/UQ2EaPuGdGI/AAAAAAAAAsE/G1WdKwhpI7c/s72-c/12.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-1818002603818858899
blogger_orig_url: https://www.nurkiewicz.com/2013/02/breaking-build-is-not-crime.html
---

For years I've been taught that breaking continuous integration build is something that should be avoided under all circumstances. Let me first quote few classics. <i>Uncle Bob</i> in  <a href="http://www.amazon.com/gp/product/0137081073/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0137081073&amp;linkCode=as2&amp;tag=javaandneighb-20"><i>The Clean Coder</i></a> says:<br />
<br />
<blockquote>The team must simply keep the build working at all times. If the build fails, it should be a “stop the presses” event and the team should meet to quickly resolve the issue.</blockquote>and later in that section:<br />
<br />
<blockquote>I have every developer run the continuous-build script before they commit.</blockquote>Final quote:<br />
<br />
<blockquote>They <i>(CI tests)</i> should never fail. If they fail, then the whole team should stop what they are doing and focus on getting the broken tests to pass again. A broken build [...] should be viewed as an emergency[...]</blockquote>In another wonderful book <a href="http://www.amazon.com/gp/product/0321601912/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321601912&amp;linkCode=as2&amp;tag=javaandneighb-20"><i>Continuous Delivery</i></a> by <i>Jez Humble</i> and <i>David Farley</i> the authors go way further. They present 7-point plan that we should follow on every commit (!):<br />
<br />
<blockquote><code>3.</code> Run the build script and tests on your development machine to make sure that everything still works correctly on your computer<br />
    <br />
    [...]<br />
    <br />
    <code>5.</code> Wait for your CI tool to run the build with your changes.<br />
    <br />
    [...]<br />
    <br />
    <code>7.</code> If the build passes, rejoice and move on to your next task.<br />
    <br />
    [...]<br />
    <br />
    If the commit succeeds, the developers are then, and only then, free to move on to their next task.</blockquote>They suggest the following best practices:<br />
<br />
<blockquote><h4>Never Go Home on a Broken Build</h4>[...] When the build breaks on check-in, try to fix it for ten minutes.</blockquote>To summarize what literature says about continuous integration:<br />
<br />
<ul><li>always run all the tests before committing to make sure everything is green<br />
    <br />
 </li><li>look closely at your CI builds to make sure they pass, don't proceed with further tasks<br />
    <br />
 </li><li>if you break the build, you must treat this as an emergency and fix it ASAP<br />
    <br />
 </li><li>you have very little time to fix, otherwise revert your changes<br />
    <br />
 </li></ul>It's not uncommon to have some hardware alarms triggering when build goes red. I heard of teams where build-breaking developer had to wear some silly hat or donate a dollar for charity (nothing wrong with that alone). Breaking build is considered a sin, assassination on team's productivity, carelessness and laziness. CI server becomes this dreadful, scary machine that developers are afraid of. Bamboo even gives each developer points based on the total number of broken vs. fixed builds.<br />
<br />
I fully understand this point of view and behaviour, but this doesn't mean I agree. I feel this workflow is just plain <i>wrong</i>. I am aware that the whole team is working on the same HEAD/trunk in version control so breaking it is possibly a show-stopper for all of them. But I'm against treating CI/source control as some scarce resource that is so mission-critical.<br />
<br />
Continuous integration server and VCS should be your personal team-mate, doing work for me. No one is really paying me for staring for, say, 5 minutes at my IDE before each commit to make sure all tests still pass. If that's the case, I'm suppose to watch CI build blindly for next 5 minutes. If I broke the build, they expect me to drop everything and just jump in, trying to fix build within 10 minutes, as <i>Continuous Delivery</i> suggests. All this in emergency, stressful manner. Why?<br />
<br />
Back in the days of Java 1.4 we were taught that concurrent programming using <code>wait()</code> and <code>notify()</code> is hard. But instead of giving up concurrency we came up with better and easier to use abstractions and libraries. At the same time we were reluctant to rename classes as this also renamed <code>.java</code> files, operation not well supported in CVS. But instead of keeping old names forever we migrated to superior SVN. Now because of technical limitations of continuous integration servers and VCS we should treat CI server as a very expensive über-assertion that should never fail. Technology deficiencies seem to affect our productivity and workflow.<br />
<br />
<b>I want to break the build whenever I want!</b> When I'm done and my new tests pass, I just want to commit/push my new stuff and let CI server perform full testing. I hope everything flies but if not, I don't want to feel guilty. I don't want to stay late or apologize my team-mates. I will fix these unexpected problems when I can. It's not production, it's just my experimental new feature failure that no one cares.<br />
<br />
This naturally leads to an idea of <a href="http://martinfowler.com/bliki/FeatureBranch.html">feature branches</a>. The concept is simple: you develop your feature on a separate branch, CI server might even build all <i>your</i> changes and when you feel you are ready, you simply merge your changes back to mainline. The problem with feature branches is that it's no longer <i>continuous integration</i>. After days of development your feature might be green and ready alone, but merging it back might be extremely problematic. Also other team members might benefit from your changes, even if they are not complete (but already <i>green</i>). All these observations led me to the following requirements:<br />
<br />
<ul><li>I want to push my changes as often as I need<br />
    <br />
 </li><li>CI server should build my changes in isolation so that if they break, no one sees them or cares<br />
    <br />
 </li><li>if my changes are good, I want them to be automatically and immediately visible to others<br />
    <br />
 </li><li>I also want to see changes made by others as soon as possible<br />
    <br />
 </li></ul>Fortunately modern CI servers (I'm using <a href="http://www.atlassian.com/software/bamboo/overview">Bamboo</a> as a reference) and version control systems (git here, Mercurial should work exactly the same) are capable of supporting the workflow I've dreamed of. The main requirement is that I want to push my changes as fast as possible without running all the tests and breaking <code>master</code>. The first step is to create a separate branch and commit to that branch. <b>We should never commit to <code>master</code></b>. When I think I'm ready with my new feature I simply push that branch and move on. No running tests locally, no nervous monitoring of CI server. Just push and approach new challenges. This may lead to great savings in time if your test suite takes few minutes to run.<br />
<br />
First things first, here is how you set up Bamboo. Under <i>Plan Configuration</i> and <i>Branches</i> select the following highlighted options:<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-xieZCMhcciw/UQ2EaPuGdGI/AAAAAAAAAsE/G1WdKwhpI7c/s1600/12.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://4.bp.blogspot.com/-xieZCMhcciw/UQ2EaPuGdGI/AAAAAAAAAsE/G1WdKwhpI7c/s640/12.png" width="640" /></a></div><br />
<br />
<i>Automatically manage branches</i> will discover and build all new branches automatically. <i>Branch Merging Enabled</i> allows Bamboo to automatically merge new branches with <code>master</code> one way or another. In the <i>Gatekeeper</i> configuration we tick <i>Push on</i> option. Here is how it works: I make several commits to my <code>feature</code> branch. You can push them immediately or after some time:<br />
<br />
<table><tbody><tr><td><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-eLSBOR-tMlc/UQ2EaR2I6YI/AAAAAAAAAsM/6YgxR3KJjEU/s1600/2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="74" src="http://3.bp.blogspot.com/-eLSBOR-tMlc/UQ2EaR2I6YI/AAAAAAAAAsM/6YgxR3KJjEU/s320/2.png" width="320" /></a></div><h1></h1></td><td><pre class="brush: plain">* 894217c (HEAD, feature, origin/feature) More tests<br />
    * 3883a5c Starting to work on a feature<br />
    * 1bd4e34 (origin/master, master) Multiplication test<br />
    * f5c886c Testing addition<br />
    * 3e6ab7c Initial revision<br />
</pre></td></tr></tbody></table>Notice that my <code>feature</code> branch is placed on top of <code>master</code>. <code>master</code> branch is still green and my, possibly breaking, changes are isolated. Here comes the magic. I configured Bamboo to discover new branches and build them automatically:<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-lwAmi_RXvqg/UQ2EaqjtigI/AAAAAAAAAss/7skGEznEU4A/s1600/3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="156" src="http://4.bp.blogspot.com/-lwAmi_RXvqg/UQ2EaqjtigI/AAAAAAAAAss/7skGEznEU4A/s640/3.png" width="640" /></a></div><br />
<br />
What's so special about that? Bamboo tells me that my changes are fine so I am free to integrate them into the mainline (<code>master</code> branch). Am I? No, Bamboo did it already! It built my changes, found them to be <i>green</i> and automatically merged them into `master so that others can see them. Merging was simple, it's just fast-forward:<br />
<a name='more'></a><br />
<br />
<table><tbody><tr><td><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-mugW8MMby-M/UQ2Ea0nMX2I/AAAAAAAAAsU/wzPb7n1eljk/s1600/4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="48" src="http://4.bp.blogspot.com/-mugW8MMby-M/UQ2Ea0nMX2I/AAAAAAAAAsU/wzPb7n1eljk/s320/4.png" width="320" /></a></div><h1></h1></td><td><pre class="brush: plain">* 894217c (HEAD, origin/master, origin/feature, master, feature) More tests<br />
    * 3883a5c Starting to work on a feature<br />
    * 1bd4e34 Multiplication test<br />
    * f5c886c Testing addition<br />
    * 3e6ab7c Initial revision<br />
</pre></td></tr></tbody></table><br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-nxbtzX4h1R8/UQ2EawlNAYI/AAAAAAAAAsY/de8-ntEO2Rw/s1600/5.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="114" src="http://2.bp.blogspot.com/-nxbtzX4h1R8/UQ2EawlNAYI/AAAAAAAAAsY/de8-ntEO2Rw/s640/5.png" width="640" /></a></div><br />
<br />
<br />
<br />
OK, was it really that interesting? After all we would get the same result by simply pushing directly to <code>master</code>... Well, but what happens if we are pushing <i>breaking</i> changes to unmodified mainline? This is the terrifying moment in most of the teams. I just pushed breaking changes and everyone is yelling at me. <i>Fix. Fast. Y U NO RUN TEST?</i> But not in this approach:<br />
<br />
<br />
<table><tbody><tr><td><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-GmPF-oC4t4E/UQ2EbEfjlcI/AAAAAAAAAsk/BqEtBNZEFvE/s1600/6.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="92" src="http://4.bp.blogspot.com/-GmPF-oC4t4E/UQ2EbEfjlcI/AAAAAAAAAsk/BqEtBNZEFvE/s320/6.png" width="320" /></a></div><h1></h1></td><td><pre class="brush: plain">* cc4ea63 (HEAD, origin/feature, feature) Experimental changes<br />
    * f0a1a95 Side effects<br />
    * 894217c (origin/master, master) More tests<br />
    * 3883a5c Starting to work on a feature<br />
    * 1bd4e34 Multiplication test<br />
    * f5c886c Testing addition<br />
    * 3e6ab7c Initial revision<br />
</pre></td></tr></tbody></table>The last commit is breaking one of the tests:<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-er_m_nJir4w/UQ2Ebc7BbuI/AAAAAAAAAso/FpdEWew2Ti0/s1600/7.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="230" src="http://2.bp.blogspot.com/-er_m_nJir4w/UQ2Ebc7BbuI/AAAAAAAAAso/FpdEWew2Ti0/s640/7.png" width="640" /></a></div><br />
<h1></h1>Here is where all this pain starts to pay off: <code>feature</code> branch might be broken, but <code>master</code> is untouched. No merging occurred. Only my very own, private branch is broken. Other developers are unaffected. If this build was <i>green</i>, my experimental changes would have been automatically merged to <code>master</code> and pushed. But I made a mistake and they remain hidden. No one cares, my team mates still see stable <code>master</code>. I can go for lunch or fix it tomorrow. No stress, no peer-pressure. When I get it right, Bamboo will automatically apply my fix. <br />
<br />
This was all very easy as Bamboo could use fast-forwarding instead of ordinary merge. But what if we try pushing <i>good</i> changes to modified remote <code>origin/master</code>? Suppose we are working on our feature but in the meantime other developer pushed some changes to <code>bugfix</code> branch which happened to be correct so Bamboo decided to merge them immediately:<br />
<br />
<table><tbody><tr><td><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-q2oFQQSZAJk/UQ2Eb-Pe2iI/AAAAAAAAAsw/QKYPWRpTP4U/s1600/9.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="97" src="http://2.bp.blogspot.com/-q2oFQQSZAJk/UQ2Eb-Pe2iI/AAAAAAAAAsw/QKYPWRpTP4U/s320/9.png" width="320" /></a></div><h1></h1></td><td><pre class="brush: plain">* d600da5 (HEAD, feature) Cosmetics<br />
    | * 25612d7 (origin/master, origin/bugfix, master, bugfix) Documentation<br />
    | * 733b6a9 Urgent bug fix<br />
    |/  <br />
    * 4f258a6 (origin/feature) Fixing test failure<br />
    * cc4ea63 Experimental changes<br />
    * f0a1a95 Side effects<br />
    * 894217c More tests<br />
    * 3883a5c Starting to work on a feature<br />
    * 1bd4e34 Multiplication test<br />
    * f5c886c Testing addition<br />
    * 3e6ab7c Initial revision<br />
</pre></td></tr></tbody></table>As you can see our <code>feature</code> branch was not yet pushed to main repository while <code>bugfix</code> branch is already integrated. How will Bamboo deal with <code>feature</code> branch being pushed? The behaviour is a bit more complex, but still manageable: Bamboo first checks out <code>master</code> (including <code>bugfix</code> branch already merged) and tries to merge changes from <code>feature</code> branch. If merge was successful (no conflicts), ordinary build is performed. If build is successful, merge results are pushed to <code>master</code>:<br />
<br />
<table><tbody><tr><td><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-7C0IeJw_7yU/UQ2EZ8pEioI/AAAAAAAAAsA/aj1Tq3_6vxs/s1600/11.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="145" src="http://4.bp.blogspot.com/-7C0IeJw_7yU/UQ2EZ8pEioI/AAAAAAAAAsA/aj1Tq3_6vxs/s320/11.png" width="320" /></a></div><h1><br />
</h1></td><td><pre class="brush: plain">*   e58a2db (origin/master) [bamboo] Automated branch merge<br />
    |\  <br />
    | * d600da5 (HEAD, origin/feature, feature) Cosmetics<br />
    * | 25612d7 (origin/bugfix, master, bugfix) Documentation<br />
    * | 733b6a9 Urgent bug fix<br />
    |/  <br />
    * 4f258a6 Fixing test failure<br />
    * cc4ea63 Experimental changes<br />
    * f0a1a95 Side effects<br />
    * 894217c More tests<br />
    * 3883a5c Starting to work on a feature<br />
    * 1bd4e34 Multiplication test<br />
    * f5c886c Testing addition<br />
    * 3e6ab7c Initial revision<br />
</pre></td></tr></tbody></table>Notice the "<i>[bamboo] Automated branch merge</i>" commit made implicitly by Bamboo. As you can see this commit merges all my <code>feature</code> branch changes into <code>master</code> branch. This approach works but has several drawbacks:<br />
<br />
<ul><li>after a while your <code>master</code> branch history might consist of barely Bamboo generated commits. I'd rather see ordinary commits there</li><li>automatic merging in Bamboo might fail</li><li>my <code>feature</code> branch still doesn't have <code>bugfix</code> branch changes already merged into mainline</li></ul>For the reasons above it's better to merge my <code>feature</code> branch first locally with <code>master</code> and push that. In this scenario you are almost guaranteed that remote merge on Bamboo will never fail (only fast forward), it's predictable and you work on the latest <code>master</code> state. And BTW wondering what would happen if automatic merging on Bamboo fails?<br />
<br />
<div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-GPNLQnjU6_4/UQ2EaNHXx-I/AAAAAAAAAsI/nxZwi9pjSDA/s1600/13.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="http://1.bp.blogspot.com/-GPNLQnjU6_4/UQ2EaNHXx-I/AAAAAAAAAsI/nxZwi9pjSDA/s640/13.png" width="640" /></a></div><br />
<h1>Summary</h1>This approach for working with version control brings best of both worlds: feature branches and continuous integration. Because each developer is working on a separate branch (or even repository!), broken commit won't ever make it to <code>master</code> branch/mainline. On the other hand automatic merging will make sure our feature branch is always up-to-date and we won't run into issues when trying to merge days worth of work. Moreover good commits are immediately visible to others while bad ones remain hidden.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>
