---
layout: post
title: Promises and CompletableFuture
date: '2013-12-22T20:21:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- CompletableFuture
- multithreading
- concurrency
modified_time: '2015-11-29T23:38:27.987+01:00'
thumbnail: http://2.bp.blogspot.com/-shNFdLJrInc/Urc5BoUsvPI/AAAAAAAAA44/9Qtl5sLmQd8/s72-c/highres_312435802.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-3500733017634612654
blogger_orig_url: https://www.nurkiewicz.com/2013/12/promises-and-completablefuture.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-shNFdLJrInc/Urc5BoUsvPI/AAAAAAAAA44/9Qtl5sLmQd8/s1600/highres_312435802.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-shNFdLJrInc/Urc5BoUsvPI/AAAAAAAAA44/9Qtl5sLmQd8/s1600/highres_312435802.jpg" height="150" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">From <a href="http://www.meetup.com/Warszawa-Java-User-Group-Warszawa-JUG/photos/18880102/">meetup.com</a></td></tr></tbody></table>During <a href="http://www.youtube.com/watch?v=S7gCcgTWSPs">my talk</a>  at Warsaw Java Users Group about functional reactive programming in Java a few interesting questions came up regarding <a href="http://download.java.net/jdk8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a> capabilities. One person was interested whether it's possible to wait for the first completed future that is passing a given predicate rather than just the first one (like <a href="http://download.java.net/jdk8/docs/api/java/util/concurrent/CompletableFuture.html#anyOf-java.util.concurrent.CompletableFuture...-"><code>CompletableFuture.anyOf()</code></a>). This is similar requirement to <a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future$"><code>Future.find()</code></a> in Scala. It's not built into <code>CompletableFuture</code> but quite easy to implement using the concept of <i>promises</i>.<br /><br />Our custom implementation will take two parameters: a list of homogeneous futures and a predicate. The first future to complete that matches given predicate wins. If no future matched resulting future never ends (rather easy to change that behaviour). We will use a thread-safe and lightweight <code>AtomicBoolean completed</code> flag because callbacks will be invoked from multiple threads.    <br /><br /><pre class="brush: java">public static &lt;T&gt; CompletableFuture&lt;T&gt; firstMatching(Predicate&lt;T&gt; predicate, CompletableFuture&lt;T&gt;... futures) {<br />    final AtomicBoolean completed = new AtomicBoolean();<br />    final CompletableFuture&lt;T&gt; promise = new CompletableFuture&lt;&gt;();<br />    for (CompletableFuture&lt;T&gt; future : futures) {<br />        future.thenAccept(result -&gt; {<br />            if (predicate.test(result) &amp;&amp; completed.compareAndSet(false, true))<br />                promise.complete(result);<br />        });<br />    }<br />    return promise;<br />}<br /></pre>As you can see <i>promise</i> is like a <code>Future</code> detached from a thread pool. Rather than waiting for an asynchronous computation to complete we simply assign a value to it at arbitrary point in time. See also: <a href="http://nurkiewicz.blogspot.com/2013/02/implementing-custom-future.html"><i>Implementing custom Future</i></a>. <br /><br /><hr />Second question was about <a href="http://download.java.net/jdk8/docs/api/java/util/concurrent/CompletableFuture.html#anyOf-java.util.concurrent.CompletableFuture...-"><code>CompletableFuture.anyOf()</code></a> - whether it automatically cancels all tasks except the first one. As you may remember <a href="http://nurkiewicz.blogspot.com/2013/05/java-8-definitive-guide-to.html"><code>anyOf()</code> will complete when the very first of underlying futures complete</a>, discarding all remaining futures. It turns out that <code>CompletableFuture</code> forgets about them without any special treatment. We could expect that it should immediately call <code>cancel()</code> on all slower tasks but this doesn't happen (!) and we will see soon why.<br /><br />Luckily we can easily build our own instances of <code>CompletableFuture</code> and resolve them at any time, thus it's relatively easy to build more abstract transformations on top of futures. Our implementation will asynchronously wait for completion of all underlying futures and once the first one completes it will attempt to cancel all the remaining ones - since they are no longer needed:<br /><br /><pre class="brush: java">public static &lt;T&gt; CompletableFuture&lt;T&gt; cancellingAnyOf(CompletableFuture&lt;T&gt;... futures) {<br />    final AtomicBoolean completed = new AtomicBoolean();<br />    final CompletableFuture&lt;T&gt; promise = new CompletableFuture&lt;&gt;();<br />    for (CompletableFuture&lt;T&gt; future : futures) {<br />        future.whenComplete((result, ex) -&gt; {<br />            if (completed.compareAndSet(false, true)) {<br />                Arrays.asList(futures).stream().<br />                        filter(f -&gt; f != future).<br />                        forEach(f -&gt; f.cancel(true));<br />                if (ex != null)<br />                    promise.completeExceptionally(ex);<br />                else<br />                    promise.complete(result);<br />            }<br />        });<br />    }<br />    return promise;<br />}<br /></pre>The implementation is slightly complex because <code>whenComplete()</code> callbacks are executed from multiple threads so we must synchronize this method properly. That's the rationale behind lightweight <code>AtomicBoolean completed</code> flag. When the very first <code>whenComplete()</code> callback is executed it passes the value to our custom <code>CompletableFuture</code> (called <i>promise</i>) and attempts to cancel all the remaining tasks. OK, so the implementation looks fine but it somehow fails to interrupt running tasks, e.g. blocked on <code>Thread.sleep()</code>. In essence all these methods that declare throwing <code>InterruptedException</code> should be interrupted but aren't. Why? Well, <i>I failed</i> to read the <a href="http://download.java.net/jdk8/docs/api/java/util/concurrent/CompletableFuture.html">documentation of <code>CompletableFuture</code></a>:<br /><br /><blockquote>Since [...] this class has no direct control over the computation that causes it to be completed, cancellation is treated as just another form of exceptional completion. Method <code>cancel</code> has the same effect as <code>completeExceptionally(new CancellationException())</code>.<br /><br /></blockquote>And in <a href="http://download.java.net/jdk8/docs/api/java/util/concurrent/CompletableFuture.html#cancel-boolean-"><code>CompletableFuture.cancel(mayInterruptIfRunning)</code></a>:<br /><br /><blockquote><code>mayInterruptIfRunning</code> - this value has no effect in this implementation because interrupts are not used to control processing.<br /><br /></blockquote>This means that <b><code>CompletableFuture.cancel()</code> does not interrupt underlying thread</b>. When you call <code>Future.cancel()</code> it tries to call <code>Thread.interrupt()</code>, eagerly stopping already running task. This is virtually impossible with <code>CompletableFuture</code>. All it does is resolving a future with <code>CancellationException</code> but does not care about computation running. Very disappointing but worth knowing.<br /><br />I hope by now you are more familiar with the concept of <i>promises</i> and how they can be implemented using <code>CompletableFuture</code>. Other scenarios are relatively easy to glue together.<br /><br /><script src="https://gist.github.com/nurkiewicz/3983275/raw/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>