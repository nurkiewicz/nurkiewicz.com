---
layout: post
title: Implementing custom Future
date: '2013-02-20T20:38:00.001+01:00'
author: Tomasz Nurkiewicz
tags:
- jms
- multithreading
- concurrency
modified_time: '2013-02-20T20:38:31.551+01:00'
thumbnail: http://3.bp.blogspot.com/-c9_dtm4HNMk/USUlh2vmWFI/AAAAAAAAAuE/gj2NrpXyGGs/s72-c/169795_121654734567005_7861957_o.jpg
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2326339500428441136
blogger_orig_url: https://www.nurkiewicz.com/2013/02/implementing-custom-future.html
---

<table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-c9_dtm4HNMk/USUlh2vmWFI/AAAAAAAAAuE/gj2NrpXyGGs/s1600/169795_121654734567005_7861957_o.jpg" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://3.bp.blogspot.com/-c9_dtm4HNMk/USUlh2vmWFI/AAAAAAAAAuE/gj2NrpXyGGs/s320/169795_121654734567005_7861957_o.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Oslo seen from Grefsenkollen</td></tr></tbody></table>Last time we learned the <a href="http://nurkiewicz.com/2013/02/javautilconcurrentfuture-basics.html">principles behind <code>java.util.concurrent.Future&lt;T&gt;</code></a>. We also discovered that <code>Future&lt;T&gt;</code> is typically returned by libraries or frameworks. But there is nothing stopping us from implementing it all by ourselves when it makes sense. It is not particularly complex and may significantly improve your design. I did my best to pick interesting use case for our example.<br /><br /><a href="http://en.wikipedia.org/wiki/Java_Message_Service">JMS (Java Message Service)</a> is a standard Java API for sending asynchronous messages. When we think about JMS, we immediately see a client sending a message to a server (broker) in a <i>fire and forget</i> manner. But it is equally common to implement <a href="http://www.eaipatterns.com/RequestReplyJmsExample.html"><i>request-reply</i> messaging pattern</a> on top of JMS. The implementation is fairly simple: you send a request message (of course asynchronously) to an MDB on the other side. MDB processes the request and sends a reply back either to hardcoded <i>reply</i> queue or to an arbitrary queue chosen by the client and sent along with the message in <code>JMSReplyTo</code> property. The second scenario is much more interesting. Client can create a temporary queue and use it as a reply queue when sending a request. This way each request/reply pair uses different reply queue, this there is no need for correlation ID, selectors, etc.<br /><br />There is one catch, however. Sending a message to JMS broker is simple and asynchronous. But receiving reply is much more cumbersome. You can either implement <a href="http://docs.oracle.com/javaee/6/api/javax/jms/MessageListener.html"><code>MessageListener</code></a> to consume one, single message or use blocking <a href="http://docs.oracle.com/javaee/6/api/javax/jms/MessageConsumer.html#receive()"><code>MessageConsumer.receive()</code></a>. First approach is quite heavyweight and hard to use in practice. <a href="http://activemq.apache.org/how-should-i-implement-request-response-with-jms.html">Second one</a> defeats the purpose of asynchronous messaging. You can also poll the reply queue with some interval, which sounds even worse.<br /><br />Knowing the <code>Future</code> abstraction by now you should have some design idea. What if we can send a request message and get a <code>Future&lt;T&gt;</code> back, representing reply message that didn't came yet? This <code>Future</code> abstraction should handle all the logic and we can safely use it as a handle to future outcome. Here is the plumbing code used to create temporary queue and send request:<br /><a name='more'></a><br /><br /><pre class="brush: java">private &lt;T extends Serializable&gt; Future&lt;T&gt; asynchRequest(ConnectionFactory connectionFactory, Serializable request, String queue) throws JMSException {<br />    Connection connection = connectionFactory.createConnection();<br />    connection.start();<br />    final Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<br />    final Queue tempReplyQueue = session.createTemporaryQueue();<br />    final ObjectMessage requestMsg = session.createObjectMessage(request);<br />    requestMsg.setJMSReplyTo(tempReplyQueue);<br />    sendRequest(session.createQueue(queue), session, requestMsg);<br />    return new JmsReplyFuture&lt;T&gt;(connection, session, tempReplyQueue);<br />}<br /></pre><code>asynchRequest()</code> method simply takes a <a href="http://docs.oracle.com/javaee/6/api/javax/jms/ConnectionFactory.html"><code>ConnectionFactory</code></a> to JMS broker and arbitrary piece of data. This object will be sent to <code>queue</code> using <code>ObjectMessage</code>. Last line is crucial - we return our custom <code>JmsReplyFuture&lt;T&gt;</code> that will represent <i>not-yet-received</i> reply. Notice how we pass temporary JMS queue to both <code>JMSReplyTo</code> property and our <code>Future</code>. Implementation of the MDB side is not that important. Needless to say it is suppose to send a reply back to designated queue:<br /><br /><pre class="brush: java">final ObjectMessage reply = session.createObjectMessage(...);<br />session.createProducer(request.getJMSReplyTo()).send(reply);<br /></pre>So let's dive into the implementation of <code>JmsReplyFuture&lt;T&gt;</code>. I made an assumption that both request and reply are <code>ObjectMessage</code>s. It's not very challenging to use a different type of message. First of all let us see how receiving messages from reply channel is set up:<br /><br /><pre class="brush: java">public class JmsReplyFuture&lt;T extends Serializable&gt; implements Future&lt;T&gt;, MessageListener {<br /><br />    //...<br /><br />    public JmsReplyFuture(Connection connection, Session session, Queue replyQueue) throws JMSException {<br />        this.connection = connection;<br />        this.session = session;<br />        replyConsumer = session.createConsumer(replyQueue);<br />        replyConsumer.setMessageListener(this);<br />    }<br /><br />    @Override<br />    public void onMessage(Message message) {<br />        //...<br />    }<br /><br />}<br /></pre>As you can see <code>JmsReplyFuture</code> implements both <code>Future&lt;T&gt;</code> (where <code>T</code> is expected type of object wrapped inside <code>ObjectMessage</code>) and JMS <code>MessageListener</code>. In the constructor we simply start listening on <code>replyQueue</code>. From our design assumptions we know that there will be at most one message there because reply queue is temporary throw away queue. <a href="http://nurkiewicz.com/2013/02/javautilconcurrentfuture-basics.html">In the previous article</a> we learned that <code>Future.get()</code> should block while waiting for a result. On the other hand <code>onMessage()</code> is a callback method called from some internal JMS client thread/library. Apparently we need some shared variable/lock to let waiting <code>get()</code> know that reply arrived. Preferably our solution should be lightweight and not introduce any latency so busy waiting on <code>volatile</code> variable is a bad idea. Initially I though about <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html"><code>Semaphore</code></a> that I would use to unblock <code>get()</code> from <code>onMessage()</code>. But I would still need some shared variable to hold the actual reply object. So I came up with an idea of using <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html"><code>ArrayBlockingQueue</code></a>. It might sound strange to use a queue when we know there will be no more that one item. But it works perfectly, utilizing good old producer-consumer pattern: <code>Future.get()</code> is a consumer blocking on an empty queue's <code>poll()</code> method. On the other hand <code>onMessage()</code> is a producer, placing reply message in that queue and immediately unblocking consumer. Here is how it looks:<br /><br /><pre class="brush: java; highlight: [14, 25]">public class JmsReplyFuture&lt;T extends Serializable&gt; implements Future&lt;T&gt;, MessageListener {<br /><br />    private final BlockingQueue&lt;T&gt; reply = new ArrayBlockingQueue&lt;&gt;(1);<br /><br />    //...<br /><br />    @Override<br />    public T get() throws InterruptedException, ExecutionException {<br />        return this.reply.take();<br />    }<br /><br />    @Override<br />    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {<br />        final T replyOrNull = reply.poll(timeout, unit);<br />        if (replyOrNull == null) {<br />            throw new TimeoutException();<br />        }<br />        return replyOrNull;<br />    }<br /><br />    @Override<br />    public void onMessage(Message message) {<br />        final ObjectMessage objectMessage = (ObjectMessage) message;<br />        final Serializable object = objectMessage.getObject();<br />        reply.put((T) object);<br />        //...<br />    }<br /><br />}<br /></pre>The implementation is still not complete, but it covers most important concepts. Notice how nicely <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#poll(long,%20java.util.concurrent.TimeUnit)"><code>BlockingQueue.poll(long, TimeUnit)</code></a> method fits into <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get(long,%20java.util.concurrent.TimeUnit)"><code>Future.get(long, TimeUnit)</code></a>. Unfortunately, even though they come from the same package and were developed more or less in the same time, one method returns <code>null</code> upon timeout while the other should throw an exception. Easy to fix.<br /><br />Also notice how easy the implementation of <code>onMessage()</code> became. We just place newly received message in a <code>BlockingQueue reply</code> and the collection does all the synchronization for us. We are still missing some less significant, but still important details - cancelling and clean up. Without going much into details, here is a full implementation:<br /><br /><pre class="brush: java">public class JmsReplyFuture&lt;T extends Serializable&gt; implements Future&lt;T&gt;, MessageListener {<br /><br />    private static enum State {WAITING, DONE, CANCELLED}<br /><br />    private final Connection connection;<br />    private final Session session;<br />    private final MessageConsumer replyConsumer;<br />    private final BlockingQueue&lt;T&gt; reply = new ArrayBlockingQueue&lt;&gt;(1);<br />    private volatile State state = State.WAITING;<br /><br />    public JmsReplyFuture(Connection connection, Session session, Queue replyQueue) throws JMSException {<br />        this.connection = connection;<br />        this.session = session;<br />        replyConsumer = session.createConsumer(replyQueue);<br />        replyConsumer.setMessageListener(this);<br />    }<br /><br />    @Override<br />    public boolean cancel(boolean mayInterruptIfRunning) {<br />        try {<br />            state = State.CANCELLED;<br />            cleanUp();<br />            return true;<br />        } catch (JMSException e) {<br />            throw Throwables.propagate(e);<br />        }<br />    }<br /><br />    @Override<br />    public boolean isCancelled() {<br />        return state == State.CANCELLED;<br />    }<br /><br />    @Override<br />    public boolean isDone() {<br />        return state == State.DONE;<br />    }<br /><br />    @Override<br />    public T get() throws InterruptedException, ExecutionException {<br />        return this.reply.take();<br />    }<br /><br />    @Override<br />    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {<br />        final T replyOrNull = reply.poll(timeout, unit);<br />        if (replyOrNull == null) {<br />            throw new TimeoutException();<br />        }<br />        return replyOrNull;<br />    }<br /><br />    @Override<br />    public void onMessage(Message message) {<br />        try {<br />            final ObjectMessage objectMessage = (ObjectMessage) message;<br />            final Serializable object = objectMessage.getObject();<br />            reply.put((T) object);<br />            state = State.DONE;<br />            cleanUp();<br />        } catch (Exception e) {<br />            throw Throwables.propagate(e);<br />        }<br />    }<br /><br />    private void cleanUp() throws JMSException {<br />        replyConsumer.close();<br />        session.close();<br />        connection.close();<br />    }<br />}<br /></pre>I use special <code>State</code> enum to hold the information about state. I find it much more readable compared to complex conditions based on multiple flags, <code>null</code> checks, etc. Second thing to keep in mind is cancelling. Fortunately it's quite simple. We basically close the underlying session/connection. It has to remain open throughout the course of whole request/reply message exchange, otherwise temporary JMS reply queue disappears. Note that we cannot easily inform broker/MDB that we are no longer interested about the reply. We simply stop listening for it, but MDB will still process request and try to send a reply to no longer existing temporary queue.<br /><br /><hr />So how does this all look in practice? Say we have an MDB that receives a number and returns a square of it. Imagine the computation takes a little bit of time so we start it in advance, do some work in the meantime and later retrieve the results. Here is how such a design might look like:<br /><br /><pre class="brush: java">final Future&lt;Double&gt; replyFuture = asynchRequest(connectionFactory, 7, "square");<br />//do some more work<br />final double resp = replyFuture.get();      //49<br /></pre>Where <code>"square"</code> is the name of request queue. If we refactor it and use dependency injection we can further simplify it to something like:<br /><br /><pre class="brush: java">final Future&lt;Double&gt; replyFuture = calculator.square(7);<br />//do some more work<br />final double resp = replyFuture.get();      //49<br /></pre>You know what's best about this design? Even though we are exploiting quite advanced JMS capabilities, there is no JMS code here. Moreover we can later replace <code>calculator</code> with a different implementation, using SOAP or GPU. As far as the client code is concerned, we still use <code>Future&lt;Double&gt;</code> abstraction. Computation result that is not yet available. The underlying mechanism is irrelevant. That is the beauty of abstraction.<br /><br /><hr />Obviously this implementation is not production ready (by far). But even worse, it misses some essential features. We still call blocking <code>Future.get()</code> at some point. Moreover there is no way of composing/chaining futures (e.g. <i>when the response arrives, send another message</i>) or waiting for the <i>fastest</i> future to complete. Be patient!    <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>