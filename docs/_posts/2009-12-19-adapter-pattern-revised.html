---
layout: post
title: Adapter pattern revised
date: '2009-12-19T14:47:00.007+01:00'
author: Tomasz Nurkiewicz
tags:
- testing
- design patterns
- intellij idea
- hamcrest
- junit
modified_time: '2013-06-04T18:07:14.611+02:00'
thumbnail: http://2.bp.blogspot.com/_P3ewsGQzHn0/Syzf6DDftYI/AAAAAAAAASI/qPECkCQcfis/s72-c/junit1.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2328179176259612385
blogger_orig_url: https://www.nurkiewicz.com/2009/12/adapter-pattern-revised.html
---

In my <a href="http://nurkiewicz.com/2009/09/adapter-pattern-accesing-ehcache-via.html">article</a> about adapter pattern I have written an adapter that allows to access <a href="http://ehcache.org/apidocs/net/sf/ehcache/Ehcache.html" style="font-family: courier new;">Ehcache</a> cache instances through a simple <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html"><span style="font-family: courier new;">Map</span></a> interface. The basic idea was to write a <span style="font-family: courier new;">Map</span> implementation that actually, behind the scenes, was wrapping and hitting Ehcache. Everything looked great but <span style="font-weight: bold;">Zach Bailey</span> found a bug in my implementation – or more precisely – lack of functionality. He even provided a test case proving he is right. And sadly, he was ;-). Thank you Zach!<br /><br />The problem was with three map methods: <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html#keySet%28%29"><span style="font-family: courier new;">keySet()</span></a>, <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html#entrySet%28%29"><span style="font-family: courier new;">entrySet()</span></a> and <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html#values%28%29"><span style="font-family: courier new;">values()</span></a>. If you read carefully their API you’ll find out that all these methods should return an "interactive" view backed by the underlying map so that changing the view is automatically reflected in the map that returned that view and vice-versa. For example, if you remove an item from the set returned by <span style="font-family: courier new;">keySet()</span>, corresponding map entry with this key value should be also removed. Unfortunately, in my implementation these methods simply returned independent copies holding current state (snapshots) of the map. To make matters worse, those were not immutable collections (see <a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html#unmodifiableSet%28java.util.Set%29"><span style="font-family: courier new;">Collections#unmodifiableSet</span></a>) so when user modified them, no errors were issued but also source map remained untouched, effectively hiding the bug.<br /><br />As I said, I already have a unit test failing on my <span style="font-family: courier new;">Map</span> implementation. I extended the test case and created more complex test set (but still not complete!) Look at the signatures, I hope they are self-describing:<br /><br /><br /><pre class="brush: java">package com.blogspot.nurkiewicz.ehcache;<br /><br />import java.util.Iterator;<br />import java.util.Map;<br />import java.util.Set;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br /><br />import static org.hamcrest.CoreMatchers.equalTo;<br />import static org.hamcrest.CoreMatchers.not;<br />import static org.hamcrest.MatcherAssert.assertThat;<br />import static org.hamcrest.Matchers.hasItem;<br />import static org.hamcrest.collection.IsMapContaining.hasEntry;<br />import static org.junit.Assert.assertFalse;<br />import static org.junit.Assert.assertNotNull;<br />import static org.junit.Assert.assertNull;<br />import static org.junit.Assert.assertTrue;<br /><br />public  class MapTest {<br /><br />   private Map&lt;String, String&gt; map;<br /><br />   @Before<br />   public void setupTestMap() {<br />       map =  //...<br />   }<br /><br />   @Test public void emptyMapShouldReturnEmptyKeySet() {/**/}<br />   @Test public void mapWithSingleEntryShouldReturnKeySetWithSingleItem() {/**/}<br />   @Test public void mapWithMultipleEntriesShouldReturnKeySetWithMultipleItems() {/**/}<br />   @Test public void removingOnlyItemFromKeySetShouldRemoveFromMap() {/**/}<br />   @Test public void removingOnlyItemFromKeySetUsingIteratorShouldRemoveFromMap() {/**/}<br />   @Test public void removingOneOfItemsFromKeySetShouldRemoveFromMap() {/**/}<br />   @Test public void removingOneOfItemsFromKeySetUsingIteratorShouldRemoveFromMap() {/**/}<br />   @Test public void removingNotExistingItemFromKeySetShouldNotChangeMap() {/**/}<br />   @Test public void removingOnlyEntryFromMapShouldRemoveItemFromKeySet() {/**/}<br />   @Test public void removingOnlyEntryFromMapUsingIteratorShouldRemoveFromKeySet() {/**/}<br />   @Test public void removingOneOfEntriesFromMapShouldRemoveFromKeySet() {/**/}<br />   @Test public void removingOneOfEntriesFromMapUsingIteratorShouldRemoveFromKeySet() {/**/}<br />   @Test public void removingNotExistingEntryFromMapShouldNotChangeKeySet() {/**/}<br />   @Test public void addingEntryToMapShouldAddItemToKeySet() {/**/}<br />}</pre><br /><br />But before we move on and examine our original implementation against this test let us think for a while how to set up this test case? I could simply write in <span style="font-family: courier new;">setupTestMap()</span>:<br /><br /><pre class="brush: java">final Ehcache cache = CacheManager.getInstance().getEhcache("com.blogspot.nurkiewicz.ehcache.TEST");<br />map = new EhcacheMapAdapter&lt;String, String&gt;(cache);</pre><br /><br />But then I decided to test my unit tests (sic!) by running them on standard Java <span style="font-family: courier new;">Map</span> implementations: <a href="http://java.sun.com/javase/6/docs/api/java/util/HashMap.html" style="font-family: courier new;">HashMap</a>, <span style="font-family: courier new;"><a href="http://java.sun.com/javase/6/docs/api/java/util/TreeMap.html">TreeMap</a> </span>and <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html"><span style="font-family: courier new;">ConcurrentHashMap</span></a>. This is a common scenario, where you have more than one implementation of an interface and you would like to test all the implementations at once. In an ideal world (luckily, this article describes one), unit test should not depend upon particular implementation of the interface, it should rather verify whether the interface contract is satisfied, no matter which implementation is used. We want to write a single test case and pass different implementations to test them one at a time. How to do this in JUnit without copy-pasting the same tests (<a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"><span style="font-style: italic;">don’t repeat yourself!</span></a>) over and over? This is my real setup code:<br /><br /><pre class="brush: java">public abstract class MapTest {<br /><br />   private Map&lt;String, String&gt; map;<br /><br />   @Before<br />   public void setupTestMap() {<br />       map = createTestMap();<br />       assertNotNull(map);<br />   }<br /><br />   protected abstract Map&lt;String, String&gt; createTestMap();<br /><br />   //...<br />}</pre><br /><br />Have you noticed test case class being abstract? JUnit runners (both <a href="http://maven.apache.org/plugins/maven-surefire-plugin" style="font-family: courier new;">maven-surefire-plugin</a> and <a href="http://www.jetbrains.com/idea">IntelliJ IDEA</a> built in runner) are smart enough to ignore abstract test cases and run only concrete subclasses. But more importantly, when they run <span style="font-family: courier new;">MapTest </span>subclasses they include test methods (annotated with <span style="font-family: courier new;">@Test</span>) defined in abstract base class. Don’t get the idea? Look at the rest of the code:<br /><br /><pre class="brush: java">public class HashMapTest extends MapTest {<br /><br />   @Override<br />   public Map&lt;String, String&gt; createTestMap() {<br />       return new HashMap&lt;String, String&gt;();<br />   }<br />}</pre><br /><br /><pre class="brush: java">public class ConcurrentHashMapTest extends MapTest {<br /><br />   @Override<br />   public Map&lt;String, String&gt; createTestMap() {<br />       return new ConcurrentHashMap&lt;String, String&gt;();<br />   }<br />}</pre><br /><br /><pre class="brush: java">public class TreeMapTest extends MapTest {<br /><br />   @Override<br />   public Map&lt;String, String&gt; createTestMap() {<br />       return new TreeMap&lt;String, String&gt;();<br />   }<br />}</pre><br /><br /><pre class="brush: java">public class EhcacheMapAdapterTest extends MapTest {<br /><br />   @Override<br />   public Map&lt;String, String&gt; createTestMap() {<br />       final Ehcache cache = CacheManager.getInstance().getEhcache("com.blogspot.nurkiewicz.ehcache.TEST");<br />       cache.removeAll();<br />       return new EhcacheMapAdapter&lt;String, String&gt;(cache);<br />   }<br />}</pre><br /><br />Each <span style="font-family: courier new;">MapTest </span>subclass inherits test methods from abstract base class, but providing concrete <span style="font-family: courier new;">Map</span> implementation. <span style="font-family: courier new;">EhcacheMapAdapterTest </span>is the one of our interest. BTW we’ve actually introduced <a href="http://en.wikipedia.org/wiki/Template_method_pattern"><span style="font-style: italic;">Template Method</span></a> design pattern! In this pattern the majority of work (algorithm) is implemented in abstract base classes, but some steps are left intentionally as abstract methods. When using this class, almost everything is done already, all you need to provide are (typically simple) implementations of abstract methods. In our case all the logic (unit tests) are gathered in base class <span style="font-family: courier new;">MapTest</span>, but the user must subclass it and implement <span style="font-family: courier new;">Map</span> factory method <span style="font-family: courier new;">createTestMap()</span>. But more on this pattern maybe later.<br /><br />Going back to bug-fixing. Since we have the tests, lets run them to see where are we starting:<br /><br /><a href="http://2.bp.blogspot.com/_P3ewsGQzHn0/Syzf6DDftYI/AAAAAAAAASI/qPECkCQcfis/s1600-h/junit1.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5416950640165238146" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/Syzf6DDftYI/AAAAAAAAASI/qPECkCQcfis/s200/junit1.png" style="cursor: pointer; display: block; height: 179px; margin: 0px auto 10px; text-align: center; width: 200px;" /></a><br /><br />As you can see, all the tests passed in standard JDK implementations, but my EhcacheMapAdapter has lots to be ashamed of...<br /><br />It is not even test driven <span style="font-style: italic;">development</span>. It is rather test driven <span style="font-style: italic;">bug-fixing</span> – somebody reports you a bug and the first thing to do is to write a unit test (since we probably missed one) that fails because of the bug. That’s the best way to reproduce the bug. When we know what is wrong, we are bug-fixing until that (and all existing) test succeeds. This has another benefit – if few months later some developer sees your code, existing unit test will help him to understand why this bug-fix has been applied and prevent from removing it.<br /><br />After an hour or two all my tests were green, so I had a good starting point for optimizations or refactorings. Code is good, but making it even better won’t break anything. But I must disappoint you – or rather: give you an opportunity to enrich your test driven experiences! In the <a href="http://nurkiewicz.com/2009/09/adapter-pattern-accesing-ehcache-via.html">first article</a> you have a starting code, below is the full test case source:<br /><br /><br /><pre class="brush: java">public abstract class MapTest {<br /><br />   private Map&lt;String, String&gt; map;<br /><br />   @Before<br />   public void setupTestMap() {<br />       map = createTestMap();<br />       assertNotNull(map);<br />   }<br /><br />   protected abstract Map&lt;String, String&gt; createTestMap();<br /><br />   @Test<br />   public void emptyMapShouldReturnEmptyKeySet() {<br />       //given<br /><br />       //when<br />       final Set&lt;String&gt; set = map.keySet();<br /><br />       //then<br />       assertThat(set.size(), equalTo(0));<br />   }<br /><br />   @Test<br />   public void mapWithSingleEntryShouldReturnKeySetWithSingleItem() {<br />       //given<br />       map.put("zero", "0");<br /><br />       //when<br />       final Set&lt;String&gt; set = map.keySet();<br /><br />       //then<br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, hasItem("zero"));<br />   }<br /><br />   @Test<br />   public void mapWithMultipleEntriesShouldReturnKeySetWithMultipleItems() {<br />       //given<br />       map.put("zero", "0");<br />       map.put("ten", "10");<br />       map.put("hundred", "100");<br /><br />       //when<br />       final Set&lt;String&gt; set = map.keySet();<br /><br />       //then<br />       assertThat(set.size(), equalTo(3));<br />       assertThat(set, hasItem("zero"));<br />       assertThat(set, hasItem("ten"));<br />       assertThat(set, hasItem("hundred"));<br />   }<br /><br />   @Test<br />   public void removingOnlyItemFromKeySetShouldRemoveFromMap() {<br />       //given<br />       map.put("one", "1");<br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("one", "1"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final boolean result = set.remove("one");<br /><br />       //then<br />       assertTrue(result);<br />       assertTrue(set.isEmpty());<br />       assertTrue(map.isEmpty());<br /><br />   }<br /><br />   @Test<br />   public void removingOnlyItemFromKeySetUsingIteratorShouldRemoveFromMap() {<br />       //given<br />       map.put("one", "1");<br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("one", "1"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final Iterator&lt;String&gt; iterator = set.iterator();<br />       iterator.next();<br />       iterator.remove();<br /><br />       //then<br />       assertTrue(set.isEmpty());<br />       assertTrue(map.isEmpty());<br /><br />   }<br /><br />   @Test<br />   public void removingOneOfItemsFromKeySetShouldRemoveFromMap() {<br />       //given<br />       map.put("three", "3");<br />       map.put("two", "2");<br />       assertThat(map.size(), equalTo(2));<br />       assertThat(map, hasEntry("two", "2"));<br />       assertThat(map, hasEntry("three", "3"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final boolean resultOfRemovingOne = set.remove("one");<br />       final boolean resultOfRemovingTwo = set.remove("two");<br /><br />       //then<br />       assertFalse(resultOfRemovingOne);<br />       assertTrue(resultOfRemovingTwo);<br /><br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, not(hasItem("two")));<br />       assertThat(set, hasItem("three"));<br /><br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, not(hasEntry("two", "2")));<br />       assertThat(map, hasEntry("three", "3"));<br />   }<br /><br />   @Test<br />   public void removingOneOfItemsFromKeySetUsingIteratorShouldRemoveFromMap() {<br />       //given<br />       map.put("three", "3");<br />       map.put("two", "2");<br />       assertThat(map.size(), equalTo(2));<br />       assertThat(map, hasEntry("two", "2"));<br />       assertThat(map, hasEntry("three", "3"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final Iterator&lt;String&gt; iterator = set.iterator();<br />       final String removedKey = iterator.next();<br />       iterator.remove();<br /><br />       //then<br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, not(hasItem(removedKey)));<br />       assertThat(map.size(), equalTo(1));<br />   }<br /><br />   @Test<br />   public void removingNotExistingItemFromKeySetShouldNotChangeMap() {<br />       //given<br />       map.put("four", "4");<br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("four", "4"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final boolean result = set.remove("five");<br /><br />       //then<br />       assertFalse(result);<br /><br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, hasItem("four"));<br /><br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("four", "4"));<br />   }<br /><br />   @Test<br />   public void removingOnlyEntryFromMapShouldRemoveItemFromKeySet() {<br />       //given<br />       map.put("one", "1");<br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("one", "1"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final String previousValue = map.remove("one");<br /><br />       //then<br />       assertThat(previousValue, equalTo("1"));<br />       assertTrue(set.isEmpty());<br /><br />   }<br /><br />   @Test<br />   public void removingOnlyEntryFromMapUsingIteratorShouldRemoveFromKeySet() {<br />       //given<br />       map.put("one", "1");<br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("one", "1"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();<br />       iterator.next();<br />       iterator.remove();<br /><br />       //then<br />       assertTrue(set.isEmpty());<br /><br />   }<br /><br />   @Test<br />   public void removingOneOfEntriesFromMapShouldRemoveFromKeySet() {<br />       //given<br />       map.put("three", "3");<br />       map.put("two", "2");<br />       assertThat(map.size(), equalTo(2));<br />       assertThat(map, hasEntry("two", "2"));<br />       assertThat(map, hasEntry("three", "3"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final String previousValueForKeyOne = map.remove("one");<br />       final String previousValueForKeyTwo = map.remove("two");<br /><br />       //then<br />       assertNull(previousValueForKeyOne);<br />       assertNotNull(previousValueForKeyTwo);<br /><br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, not(hasItem("two")));<br />       assertThat(set, hasItem("three"));<br />   }<br /><br />   @Test<br />   public void removingOneOfEntriesFromMapUsingIteratorShouldRemoveFromKeySet() {<br />       //given<br />       map.put("three", "3");<br />       map.put("two", "2");<br />       assertThat(map.size(), equalTo(2));<br />       assertThat(map, hasEntry("two", "2"));<br />       assertThat(map, hasEntry("three", "3"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();<br />       final Map.Entry&lt;String, String&gt; entry = iterator.next();<br />       iterator.remove();<br /><br />       //then<br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, not(hasItem(entry.getKey())));<br />   }<br /><br />   @Test<br />   public void removingNotExistingEntryFromMapShouldNotChangeKeySet() {<br />       //given<br />       map.put("four", "4");<br />       assertThat(map.size(), equalTo(1));<br />       assertThat(map, hasEntry("four", "4"));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       final String previousValueForKeyFive = map.remove("five");<br /><br />       //then<br />       assertNull(previousValueForKeyFive);<br /><br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, hasItem("four"));<br />   }<br /><br />   @Test<br />   public void addingEntryToMapShouldAddItemToKeySet() {<br />       //given<br />       assertThat(map.size(), equalTo(0));<br /><br />       //when<br />       Set&lt;String&gt; set = map.keySet();<br />       map.put("two", "2");<br /><br />       //then<br />       assertThat(set.size(), equalTo(1));<br />       assertThat(set, hasItem("two"));<br />   }<br /><br />}</pre><br /><br /><br />Try a little of TDB (<span style="font-style: italic;">test driven bug-fixing</span>) and see how great bug-fixing can be, when unit tests tell you exactly, if you’ve done your job correctly. Happy coding!  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>