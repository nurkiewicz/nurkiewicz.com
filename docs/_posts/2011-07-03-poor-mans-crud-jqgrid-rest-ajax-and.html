---
layout: post
title: 'Poor man''s CRUD: jqGrid, REST, AJAX, and Spring MVC in one house'
date: '2011-07-03T19:15:00.001+02:00'
author: Tomasz Nurkiewicz
tags:
- jqgrid
- jquery
- spring mvc
- javascript
- rest
- spring
modified_time: '2011-11-17T19:22:27.232+01:00'
thumbnail: http://1.bp.blogspot.com/-S_jCbvgAito/ThCgthzLOlI/AAAAAAAAAcY/z2FWNRGmdSw/s72-c/popup.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-981368694888269595
blogger_orig_url: https://www.nurkiewicz.com/2011/07/poor-mans-crud-jqgrid-rest-ajax-and.html
---

<div>More than two years back I wrote an article on how two implement elegant CRUD in <a href="http://struts.apache.org/2.2.1.1/">Struts2</a>. Actually I had to devote two articles on that subject because the topic was so broad. Today I have taken much more lightweight and modern approach with a set of popular and well established frameworks and libraries. Namely, we will use <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/mvc.html">Spring MVC</a> on the back-end to provide REST interface to our resources, fabulous <a href="http://www.trirand.com/blog">jqGrid</a> plugin for <a href="http://jquery.com/">jQuery</a> to render tabular grids (and much more!) and we will wire up everything with a pinch of JavaScript and AJAX.</div><div><br /></div><div>Back-end is actually the least interesting part of this showcase, it could have been implemented using any server-side technology capable of handling RESTful requests, probably JAX-RS should now be considered standard in this field. I have chosen Spring MVC without any good reason, but it's also not a bad choice for this task. We will expose CRUD operations over REST interface; the list of <a href="http://en.wikipedia.org/wiki/List_of_best-selling_books">best selling books in history</a> will be our domain model (can you guess who is on the podium?)</div><div><br /></div><div><pre class="brush: java"><br />@Controller<br />@RequestMapping(value = "/book")<br />public class BookController {<br /><br />  private final Map&lt;Integer, Book&gt; books = new ConcurrentSkipListMap&lt;Integer, Book&gt;();<br /><br />  @RequestMapping(value = "/{id}", method = GET)<br />  public @ResponseBody Book read(@PathVariable("id") int id) {<br />    return books.get(id);<br />  }<br /><br />  @RequestMapping(method = GET)<br />  public @ResponseBody Page&lt;Book&gt; listBooks(<br />      @RequestParam(value = "page", required = false, defaultValue = "1") int page,<br />      @RequestParam(value = "max", required = false, defaultValue = "20") int max) {<br />    final ArrayList&lt;Book&gt; booksList = new ArrayList&lt;Book&gt;(books.values());<br />    final int startIdx = (page - 1) * max;<br />    final int endIdx = Math.min(startIdx + max, books.size());<br />    return new Page&lt;Book&gt;(booksList.subList(startIdx, endIdx), page, max, books.size());<br />  }<br />}<br /></pre></div><div><br /></div><div>Few things need explanation. First of all <b>for the purposes of this simple showcase</b> I haven't used any database, all the books are stored in an in-memory map inside a controller. Forgive me. Second issue is more subtle. Since there seems to be <a href="http://stackoverflow.com/questions/924472">no agreement</a> on how to handle paging with RESTful web services, I used simple query parameters. You may find it ugly, but I find abusing <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Accept-Ranges</span> and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Range</span> headers together with <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">206</span> HTTP response code even uglier.</div><div><br /></div><div>Last notable detail is the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Page&lt;Book&gt;</span> wrapper class:<br /><br /><a name='more'></a><br /></div><div><br /></div><div><pre class="brush: java"><br />@XmlRootElement<br />public class Page&lt;T&gt; {<br /><br />  private List&lt;T&gt; rows;<br /><br />  private int page;<br />  private int max;<br />  private int total;<br /><br />  //...<br /><br />}<br /></pre></div><div><br /></div><div>I could have return raw list (or, more precisely, requested part of the list), but I also need a way to provide convenient metadata like total number of records to the view layer, not to mention some difficulties while marshalling/unmarshalling raw lists.</div><div><br /></div><div>We are now ready to start our application and do a little test drive with <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">curl</span>:</div><div><br /></div><div><pre class="brush: xml"><br />&lt;!-- $ curl -v "http://localhost:8080/books/rest/book?page=1&max=2" --&gt;<br /><br />&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br />&lt;page&gt;<br />  &lt;total&gt;43&lt;/total&gt;<br />  &lt;page&gt;1&lt;/page&gt;<br />  &lt;max&gt;3&lt;/max&gt;<br />  &lt;rows xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="book"&gt;<br />    &lt;author&gt;Charles Dickens&lt;/author&gt;<br />    &lt;available&gt;true&lt;/available&gt;<br />    &lt;cover&gt;PAPERBACK&lt;/cover&gt;<br />    &lt;id&gt;1&lt;/id&gt;<br />    &lt;publishedYear&gt;1859&lt;/publishedYear&gt;<br />    &lt;title&gt;A Tale of Two Cities&lt;/title&gt;<br />  &lt;/rows&gt;<br />  &lt;rows xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="book"&gt;<br />    &lt;author&gt;J. R. R. Tolkien&lt;/author&gt;<br />    &lt;available&gt;true&lt;/available&gt;<br />    &lt;cover&gt;HARDCOVER&lt;/cover&gt;<br />    &lt;id&gt;2&lt;/id&gt;<br />    &lt;publishedYear&gt;1954&lt;/publishedYear&gt;<br />    &lt;title&gt;The Lord of the Rings&lt;/title&gt;<br />  &lt;/rows&gt;<br />  &lt;rows xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="book"&gt;<br />    &lt;author&gt;J. R. R. Tolkien&lt;/author&gt;<br />    &lt;available&gt;true&lt;/available&gt;<br />    &lt;cover&gt;PAPERBACK&lt;/cover&gt;<br />    &lt;id&gt;3&lt;/id&gt;<br />    &lt;publishedYear&gt;1937&lt;/publishedYear&gt;<br />    &lt;title&gt;The Hobbit&lt;/title&gt;<br />  &lt;/rows&gt;<br />&lt;/page&gt;<br /><br /></pre></div><div><br /></div><div>Response type defaults to XML if none is specified but if we add <a href="http://jackson.codehaus.org/">Jackson</a> library to the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">CLASSPATH</span>, Spring will pick it up and enable us to use JSON as well:</div><div><br /></div><div><pre class="brush: js"><br />// $ curl -v -H "Accept: application/json" "http://localhost:8080/books/rest/book?page=1&max=3"<br /><br />{<br />    "total":43,<br />    "max":3,<br />    "page":1,<br />    "rows":[<br />        {<br />            "id":1,<br />            "available":true,<br />            "author":"Charles Dickens",<br />            "title":"A Tale of Two Cities",<br />            "publishedYear":1859,<br />            "cover":"PAPERBACK",<br />            "comments":null<br />        },<br />        {<br />            "id":2,<br />            "available":true,<br />            "author":"J. R. R. Tolkien",<br />            "title":"The Lord of the Rings",<br />            "publishedYear":1954,<br />            "cover":"HARDCOVER",<br />            "comments":null<br />        },<br />        {<br />            "id":3,<br />            "available":true,<br />            "author":"J. R. R. Tolkien",<br />            "title":"The Hobbit",<br />            "publishedYear":1937,<br />            "cover":"PAPERBACK",<br />            "comments":null<br />        }<br />    ]<br />}<br /></pre></div><div><br /></div><div>Nice, now we can work on the front-end, hopefully not making our hands too dirty. With regards to HTML markup, this is all we need, seriously:</div><div><br /></div><div><pre class="brush: html"><br />&lt;table id="grid"&gt;&lt;/table&gt;<br />&lt;div id="pager"&gt;&lt;/div&gt;<br /><br /></pre></div><div><br /></div><div>Keep in mind that we will implement all CRUD operations, but still, this is all we need. No more HTML. Rest of the magic happens thanks to marvellous jqGrid library. Here is a basic setup:</div><div><br /></div><div></div><div><pre class="brush: js"><br />$("#grid")<br />    .jqGrid({<br />      url:'rest/book',<br />      colModel:[<br />        {name:'id', label: 'ID', formatter:'integer', width: 40},<br />        {name:'title', label: 'Title', width: 300},<br />        {name:'author', label: 'Author', width: 200},<br />        {name:'publishedYear', label: 'Published year', width: 80, align: 'center'},<br />        {name:'available', label: 'Available', formatter: 'checkbox', width: 46, align: 'center'}<br />      ],<br />      caption: "Books",<br />      pager : '#pager',<br />      height: 'auto'<br />    })<br />    .navGrid('#pager', {edit:false,add:false,del:false, search: false});<br /><br /></pre></div><div><br /></div><div>Technically, this is all we need. URL to fetch the data, pointing to our controller (jqGrid will perform all the AJAX magic for us) and the data model (you may recognize book fields and their descriptions). However, since jqGrid is highly customizable, I applied few tweaks to make the grid look a bit better. Also I didn't like suggested names of metadata, for instance <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">total</span>&nbsp;field returned from the server is suppose to be the total number of pages, not records – highly counter-intuitive. Here are my tweaked options:</div><div><br /></div><div><pre class="brush: js"><br />$.extend($.jgrid.defaults, {<br />  datatype: 'json',<br />  jsonReader : {<br />    repeatitems:false,<br />    total: function(result) {<br />      //Total number of pages<br />      return Math.ceil(result.total / result.max);<br />    },<br />    records: function(result) {<br />      //Total number of records<br />      return result.total;<br />    }<br />  },<br />  prmNames: {rows: 'max', search: null},<br />  height: 'auto',<br />  viewrecords: true,<br />  rowList: [10, 20, 50, 100],<br />  altRows: true,<br />  loadError: function(xhr, status, error) {<br />    alert(error);<br />  }<br />  });<br /><br /></pre></div><div><br /></div><div>Eager to see the results? Here is a browser screenshot:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-S_jCbvgAito/ThCgthzLOlI/AAAAAAAAAcY/z2FWNRGmdSw/s1600/popup.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="258" src="http://1.bp.blogspot.com/-S_jCbvgAito/ThCgthzLOlI/AAAAAAAAAcY/z2FWNRGmdSw/s320/popup.png" width="320" /></a></div><br /></div><div><br /></div><div>Good looking, with customizable paging, lightweight refreshing... And our hands are still relatively clean! But I promised CRUD... If you were careful, you have probably noticed few <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">navGrid</span> attributes, dying to be turned on:</div><div><br /></div><div><br /></div><div><pre class="brush: js"><br />var URL = 'rest/book';<br />var options = {<br />  url: URL,<br />  editurl: URL,<br />  colModel:[<br />    {<br />      name:'id', label: 'ID',<br />      formatter:'integer',<br />      width: 40,<br />      editable: true,<br />      editoptions: {disabled: true, size:5}<br />    },<br />    {<br />      name:'title',<br />      label: 'Title',<br />      width: 300,<br />      editable: true,<br />      editrules: {required: true}<br />    },<br />    {<br />      name:'author',<br />      label: 'Author',<br />      width: 200,<br />      editable: true,<br />      editrules: {required: true}<br />    },<br />    {<br />      name:'cover',<br />      label: 'Cover',<br />      hidden: true,<br />      editable: true,<br />      edittype: 'select',<br />      editrules: {edithidden:true},<br />      editoptions: {<br />        value: {'PAPERBACK': 'paperback', 'HARDCOVER': 'hardcover', 'DUST_JACKET': 'dust jacket'}<br />      }<br />    },<br />    {<br />      name:'publishedYear',<br />      label: 'Published year',<br />      width: 80,<br />      align: 'center',<br />      editable: true,<br />      editrules: {required: true, integer: true},<br />      editoptions: {size:5, maxlength: 4}<br />    },<br />    {<br />      name:'available',<br />      label: 'Available',<br />      formatter: 'checkbox',<br />      width: 46,<br />      align: 'center',<br />      editable: true,<br />      edittype: 'checkbox',<br />      editoptions: {value:"true:false"}<br />    },<br />    {<br />      name:'comments',<br />      label: 'Comments',<br />      hidden: true,<br />      editable: true,<br />      edittype: 'textarea',<br />      editrules: {edithidden:true}<br />    }<br />  ],<br />  caption: "Books",<br />  pager : '#pager',<br />  height: 'auto'<br />};<br />$("#grid")<br />    .jqGrid(options)<br />    .navGrid('#pager', {edit:true,add:true,del:true, search: false});<br /></pre></div><div><br /></div><div>The configuration is getting dangerously verbose, but there's nothing complicated out there – for each field we have added few additional attributes controlling how this field should be treated in edit mode. This includes what type of HTML input should represent it, validation rules, visibility, etc. But honestly, I believe it was worth it:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-E5f2LP5ZtQs/ThCg3iqQJcI/AAAAAAAAAcc/aKqjUPF6h8w/s1600/edit_validation_normal.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="258" src="http://2.bp.blogspot.com/-E5f2LP5ZtQs/ThCg3iqQJcI/AAAAAAAAAcc/aKqjUPF6h8w/s320/edit_validation_normal.png" width="320" /></a></div><br /></div><div><br /></div><div>This nicely looking edit window has been fully generated by jqGrid based on our edit options mentioned above, including validation logic. We can make some of the fields visible in the grid hidden/inactive in edit dialog (like <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">id</span>) and vice-versa (<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">cover</span> and <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">comments</span> are not present in the grid, however you can modify them). Also notice few new icons visible in bottom-left corner of the grid. Adding and deleting is possible as well – and we haven't written a single line of HTML/JSP/JavaScript (excluding jqGrid configuration object).</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-GrLAA3ArM44/ThChOrlOkOI/AAAAAAAAAcg/oVcWcydyOoA/s1600/del.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="258" src="http://2.bp.blogspot.com/-GrLAA3ArM44/ThChOrlOkOI/AAAAAAAAAcg/oVcWcydyOoA/s320/del.png" width="320" /></a></div><br /></div><div><br /></div><div>Of course we all know that <a href="http://www.codinghorror.com/blog/2005/08/the-user-interface-is-the-application.html"><i>The User Interface Is The Application</i></a>, and our interface is pretty good, however sometimes we really want a beautiful <b>and</b> working application. And currently the latter requirement is our Achilles' heel. Not because the back-end isn't ready, this is rather trivial:</div><div><br /></div><div><pre class="brush: java"><br />@Controller<br />@RequestMapping(value = "/book")<br />public class BookController {<br /><br />  private final Map&lt;Integer, Book&gt; books = new ConcurrentSkipListMap&lt;Integer, Book&gt;();<br /><br />  @RequestMapping(value = "/{id}", method = GET)<br />  public @ResponseBody Book read(@PathVariable("id") int id) {<br />    //...<br />  }<br /><br />  @RequestMapping(method = GET)<br />  public<br />  @ResponseBody<br />  Page&lt;Book&gt; listBooks(<br />      @RequestParam(value = "page", required = false, defaultValue = "1") int page,<br />      @RequestParam(value = "max", required = false, defaultValue = "20") int max) {<br />    //...<br />  }<br /><br />  @RequestMapping(value = "/{id}", method = PUT)<br />  @ResponseStatus(HttpStatus.NO_CONTENT)<br />  public void updateBook(@PathVariable("id") int id, @RequestBody Book book) {<br />    //...<br />  }<br /><br />  @RequestMapping(method = POST)<br />  public ResponseEntity&lt;String&gt; createBook(HttpServletRequest request, @RequestBody Book book) {<br />    //...<br />  }<br /><br />  @RequestMapping(value = "/{id}", method = DELETE)<br />  @ResponseStatus(HttpStatus.NO_CONTENT)<br />  public void deleteBook(@PathVariable("id") int id) {<br />    //...<br />  }<br /><br />}<br /></pre></div><div><br /></div><div>Server-side is ready, but when it comes to data manipulation on the client-side, jqGrid reveals its dirty secret – all the traffic to the server is sent using POST like this:</div><div><br /></div><div><pre class="brush: plain"><br />Content-Type: application/x-www-form-urlencoded in the following format:<br /><br />id=&title=And+Then+There+Were+None&author=Agatha+Christie&cover=PAPERBACK&publishedYear=1939&available=true&comments=&oper=add<br /></pre></div><div><br /></div><div>The last attribute (<span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">oper=add</span>) is crucial. Not really idiomatic REST, don't you think? If we could only use POST/PUT/DELETE appropriately and serialize data using JSON or XML... Modifying my server so that it is compliant with some JavaScript library (no matter how cool it is), seems like a last resort. Thankfully, everything can be <a href="http://www.trirand.com/jqgridwiki/doku.php?id=wiki:jqgriddocs">customized</a> with a moderate amount of work.</div><div><br /></div><div><pre class="brush: js"><br />$.extend($.jgrid.edit, {<br />      ajaxEditOptions: { contentType: "application/json" },<br />      mtype: 'PUT',<br />      serializeEditData: function(data) {<br />        delete data.oper;<br />        return JSON.stringify(data);<br />      }<br />    });<br />$.extend($.jgrid.del, {<br />      mtype: 'DELETE',<br />      serializeDelData: function() {<br />        return "";<br />      }<br />    });<br /><br />var URL = 'rest/book';<br />var options = {<br />  url: URL,<br />  //...<br />}<br /><br />var editOptions = {<br />  onclickSubmit: function(params, postdata) {<br />    params.url = URL + '/' + postdata.id;<br />  }<br />};<br />var addOptions = {mtype: "POST"};<br />var delOptions = {<br />  onclickSubmit: function(params, postdata) {<br />    params.url = URL + '/' + postdata;<br />  }<br />};<br /><br /><br />$("#grid")<br />    .jqGrid(options)<br />    .navGrid('#pager',<br />    {}, //options<br />    editOptions,<br />    addOptions,<br />    delOptions,<br />    {} // search options<br />);<br /></pre></div><div><br /></div><div>We have customized HTTP method per operation, serialization is handled using JSON and finally URLs for edit and delete operations are now suffixed with <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">/<i>record_id</i></span>. Now it not only looks, it works! Look at the browser interaction with the server (note different HTTP methods and URLs):</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-WdpIbN8QiJ8/ThChU-IlDQI/AAAAAAAAAck/k6A7fcL27_0/s1600/http.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="229" src="http://4.bp.blogspot.com/-WdpIbN8QiJ8/ThChU-IlDQI/AAAAAAAAAck/k6A7fcL27_0/s320/http.png" width="320" /></a></div><br /></div><div><br /></div><div>Here is an example of creating a new resource on browser side:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-zoFATrd62Gw/ThChbLCaiII/AAAAAAAAAco/DYbviVdqK-U/s1600/http_post.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="146" src="http://3.bp.blogspot.com/-zoFATrd62Gw/ThChbLCaiII/AAAAAAAAAco/DYbviVdqK-U/s320/http_post.png" width="320" /></a></div><br /></div><div><br /></div><div>To follow REST principles as closely as possible I return <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">201 Created</span> response code together with <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Location</span> header pointing to newly created resource. As you can see data is now being sent to the server in JSON format.</div><div><br /></div><div>To summarize, such an approach has plenty of advantages:</div><ul><li><div>GUI is very responsive, page  appears instantly (it can be a static resource served from <a href="http://en.wikipedia.org/wiki/Content_delivery_network">CDN</a>),  while data is loaded asynchronously via AJAX in lightweight JSON  format</div></li><li><div>We get CRUD operations for free</div></li><li><div>REST interface for other systems  is also for free</div><div></div><div><br />Compare this with any web framework  out there. And did I mention about this little cherry on our  JavaScript frosting: jqGrid is fully compliant with <a href="http://jqueryui.com/themeroller">jQuery  UI themes</a> and also supports internationalization. Here is the  same application with changed theme and language:</div></li></ul><div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-XCqyIzZ-N18/ThChhbYPODI/AAAAAAAAAcs/qjUfZo6pW5I/s1600/edit_validation_green.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="258" src="http://4.bp.blogspot.com/-XCqyIzZ-N18/ThChhbYPODI/AAAAAAAAAcs/qjUfZo6pW5I/s320/edit_validation_green.png" width="320" /></a></div><br /></div><div><br /></div><div>Full <a href="https://github.com/nurkiewicz/books">source code</a> is available on <a href="https://github.com/nurkiewicz">my</a> GitHub account. The application is self contained, just build it and deploy it to some servlet container.</div>