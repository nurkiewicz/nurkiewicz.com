---
layout: post
title: Promises and futures in Clojure
date: '2013-03-24T11:15:00.000+01:00'
author: Tomasz Nurkiewicz
tags:
- clojure
- concurrency
modified_time: '2013-04-02T23:40:02.373+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-2296222456006130476
blogger_orig_url: https://www.nurkiewicz.com/2013/03/promises-and-futures-in-clojure.html
---

Clojure, being <a href="http://clojure.org/rationale"><i>designed for concurrency</i></a> is a natural fit for our <a href="http://nurkiewicz.blogspot.com/2013/02/javautilconcurrentfuture-basics.html"><i>Back to the Future</i> series</a>. Moreover futures are supported out-of-the-box in Clojure. Last but not least, Clojure is the first language/library that draws a clear distinction between <i>futures</i> and <i>promises</i>. They are so similar that most platforms either support only futures or combine them. Clojure is very explicit here, which is good. Let's start from promises:<br /><br /><h2>Promises</h2>Promise is a thread-safe object that encapsulates immutable value. This value might not be available yet and can be <i>delivered</i> exactly once, from any thread, later. If other thread tries to <i>dereference</i> a promise before it's delivered, it'll block calling thread. If promise is already resolved (delivered), no blocking occurs at all. Promise can only be delivered once and can never change its value once set:<br /><br /><a name='more'></a><br /><br /><pre class="brush: java">(def answer (promise))<br /><br />@answer<br /><br />(deliver answer 42)<br /></pre><code>answer</code> is a <code>promise</code> var. Trying to dereference it using <code>@answer</code> or <code>(deref answer)</code> at this point will simply block. This or some other thread must first deliver some value to this promise (using <code>deliver</code> function). All threads blocked on <code>deref</code> will wake up and subsequent attempts to dereference this promise will return <code>42</code> immediately. Promise is thread safe and you cannot modify it later. Trying to deliver another value to <code>answer</code> is ignored.<br /><br /><h2>Futures</h2>Futures behave pretty much the same way in Clojure from user perspective - they are containers for a single value (of course it can be a <code>map</code> or <code>list</code> - but it should be immutable) and trying to dereference future before it is resolved blocks. Also just like promises, futures can only be resolved once and dereferencing resolved future has immediate effect. The difference between the two is semantic, not technical. Future represents background computation, typically in a thread pool while promise is just a simple container that can be delivered (filled) by anyone at any point in time. Typically there is no associated background processing or computation. It's more like an event we are waiting for (e.g. <a href="http://nurkiewicz.blogspot.com/2013/03/deferredresult-asynchronous-processing.html">JMS message reply we wait for</a>).<br /><br />That being said, let's start some asynchronous processing. <a href="http://nurkiewicz.blogspot.com/2013/03/futures-in-akka-with-scala.html">Similar to Akka</a>, underlying thread pool is implicit and we simply pass piece of code that we want to run in background. For example to calculate the sum of positive integers below ten million we can say:<br /><br /><pre class="brush: java">(let <br />    [sum (future (apply + (range 1e7)))] <br />    (println "Started...") <br />    (println "Done: " @sum)<br />)<br /></pre><code>sum</code> is the future instance. <code>"Started..."</code> message appears immediately as the computation started in background thread. But <code>@sum</code> is blocking and we actually have to wait a little bit<sup>1</sup> to see the <code>"Done: "</code> message and computation results. And here is where the greatest disappointment arrives: neither <a href="http://clojuredocs.org/clojure_core/clojure.core/future"><code>future</code></a> nor <a href="http://clojuredocs.org/clojure_core/clojure.core/promise"><code>promise</code></a> in Clojure supports listening for completion/failure asynchronously. The API is pretty much equivalent to <a href="http://nurkiewicz.blogspot.com/2013/02/javautilconcurrentfuture-basics.html">very limited <code>java.util.concurrent.Future&lt;T&gt;</code></a>. We can create <code>future</code>, <a href="http://clojuredocs.org/clojure_core/clojure.core/future-cancel"><code>cancel</code> it</a>, check whether it is <a href="http://clojuredocs.org/clojure_core/clojure.core/realized_q"><code>realized?</code> (resolved)</a> and block waiting for a value. Just like <code>Future&lt;T&gt;</code> in Java, as a matter of fact the result of <code>future</code> function even implements <code>java.util.concurrent.Future&lt;T&gt;</code>. As much as I love Clojure concurrency primitives like STM and agents, futures feel a bit underdeveloped. Lack of event-driven, asynchronous callbacks that are invoked whenever futures completes (notice that <a href="http://clojuredocs.org/clojure_core/clojure.core/add-watch"><code>add-watch</code></a> doesn't work futures - and is still in alpha) greatly reduces the usefulness of a future object. We can no longer:<br /><br /><ul><li>map futures to transform result value asynchronously</li><li>chain futures</li><li>translate list of futures to future of list</li><li>...and much more, see how <a href="http://nurkiewicz.blogspot.no/2013/02/javautilconcurrentfuture-basics.html">Akka does it</a> and <a href="http://nurkiewicz.blogspot.no/2013/02/advanced-listenablefuture-capabilities.html">Guava to some extent</a></li></ul>That's a shame and since it's not a technical difficulty but only a missing API, I hope to see support for completion listeners soon. For completeness here is a slightly bigger program using futures to concurrently fetch contents of several websites, foundation for our <a href="http://nurkiewicz.blogspot.no/2013/02/executorcompletionservice-in-practice.html">web crawling sample</a>:<br /><br /><pre class="brush: java">(let [<br />    top-sites `("www.google.com" "www.youtube.com" "www.yahoo.com" "www.msn.com")<br />    futures-list (doall (<br />            map #(<br />                future (slurp (str "http://" %))<br />            )<br />            top-sites<br />    ))<br />    contents (map deref futures-list)<br />    ]<br />(doseq [s contents] (println s))<br />)<br /></pre>Code above starts downloading contents of several websites concurrently. <code>map deref</code> waits for all results one after another and once all futures from <code>futures-list</code> all completed, <code>doseq</code> prints the contents (<code>contents</code> is a list of strings). <br /><br />One trap I felt into was the absence of <code>doall</code> (that forces lazy sequence evaluation) in my initial attempt. <code>map</code> produces lazy sequence out of <code>top-sites</code> list, which means <code>future</code> function is called only when given item of <code>futures-list</code> is first accessed. That's good. But each item is accessed for the first time only during <code>(map deref futures-list)</code>. This means that while waiting for first future to dereference, second future didn't even started yet! It starts when first future completes and we try to dereference the second one. That means that last future starts when all previous futures are already completed. To cut long story short, without <code>doall</code> that forces all futures to start immediately, our code runs sequentially, one future after another. The beauty of side effects.<br /><br /><sup>1</sup> - <del>BTW <code>(1L to 9999999L).sum</code> in Scala is faster by almost an order of magnitude, <i>just sayin'</i>...</del> - see comments by <i>Rave Star</i> below.  <script src="https://raw.github.com/gist/3983275/936845e66d98bb7c627684df7884f33b2cc368f5/syntaxhighlighter.js"></script>