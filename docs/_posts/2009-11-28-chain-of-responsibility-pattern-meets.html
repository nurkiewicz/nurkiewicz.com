---
layout: post
title: Chain of responsibility pattern meets Spring, JPA, Wicket and Apache CXF part
  1/2
date: '2009-11-28T19:24:00.009+01:00'
author: Tomasz Nurkiewicz
tags:
- jpa
- web services
- design patterns
- spring
modified_time: '2009-12-01T21:16:00.361+01:00'
thumbnail: http://4.bp.blogspot.com/_P3ewsGQzHn0/SxFvAOiwFpI/AAAAAAAAAPY/QTr0O25eO_0/s72-c/ok.png
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-864940446407161601
blogger_orig_url: https://www.nurkiewicz.com/2009/11/chain-of-responsibility-pattern-meets.html
---

Chain of responsibility behavioral design pattern is a wonderful solution for complex logic of processing a requests. In this pattern single request (message, database record, external system call, etc.) is being passed to the first handler in the chain. This handler can:<br /><br /><ul><li>process request and return result</li><li>process request partially and run subsequent handler</li><li>ignore the request and pass the control further as above</li><li>run next handler and, after it returns, process already handled request</li><li>simply return, without processing and passing control down the chain</li><li>throw an exception</li></ul><br />Of course, if the first handler decides to pass control down the chain to the second one, the second handler has the same set of options. The most important feature of handlers is that each handler is only aware of itself – it does not know its position in chain (whether it is first, last or somewhere in the middle) and particularly not know what is the next handler down the chain. Because each handler is available only through the same abstract interface, this design promotes louse coupling (handlers are independent of each other) and high cohesion (every handler has one, well known responsibility).<br /><br />So, what is this chain after all? Actually, it is just a ordered list of handlers. The biggest advantage of the pattern is that this list can be easily modified. You may change the order, remove or add handlers in no time, altering the system behavior. Although some combinations of handlers in chain will be incorrect (as we will see later), ability to change the chain without changing lots of code makes the system very flexible.<br /><br />The last important thing to mention are the scenarios in which this pattern can work. In the first variation, each handler has only two options: either handler the request and return result or ignore request and pass control down the chain. In the second variation (which I have chosen for the example) chain works more like a <a href="http://java.sun.com/blueprints/patterns/InterceptingFilter.html">filter</a>, where each handler alters the request and/or has some side effects, but no handler (except the special last one) fully takes care of the message.<br /><br />Enough of theory, this is our artificial example: we are designing a web service for registering car. There are at least two business steps in this process: storing a car data passed to WS (this is our request, also called the message) in the database and registering the in Car Department using their remote EJB. There is also lots of technical steps: logging, validation, exception handling, transactions, profiling, timeouts, retrying, etc. Good design would promote louse coupling, so all this steps should be decoupled (AOP, anybody?). Also, some steps are optional and the order of others is not obvious. Besides, some other business routines are planned to be added in the future, so web service implementation must be very flexible.<br /><br />Let us start from the handler abstraction:<br /><br /><pre class="brush: java">public interface RegistrationChainHandler {<br />   long handle(Car car, RegistrationChain chain) throws Exception;<br />}</pre><br /><br />Seems very straightforward: handler takes the argument of the message type (<span style="font-family:courier new;">Car </span>POJO  in this case) and returns the chain result value (some id). But what is this <span style="font-family:courier new;">RegistrationChain</span>? In classic chain of responsibility pattern each handler simply has a reference to the next handler in chain. I found this approach less flexible to the one I present. So, what this object after all? In short, RegistrationChain is a simple wrapper around handlers list, remembering the position (next handler to be executed; see <a href="http://en.wikipedia.org/wiki/Iterator_pattern">Iterator</a> pattern). By invoking its <span style="font-family:courier new;">proceed()</span> method we simply ask it to run next handler in chain. Here is a part of not-so-obvious implementation:<br /><br /><pre class="brush: java; highlight: [9]">public class RegistrationChain {<br />   private final ListIterator&lt;RegistrationChainHandler&gt; currentHandlerIter;<br /><br />   public long proceed(Car car) throws Exception {<br />       if (!currentHandlerIter.hasNext())<br />           return handleEndOfChain();<br />       RegistrationChainHandler handler = currentHandlerIter.next();<br />       try {<br />           return handler.handle(car, this);<br />       } finally {<br />           currentHandlerIter.previous();<br />       }<br />   }<br /><br />   protected long handleEndOfChain() {<br />       throw new IllegalStateException("No handler fulfilled the request");<br />   }<br /><br />}</pre><br /><br />The <span style="font-family:courier new;">proceed()</span> method first tries to obtain next handler from the chain. If no such exists, <span style="font-family:courier new;">handleEndOfChain()</span> method is called. Of course, I could simply throw an exception directly from <span style="font-family:courier new;">proceed()</span>, but doing so from protected method allows user to alter the end of chain behavior by subclassing the <span style="font-family:courier new;">RegistrationChain</span>. This is a good practice following <a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open/closed principle</a>.<br /><br />If the handler is found, its <span style="font-family:courier new;">handle()</span> method is being called and the return value returned further. This is not complicated if you think for a while: handler A calls <span style="font-family:courier new;">proceed()</span> method inside its <span style="font-family:courier new;">handle()</span> method. The <span style="font-family:courier new;">proceed()</span> method finds handler B succeeding A and runs its <span style="font-family:courier new;">handle()</span> method passing itself as a second argument. The cycle repeats.<br /><br />Only the finally clause might not be obvious at first. Think about aforementioned chain <span style="font-style: italic;">A</span> -&gt; <span style="font-style: italic;">B</span> -&gt; <span style="font-style: italic;">C</span>. If handler <span style="font-style: italic;">A</span> calls <span style="font-family:courier new;">proceed()</span>, <span style="font-family:courier new;">B.handle()</span> is being called and chain iterator forwards. If <span style="font-family:courier new;">B.handle()</span> calls <span style="font-family:courier new;">proceed()</span>, chain will call <span style="font-family:courier new;">C.handle()</span>, as this is the next handler in chain. If the chain iterator only forwards, why move it back when returning? Let’s move a bit further. When <span style="font-family:courier new;">A.handle()</span> call to <span style="font-family:courier new;">proceed()</span> finishes, what would be the position of chain iterator? Without going back after each <span style="font-family:courier new;">proceed()</span>, it would point to some undetermined place in the chain (probably past the end). Now think what would happen if <span style="font-family:courier new;">A.handle()</span>, for some reason, calls <span style="font-family:courier new;">proceed()</span> once again? You would expect to re-run the chain starting from <span style="font-style: italic;">B</span>, but the next handler iterator points "somewhere"... Think about it, as this is the cause for moving the iterator back.<br /><br />We have the infrastructure, it is time for real implementation. First, two main business processes: storing car in database using JPA and accessing remote EJB:<br /><br /><pre class="brush: java">public class StoreCarHandler implements RegistrationChainHandler {<br />   @PersistenceContext<br />   private EntityManager em;<br /><br />   @Override<br />   @Transactional(propagation = Propagation.MANDATORY)<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       em.persist(car);<br />       return chain.proceed(car);<br />   }<br />}</pre><br /><br />As you can see, <span style="font-family:courier new;">MANDATORY</span> transaction propagation level has been used to ensure the method runs within a transaction and fails if not. Transaction management will be held by different handler.<br /><br /><pre class="brush: java">public class RegisterInCarDeptHandler implements RegistrationChainHandler {<br /><br />   @Resource<br />   private CarRegisterRemote carRegisterRemote;<br /><br />   @Override<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       String carDeptId = carRegisterRemote.register(car.getRegistrationNo(), car.getEngineCapacity().doubleValue());<br />       car.setCarDeptId(carDeptId);<br />       return chain.proceed(car);<br />   }<br />}</pre><br /><br />This handler uses remote EJB proxy injected by Spring and runs its business method. Value returned from this method is then assigned to the car being processed. There are also several other handlers having different, well specified responsibilities:<br /><br /><pre class="brush: java">public class ValidationHandler implements RegistrationChainHandler {<br /><br />   @Override<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       Validate.notNull(car, "Car can't be null");<br />       Validate.notEmpty(car.getRegistrationNo(), "Registration number can't be empty");<br />       Validate.notNull(car.getColor(), "Color can't be null");<br />       Validate.notNull(car.getEngineCapacity(), "Engine capacity can't be null");<br />       Validate.notNull(car.getWeight(), "Weight can't be null");<br />       return chain.proceed(car);<br />   }<br />}</pre><br /><br />This handler simply validates input argument. You might consider this as assertion.<br />Logging handler simply logs input argument:<br /><br /><pre class="brush: java">public class LoggingHandler implements RegistrationChainHandler {<br /><br />   private static final Logger log = LoggerFactory.getLogger(LoggingHandler.class);<br /><br />   @Override<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       log.debug("Processing car: {}", car);<br />       return chain.proceed(car);<br />   }<br />}</pre><br /><br />This handler uses <a href="http://perf4j.codehaus.org/">Perf4j</a> to monitor the time of remaining part of chain execution. Perf4j is a wonderful tool for measuring your application performance and gathering statistics. I will try to write something more about it in the future. By using different tag attribute values you might create several copies of this handler and monitor different parts of the chain:<br /><br /><pre class="brush: java">public class Perf4jHandler implements RegistrationChainHandler {<br /><br />   private String tag;<br /><br />   @PostConstruct<br />   public void init() {<br />       if(StringUtils.isBlank(tag))<br />       tag = Perf4jHandler.class.getName();<br />   }<br /><br />   @Override<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       StopWatch watch = new Slf4JStopWatch(tag);<br />       try {<br />           return chain.proceed(car);<br />       } finally {<br />           watch.stop();<br />       }<br />   }<br /><br />   public void setTag(String tag) {<br />       this.tag = tag;<br />   }<br />}</pre><br /><br />Exception translation is a common pattern used to hide the details of your system and provide less verbose messages to the client. Surely, you don’t want to expose parts of your SQL or JMS queues names, etc., which often occur in exception messages.<br /><br /><pre class="brush: java">public class ExceptionTranslatorHandler implements RegistrationChainHandler {<br /><br />   @Override<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       try {<br />           return chain.proceed(car);<br />       } catch (CarRegistrationException e) {<br />           throw e;<br />       } catch (Exception e) {<br />           throw new CarRegistrationException("Error while registering car", e);<br />       }<br />   }<br />}</pre><br /><br />Two handlers that left are particularly important. The first one handles transactions, which was already mentioned:<br /><br /><pre class="brush: java">public class TransactionalHandler implements RegistrationChainHandler {<br /><br />   @Override<br />   @Transactional<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       return chain.proceed(car);<br />   }<br />}</pre><br /><br />That’s it! <a href="http://nurkiewicz.com/2009/08/spring-aop-riddle.html">@Transactional</a> annotation around <span style="font-family:courier new;">handle()</span> handles transaction transparently, so all the handlers down the chain are run within this transaction. The reason to have a separate handler for that instead of putting the transaction directly over <span style="font-family:courier new;">StoreCarHandler</span> is to have a better control over transaction boundaries (the handler can be put anywhere in the chain). Also, it makes the example more interesting :-).<br /><br />If you look closely to the implementations of all handlers and <span style="font-family:courier new;">RegistrationChain</span>, you will notice that the chain never ends... Every handler passed the control further and does not take responsibility of handling the car completely. Although I found it more flexible (no handler is obligated to be the last, because it will never pass control), we need a way to successfully stop processing. This can be done on RegistrationChain level (by overriding <span style="font-family:courier new;">handleEndOfChain()</span>, see above), but I chose to have a special catch-all handler:<br /><br /><pre class="brush: java">public class CatchAllHandler implements RegistrationChainHandler {<br />   private boolean fail;<br />   private String failMessage;<br /><br />   @Override<br />   public long handle(Car car, RegistrationChain chain) throws Exception {<br />       if(fail)<br />           throw new IllegalStateException(failMessage);<br />       return car.getId();<br />   }<br /><br />   public void setFail(boolean fail) {<br />       this.fail = fail;<br />   }<br />}</pre><br /><br />This handler can also be used to stop processing with exception, depending on configuration. The last, but most sophisticated handler has been added when our client requested us to provide some time SLA for the web service method. Although HTTP timeouts could have been used, we decided to implement our own mechanism, so it can be reused in the future.<br />This handler instead of running <span style="font-family:courier new;">proceed()</span> method immediately, creates a <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/Callable.html">Callable&lt;Long&gt;</a> instance wrapping it (<a href="http://nurkiewicz.com/2009/09/adapter-pattern-accesing-ehcache-via.html">Adapter</a> pattern!) and submitting to the thread pool. Then, using <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/Future.html">Future&lt;Long&gt;</a> we wait configured time for the result. If the task reaches the available thread in pool and is fully executed (it means, all handlers below are run), everything works transparently for the client. But if the invocation has not finished and the timeout is reached, client will get only error message.<br /><br /><pre class="brush: java">public class HandlerWithTimeout implements RegistrationChainHandler {<br /><br />   @Resource<br />   private ExecutorService executorService;<br />   private long timeoutInMillis = 5000;<br /><br />   @Override<br />   public long handle(final Car car, final RegistrationChain chain) throws Exception {<br />       Future&lt;Long&gt; registrationResult = executorService.submit(new Callable&lt;Long&gt;() {<br />           @Override<br />           public Long call() throws Exception {<br />              return chain.proceed(car);<br />           }});<br /><br />       try {<br />           return registrationResult.get(timeoutInMillis, TimeUnit.MILLISECONDS);<br />       } catch (ExecutionException e) {<br />           if(e.getCause() instanceof Exception)<br />              throw ((Exception) e.getCause());<br />           else<br />              throw new CarRegistrationException(e.getCause());<br />       } catch (TimeoutException e) {<br />           registrationResult.cancel(true);<br />           throw new CarRegistrationException("Registration did not finished after " + timeoutInMillis + "ms");<br />       }<br />   }<br />}</pre><br /><br /><br />That was a lot of code! Let us get everything together and test it. First we define web service interface and implementation:<br /><br /><pre class="brush: java">@WebService<br />public interface CarRegistrationWs {<br />   long registerCar(Car car);<br />}</pre><br /><br /><pre class="brush: java">public class CarRegistrationWsImpl implements CarRegistrationWs {<br />   @Override<br />   public long registerCar(Car car) {<br />       return car.register();<br />   }<br />}</pre><br /><br />Not much, everything interesting happens in <span style="font-family:courier new;">Car</span> entity. Actually, in real implementation I used <a href="http://en.wikipedia.org/wiki/Data_transfer_object">DTO</a> structural design pattern for WS argument, which is slightly different than the JPA <span style="font-family:courier new;">Car</span> POJO, but this is not important. Since <span style="font-family:courier new;">Car</span> is a JPA entity, I use <a href="http://nurkiewicz.com/2009/10/ddd-in-spring-made-easy-with-aspectj.html">@Configurable</a> annotation to inject the chain. The traditional way would be to have <span style="font-family:courier new;">CarService.register(Car)</span> service layer object, but isn’t running <span style="font-family:courier new;">Car.register()</span> more fun?<br /><br /><br /><pre class="brush: java">@Configurable<br />public class Car implements Serializable {<br /><br />   private List&lt;RegistrationChainHandler&gt; handlers;<br /><br />   public void setHandlers(List&lt;RegistrationChainHandler&gt; handlers) {<br />       this.handlers = handlers;<br />   }<br /><br />   public long register() {<br />       try {<br />           return new RegistrationChain(handlers).proceed(this);<br />       } catch (CarRegistrationException e) {<br />           throw e;<br />       } catch (RuntimeException e) {<br />           throw e;<br />       } catch (Exception e) {<br />           throw new RuntimeException(e);<br />       }<br /><br />   }<br />   /*  */<br />}</pre><br /><br />The final touch is a piece of code in, well, Spring XML:<br /><br /><pre class="brush: xml">&lt;bean id="carRegistrationWs" class="com.blogspot.nurkiewicz.cars.registration.ws.CarRegistrationWsImpl"/&gt;<br />&lt;jaxws:endpoint id="helloWorld" implementor="#carRegistrationWs" address="/Registration"/&gt;<br /><br />&lt;bean id="car" class="com.blogspot.nurkiewicz.cars.Car" scope="prototype" lazy-init="true"&gt;<br />   &lt;property name="handlers" ref="handlersList"/&gt;<br />&lt;/bean&gt;<br /> <br />&lt;util:list id="handlersList"&gt;<br />   &lt;ref bean="exceptionTranslatorHandler"/&gt;<br />   &lt;ref bean="validationHandler"/&gt;<br />   &lt;ref bean="handlerWithTimeout"/&gt;<br />   &lt;ref bean="perf4jHandler"/&gt;<br />   &lt;ref bean="loggingHandler"/&gt;<br />   &lt;ref bean="transactionalHandler"/&gt;<br />   &lt;ref bean="storeCarHandler"/&gt;<br />   &lt;ref bean="registerInCarDeptHandler"/&gt;<br />   &lt;ref bean="catchAllHandler"/&gt;<br />&lt;/util:list&gt;<br /></pre><br /><br />First bean is the web service implementation. Second one creates a web service endpoint and publishes it under given name.  As you can see Apache CXF is very easy to set up. CXF-Spring integration is briefly covered <a href="http://cwiki.apache.org/CXF20DOC/writing-a-service-with-spring.html">here</a>, also remember to <a href="http://www.techper.net/2008/01/30/configuring-cxf-logging-to-go-through-log4j">configure CXF to use Log4j</a>.<br /><br />As you probably guessed, the <span style="font-family:courier new;">handlersList</span> is our chain configuration. Each handler shown before is actually a Spring bean, which is very helpful: for example I can easily inject remote EJB proxy or ExecutorService for asynchronous invocation. Managing the whole business process is just a matter of manipulating this list.<br /><br />Finally! – I run the application using <span style="font-family:courier new;">mvn jetty:run</span> and immediately browse to <a href="http://localhost:8080/cars/ws/Registration?WSDL">http://localhost:8080/cars/ws/Registration?WSDL</a>. Seems everything is OK, so I run <a href="http://www.soapui.org/">SoapUI</a> for some functional testing. Pasting the WSDL above and filling the example request XML is enough to see the chain in action:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_P3ewsGQzHn0/SxFvAOiwFpI/AAAAAAAAAPY/QTr0O25eO_0/s1600/ok.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 74px;" src="http://4.bp.blogspot.com/_P3ewsGQzHn0/SxFvAOiwFpI/AAAAAAAAAPY/QTr0O25eO_0/s200/ok.png" alt="" id="BLOGGER_PHOTO_ID_5409226677143213714" border="0" /></a>On the right there is a response with car unique id, obtained in StoreCarHandler. If I look into the application logs, I see every handler in chain being invoked successfully. Now, I remove the &lt;weight&gt; tag causing corresponding Car attribute to be null:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_P3ewsGQzHn0/SxFvM9ZIMNI/AAAAAAAAAPg/8jfjuXwFqLQ/s1600/validation.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 74px;" src="http://3.bp.blogspot.com/_P3ewsGQzHn0/SxFvM9ZIMNI/AAAAAAAAAPg/8jfjuXwFqLQ/s200/validation.png" alt="" id="BLOGGER_PHOTO_ID_5409226895877746898" border="0" /></a>Great, ValidationHandler worked and if you took a closer look at the application logs, no further  handlers were invoked, stopping the process. But now let us play a bit with the chain itself. First, I turn off TransactionalHandler to see whether MANDATORY propagation works. By "turning off" I mean removing from handlersList in Spring context file. Quick application restart and...<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_P3ewsGQzHn0/SxFvZ8aFSFI/AAAAAAAAAPo/24PEzqtpe_I/s1600/error_short.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 74px;" src="http://4.bp.blogspot.com/_P3ewsGQzHn0/SxFvZ8aFSFI/AAAAAAAAAPo/24PEzqtpe_I/s200/error_short.png" alt="" id="BLOGGER_PHOTO_ID_5409227118951614546" border="0" /></a>The error message isn’t very descriptive, hiding the true cause of the problem. If you feel your application should be more verbose, simply turn off ExceptionTranslatorHandler, and after restarting the same message will produce:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxFvk3bP48I/AAAAAAAAAPw/r0Av7t7s8Cg/s1600/error_verbose.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 200px; height: 74px;" src="http://2.bp.blogspot.com/_P3ewsGQzHn0/SxFvk3bP48I/AAAAAAAAAPw/r0Av7t7s8Cg/s200/error_verbose.png" alt="" id="BLOGGER_PHOTO_ID_5409227306592887746" border="0" /></a>Even though I have shown a negative example of how to break the application by inappropriately modifying the chain, this simple case study still gives you a lot of flexibility. For example whether LoggingHandler should go before or rather after ValidationHandler? The other open question is the place to put Perf4jHandler. Because part of the request is processed asynchronously in a thread pool, should we measure only the time the task was executed (Perf4jHandler after HandlerWithTimeout) or maybe whole processing time (including the time the task spent in queue, waiting for available thread while all are busy – the opposite sequence of handlers). Or maybe we should duplicate Perf4jHandler and monitor both, because significant difference would mean that many executions are awaiting in queues...<br /><br />That is all about chain of responsibility pattern – in this part of the article. To sum things up, advantages of the chain of responsibility pattern are:<br /><ul><li><span style="font-weight: bold;">Flexibility </span>– chain can be easily configured, altering the system behavior without or with a little modification in code</li><li><span style="font-weight: bold;">Testability</span> – thanks to louse coupling promoted by this pattern each handler can be unit tested as well as easy integration testing of any handlers combination</li><li><span style="font-weight: bold;">Readability</span> – It is much easier to read a single class focused on one purpose rather than having a big class, even properly divided into methods</li><li><span style="font-weight: bold;">Maintainability</span> – adding, removing and changing the order of handlers is very easy. Also modifying existing handlers is easier</li><li>...also logging, profiling, etc. is centralized in a single place (RegistrationChain)</li></ul><br />Disadvantages:<br /><ul><li>Some people find it harder (?) to follow the process when it is split into several classes, especially when the order is configured somewhere else</li><li>Wrong chain configuration might harm the application, I showed an example</li></ul><br />I hope you felt a bit annoyed by the need of restarting the application after each chain modification. I also hope you were disappointed about how primitive this process was (modifying Spring XML). All your concerns are going to be addressed in the <a href="http://nurkiewicz.com/2009/12/chain-of-responsibility-pattern-meets.html">second part</a> (did you notice Wicket in the title?) And in the mean time feel free to ask questions about this wonderful pattern.