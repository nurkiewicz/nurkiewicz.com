---
layout: post
title: Configuring Quartz with JDBCJobStore in Spring
date: '2012-04-01T22:42:00.000+02:00'
author: Tomasz Nurkiewicz
tags:
- spring
- quartz
modified_time: '2012-04-01T22:42:20.451+02:00'
blogger_id: tag:blogger.com,1999:blog-6753769565491687768.post-4839418424844112322
blogger_orig_url: https://www.nurkiewicz.com/2012/04/configuring-quartz-with-jdbcjobstore-in.html
---

I am starting a little series about <a href="http://quartz-scheduler.org/">Quartz scheduler</a> internals, tips and tricks, this is a chapter 0 - how to configure persistent job store. In Quartz you essentially have a choice between storing jobs and triggers in memory and in a relation database (<a href="http://terracotta.org/"> Terracotta</a> is a recent addition to the mix). I would say in 90% of the cases when you use <code>RAMJobStore</code> with Quartz you don't really need Quartz at all. Obviously this storage backend is transient and all your pending jobs and triggers are lost between restarts. If you are fine with that, much simpler and more lightweight solutions are available, including <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html"><code>ScheduledExecutorService</code></a> built into JDK and <code>@Scheduled(cron="*/5 * * * * MON-FRI")</code> in Spring. Can you justify using extra 0,5MiB JAR in this scenario? <br /><br />This changes dramatically when you need clustering, fail-over, load-balancing and few other buzz-words. There are several use-cases for that: <br /><ul><li>single server cannot handle required number of concurrent, long running jobs and the executions need to be split into several machines - but each task must be executed exactly ones</li><li>we cannot afford to run jobs too late - if one server is down, another should run the job on time</li><li>...or less strictly - the job needs to run <b>eventually</b> - even if the one and only server was down for maintenance, delayed jobs need to be run as soon as possible after restart</li></ul>In all cases above we need some sort of non-transient global storage to keep track which jobs were executed, so that they are run exactly ones by one machine. Relational database as a shared memory works good in this scenario. <br /><br />So if you think you need to schedule jobs and have some of the requirements above, keep reading. I will show you how to configure Quartz with Spring and fully integrate them. First of all we need a <code>DataSource</code>:  <br /><pre class="brush: scala">import org.apache.commons.dbcp.BasicDataSource<br />import com.googlecode.flyway.core.Flyway<br />import org.jdbcdslog.DataSourceProxy<br />import org.springframework.jdbc.datasource.{DataSourceTransactionManager, LazyConnectionDataSourceProxy}<br />import org.h2.Driver<br /><br />@Configuration<br />@EnableTransactionManagement<br />class Persistence {<br /><br />    @Bean<br />    def transactionManager() = new DataSourceTransactionManager(dataSource())<br /><br />    @Bean<br />    @Primary<br />    def dataSource() = {<br />        val proxy = new DataSourceProxy()<br />        proxy.setTargetDSDirect(dbcpDataSource())<br />        new LazyConnectionDataSourceProxy(proxy)<br />    }<br /><br />    @Bean(destroyMethod = "close")<br />    def dbcpDataSource() = {<br />        val dataSource = new BasicDataSource<br />        dataSource.setDriverClassName(classOf[Driver].getName)<br />        dataSource.setUrl("jdbc:h2:mem:quartz-demo;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MVCC=TRUE")<br />        dataSource.setUsername("sa")<br />        dataSource.setPassword("")<br />        dataSource.setMaxActive(20)<br />        dataSource.setMaxIdle(20)<br />        dataSource.setMaxWait(10000)<br />        dataSource.setInitialSize(5)<br />        dataSource.setValidationQuery("SELECT 1")<br />        dataSource<br />    }<br /><br />}<br /></pre>As you might have guessed, Quartz needs some database tables to work with. It does not create them automatically, but SQL scripts for several databases are provided, including H2 which as you can see I am using. I think <a href="http://code.google.com/p/flyway">Flyway</a> is the easiest way to run database scripts on startup:  <br /><a name='more'></a><br /><pre class="brush: scala">@Bean(initMethod = "migrate")<br />def flyway() = {<br /> val fly = new Flyway()<br /> fly.setDataSource(dataSource())<br /> fly<br />}<br /></pre>BTW in case you haven't noticed: no, there is no XML in our sample application and yes, we are using Spring. <br /><br />Let's move on to Quartz: <br /><pre class="brush: scala; highlight: [16,22]">@Configuration<br />class Scheduling {<br /><br />    @Resource<br />    val persistence: Persistence = null<br /><br />    @Bean<br />    @DependsOn(Array("flyway"))<br />    def schedulerFactory() = {<br />        val schedulerFactoryBean = new SchedulerFactoryBean()<br />        schedulerFactoryBean.setDataSource(persistence.dataSource())<br />        schedulerFactoryBean.setTransactionManager(persistence.transactionManager())<br />        schedulerFactoryBean.setConfigLocation(new ClassPathResource("quartz.properties"))<br />        schedulerFactoryBean.setJobFactory(jobFactory())<br />        schedulerFactoryBean.setApplicationContextSchedulerContextKey("applicationContext")<br />        schedulerFactoryBean.setSchedulerContextAsMap(Map().asJava)<br />        schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true)<br />        schedulerFactoryBean<br />    }<br /><br />    @Bean<br />    def jobFactory() = new SpringBeanJobFactory<br /><br />}<br /></pre>It is nice to know you can inject instance of <code>@Configuration</code> annotated classes into another such class for convenience. Except that - nothing fancy. Note that we need <code>@DependsOn(Array("flyway"))</code> on Quartz scheduler factory - otherwise the scheduler might start before Flyway fired the migration script with Quartz database tables causing unpleasant errors on startup. The essential bits are <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/quartz/SpringBeanJobFactory.html"><code>SpringBeanJobFactory</code></a> and <code>schedulerContextAsMap</code>. The special factory makes Spring responsible for creating <code>Job</code> instances. Unfortunately this factory is quite limited which we will see shortly in the following example. First we need a Spring bean and a Quartz job:  <br /><pre class="brush: scala">@Service<br />class Printer extends Logging {<br /><br />    def print(msg: String) {<br />        logger.info(msg)<br />    }<br /><br />}<br /><br />class PrintMessageJob extends Job with Logging {<br /><br />    @BeanProperty<br />    var printer: Printer = _<br /><br />    @BeanProperty<br />    var msg = ""<br /><br />    def execute(context: JobExecutionContext) {<br />        printer print msg<br />    }<br />}<br /></pre>First unexpected input is <code>@BeanProperty</code> instead of <code>@Autowired</code> or <code>@Resource</code>. Turns out that <code>Job</code> is not really a Spring bean, even though Spring creates an instance of it. Instead Spring discovers required dependencies using available setters. So where does the <code>msg</code> string come from? Keep going:  <br /><pre class="brush: scala; highlight: 12">val trigger = newTrigger().<br />        withIdentity("Every-few-seconds", "Demo").<br />        withSchedule(<br />            simpleSchedule().<br />                    withIntervalInSeconds(4).<br />                    repeatForever()<br />        ).<br />        build()<br /><br />val job = newJob(classOf[PrintMessageJob]).<br />        withIdentity("Print-message", "Demo").<br />        usingJobData("msg", "Hello, world!").<br />        build()<br /><br />scheduler.scheduleJob(job, trigger)<br /></pre>Quartz 2.0 ships with a nice internal DSL for creating jobs and triggers in a readable manner. As you can see I am passing an extra <code>"Hello, world!"</code> parameter to the job. This parameter is stored in so called <code>JobData</code> in the database per job or per trigger. It will be provided to the job when it is executed. This way you can parametrize your jobs. However when executed our job throws <code>NullPointerException</code>... Apparently <code> printer</code> reference was not set and silently ignored. Turns out Spring won't simply look through all the beans available in the <code>ApplicationContext</code>. The <code>SpringBeanJobFactory</code> only looks into <code>Jobs'</code> and <code>Triggers'</code> <code>JobData</code> and into so called scheduler context (already mentioned). If you want to inject any Spring bean into <code>Job</code> you must explicitly place a reference to that bean in <code>schedulerContext</code>:  <br /><pre class="brush: scala">@Configuration<br />class Scheduling {<br /><br />    @Resource<br />    val printer: Printer = null<br /><br />    @Bean<br />    def schedulerFactory() = {<br />        val schedulerFactoryBean = new SchedulerFactoryBean()<br />        //...<br />        schedulerFactoryBean.setSchedulerContextAsMap(schedulerContextMap().asJava)<br />        //...<br />        schedulerFactoryBean<br />    }<br /><br />    def schedulerContextMap() =<br />        Map(<br />            "printer" -&gt; printer<br />        )<br /><br />}<br /></pre>Unfortunately each and every Spring bean you want to inject to job has to be explicitly referenced in <code> schedulerContextMap</code>. Even worse, if you forget about it, Quartz will silently log NPE at runtime. In the future we will write more robust job factory. But for starters we have a working Spring + Quartz application ready for further experiments, <a href="https://github.com/nurkiewicz/quartz-demo">sources</a> as always available under my GitHub account. <br /><br />You might ask yourself way can't we simply use <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-quartz-method-invoking-job">MethodInvokingJobDetailFactoryBean</a>? Well, first of all because it <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/scheduling/quartz/MethodInvokingJobDetailFactoryBean.html">does not work</a> with persistent job stores. Secondly - because it is unable to pass <code>JobData</code> to <code>Job</code> - so we can no longer distinguish between different job runs. For instance our job printing message would have to always print the same message hard-coded in the class. <br /><br />BTW if anyone asks you: <i>How many classes does a Java enterprise developer need to print â€œHello world!"</i> you can proudly reply: <i>4 classes, 30 JARs taking 20 MiB of space and a relational database with 10+ tables</i>. Seriously, this is an output of our article here...