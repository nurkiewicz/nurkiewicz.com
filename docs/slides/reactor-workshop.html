<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Reactor Workshop</title>

	<meta name="author" content="Tomasz Nurkiewicz">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/night.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">

			<section>
				<h1>Reactor workshop</h1>
				<h2>
					Exercises:
					<a href="https://github.com/nurkiewicz/reactor-workshop">github.com/nurkiewicz/reactor-workshop</a>
				</h2>
				<p>
					<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd> to search
				</p>
				<p>
					Use arrow keys to navigate slides
				</p>
				<p>
					<a href="https://github.com/nurkiewicz/nurkiewicz.com/blob/master/docs/slides/reactor-workshop.html">edit slides on GitHub</a>
				</p>
			</section>

			<section data-visibility="hidden">
				<ul>
					<li>9:00 -  9:50</li>
					<li>10:00 - 10:50</li>
					<li>11:00 - 11:50</li>
					<li>12:00 - 13:00</li>
					<li>13:00 - 13:45 (lunch)</li>
					<li>13:45 - 14:30</li>
					<li>14:40 - 15:25</li>
					<li>15:35 - 16:15</li>
					<li>16:25 - 17:00</li>
				</ul>
			</section>

			<section>
				<h1>Quick links</h1>
				<small>
					<div style="display: flex">
						<div style="flex: 1">
							<ul>
								<li><a href="#Blocking-code">Blocking code</a></li>
								<li><a href="#Classic-future">Classic Future</a></li>
								<li><a href="#Mono-and-Flux">Mono and Flux</a></li>
								<li><a href="#Hot-cold">Hot vs. cold</a></li>
								<li><a href="#block"><code>block()</code></a></li>
								<li><a href="#just"><code>just()</code></a></li>
								<li><a href="#defer"><code>defer()</code></a></li>
								<li><a href="#collectList"><code>collectList()</code></a></li>
								<li><a href="#buffering-operators"><code>Buffering operators</code></a></li>
								<li><a href="#map"><code>map()</code></a></li>
								<li><a href="#flatMap"><code>flatMap()</code></a></li>
								<li><a href="#zip"><code>zip()</code></a></li>
								<li><a href="#timeout"><code>timeout()</code></a></li>
								<li><a href="#onError">onError<code>*()</a></code></li>
								<li><a href="#filterWhen"><code>filterWhen()</code></a></li>
							</ul>
						</div>
						<div style="flex: 1">
							<ul>
								<li><a href="#doOnSubscribe"><code>doOnSubscribe()</code></a></li>
								<li><a href="#Side-effects">Side effects</a></li>
								<li><a href="#window"><code>window()</code></a></li>
								<li><a href="#interval"><code>interval()</code></a></li>
								<li><a href="#Schedulers">Schedulers</a></li>
								<li><a href="#subscribeOn"><code>subscribeOn()</code></a></li>
								<li><a href="#publishOn"><code>publishOn()</code></a></li>
								<li><a href="#flatMapSequential"><code>flatMapSequential()</code></a></li>
								<li><a href="#parallel"><code>parallel()</code></a></li>
								<li><a href="#expand"><code>expand()</code></a></li>
								<li><a href="#Reactive-streams">Reactive streams</a></li>
								<li><a href="#Backpressure">Backpressure</a></li>
							</ul>
						</div>
						<div style="flex: 1">
							<ul>
								<li><a href="#WebFlux">WebFlux</a></li>
								<li><a href="#Littles-Law">Little's Law</a></li>
								<li><a href="#Netty">Netty</a></li>
								<li><a href="#WebClient">WebClient</a></li>
								<li><a href="#Refactoring">Refactoring toward Reactor</a></li>
								<li><a href="#Reactive-databases">Reactive databases</a></li>
								<li><a href="#ReactorDebugAgent">ReactorDebugAgent</a></li>
								<li><a href="#BlockHound">BlockHound</a></li>
								<li><a href="#When-to-use">When to use WebFlux?</a></li>
								<li><a href="#Micronaut">Micronaut</a></li>
								<li><a href="#Reference-materials">Reference materials</a></li>
							</ul>
						</div>
					</div>
				</small>
			</section>

			<section id="whoami">
				<h1><code>whoami</code></h1>
				<h2>Tomasz Nurkiewicz</h2>
				<h2>Java Champion</h2>
				<ul>
					<li>nurkiewicz (on GMail)</li>
					<li><a href="https:/nurkiewicz.com">nurkiewicz.com</a></li>
					<li><a href="https://nurkiewicz.com/podcast.html">My podcast</a></li>
					<li><a href="https://twitter.com/tnurkiewicz">@tnurkiewicz</a></li>
					<li><a href="https://www.linkedin.com/in/nurkiewicz/">LinkedIn</a></li>
				</ul>
			</section>

			<section>
				<h1>Disclaimer</h1>
				<p>
					These slides are rough notes I made during several 3-day <em><a href="https://github.com/nurkiewicz/reactor-workshop">Reactor and WebFlux</a></em> workshops. 
					They are not a complete tutorial by far.
					Many code snippets were written by hand.
				</p>
			</section>

			<section>
				<img src="https://pbs.twimg.com/media/D0CCesXWoAEIarZ?format=jpg" alt="I had a problem so I thought to use #Reactor. Now I have a Flux<Problem>"/>
				<p>
					<a href="https://twitter.com/tnurkiewicz/status/1099021813152124928">twitter.com/tnurkiewicz/status/1099021813152124928</a>
				</p>
			</section>

			<section id="Blocking-code">
				<h1>Blocking code</h1>
				<pre>
						<code class="hljs language-java" data-trim>
							//REST, DB, file system: 100ms, 200ms, 2s
							String s = blockingOp();
						</code>
					</pre>
			</section>

			<section id="Classic-future">
				<h1>Classic <code>Future</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
							String s1 = future1.get();  //poor practice
							String s2 = future1.get(1, SECONDS);
							boolean done = future1.isDone();							
						</code>
					</pre>
			</section>

			<section>
				<h1>Wait for first ü§¶‚Äç‚ôÇÔ∏è</h1>
				<pre>
						<code class="hljs language-java" data-trim>
								Future&lt;String&gt;     future1 = asyncOp1();
								Future&lt;BigDecimal&gt; future2 = asyncOp2();
								
								while(true) {
									if(future1.isDone()) {
										log.info(future1.get());
										break;
									} else {
										if(future2.isDone()) {
											log.info(future2.get());
											break;
										}
									}
									TimeUnit.MILLISECONDS.sleep(50);
								}
						</code>
					</pre>
			</section>

			<section id="CompletableFuture">
				<h1><code>CompletableFuture</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
								CompletableFuture&lt;String&gt;     future1 = asyncOp1();
								CompletableFuture&lt;BigDecimal&gt; future2 = asyncOp2();
								log.info("Done");
						</code>
					</pre>
			</section>

			<section>
				<h1>How to create <code>CompletableFuture</code></h1>
				<pre>
					<code class="hljs language-java" data-trim>
						CompletableFuture&lt;BlockingResult&gt; f = 
								CompletableFuture.supplyAsync(() -&gt; blockingOp())					
					</code>
				</pre>
				Watch out! <code>ForkJoinPool.commonPool()</code>
			</section>

			<section>
				<h1>Custom <code>ExecutorService</code></h1>
				<pre>
					<code class="hljs language-java" data-trim>
						Future&lt;BlockingResult&gt; x = executorService.submit(() -&gt; blockingOp());

						CompletableFuture&lt;BlockingResult&gt; f = 
							CompletableFuture.supplyAsync(() -&gt; blockingOp(), executorService);						
					</code>
				</pre>
			</section>

			<section>
				<pre>
						<code class="hljs language-java" data-trim>
							CompletableFuture&lt;String&gt;     future1 = asyncOp1();
							CompletableFuture&lt;BigDecimal&gt; future2 = asyncOp2();
							
							CompletableFuture&lt;Integer&gt; future3 = 
								future1.thenApply((String s) -&gt; s.length());
							
							CompletableFuture&lt;Double&gt; future4 = 
								future3.thenApply((int x) -&gt; x * 2.0d);
						</code>
					</pre>
			</section>

			<section>
				<h1>Wait for the first one</h1>
				<pre>
						<code class="hljs language-java" data-trim>
							CompletableFuture&lt;Object&gt; f =
								CompletableFuture.anyOf(future1, future2);
						</code>
					</pre>
			</section>

			<section id="Mono-and-Flux">
				<h1><code>Mono</code> and <code>Flux</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
							//‚âà CompletableFuture&lt;Optional&lt;T&gt;&gt;
							reactor.core.publisher.Mono&lt;T&gt; mono  

							//‚âà CompletableFuture&lt;List&lt;T&gt;&gt;
							reactor.core.publisher.Flux&lt;T&gt; flux  
						</code>
					</pre>
			</section>

			<section>
				<table>
					<thead>
						<tr>
						  <th>RxJava 2+</th>
						  <th>Reactor</th>
						  <th>Java 8+</th>
						</tr>
					  </thead>
					  <tbody>
						<tr>
							<td><code>Maybe&lt;T&gt;</code></td>
							<td><code>Mono&lt;T&gt;</code></td>
							<td>&nbsp;</td>
						</tr>
						<tr>
							<td><code>Single&lt;T&gt;</code></td>
							<td><code>Mono&lt;T&gt;</code></td>
							<td><code>CompletableFuture&lt;T&gt;</code></td>
						</tr>
						<tr>
							<td><code>Completable</code></td>
							<td><code>Mono&lt;Void&gt;</code></td>
							<td>&nbsp;</td>
						</tr>
						<tr>
							<td><code>Flowable&lt;T&gt;</code></td>
							<td><code>Flux&lt;T&gt;</code></td>
							<td>&nbsp;</td>
						</tr>
						<tr>
							<td><code>Observable&lt;T&gt;</code></td>
							<td><code>Flux&lt;T&gt;</code> w/o backpressure</td>
							<td>CompletableFuture&lt;List&lt;T&gt;&gt;<sup>*</sup></td>
						</tr>
					</tbody>
				</table>
			</section>

			<section id="Flux">
				<h1><code>Flux</code> vs Java's <code>Stream</code></h1>
				<ul>
					<li>You can subscribe to <code>Flux</code> multiple times</li>
					<li><code>parallelStream()</code> is a joke</li>
					<li>Much richer API in Reactor (<code>zip()</code>, <code>window()</code>, etc.)</li>
				</ul>
			</section>

			<section>
				<h1>Laziness</h1>
				<ul>
					<li>Default in Haskell</li>
					<li>In Kotlin: <code>lazy</code> / <code>lateinit</code></li>
					<li>In Vavr: <code>Lazy&lt;T&gt;</code></li>
				</ul>
			</section>

			<section>
				<h1><code>Flux</code></h1>
				<ul>
					<li>Asynchronous event stream</li>
					<li>May be infinite</li>
					<li>May terminate with success or error</li>
					<li>May be empty</li>
				</ul>
			</section>

			<section>
				<h1><code>Flux</code> use cases</h1>
				<ul>
					<li>Loading many records</li>
					<li>Streaming changes</li>
					<li>Event/command queue</li>
					<li>Infinite updates</li>
				</ul>
			</section>

			<section>
				<h1><code>Mono</code> vs. <code>CompletableFuture</code></h1>
				<ul>
					<li><code>Mono</code> is lazy</li>
					<li><code>Mono</code> can complete without an answer</li>
				</ul>
			</section>

			<section>
				<h1>4 aspects of <code>Mono</code></h1>
				<ul>
					<li>Asynchronous (see also: <a href="https://www.javadoc.io/static/io.vavr/vavr/0.10.4/io/vavr/concurrent/Future.html"><code>vavr.Future</code></a>)</li>
					<li>Optional (see also: <a href="https://javadoc.io/static/io.vavr/vavr/0.10.4/io/vavr/control/Option.html"><code>vavr.Option</code></a>)</li>
					<li>Lazy (see also: <a href="https://javadoc.io/doc/io.vavr/vavr/0.10.4/io/vavr/Lazy.html"><code>vavr.Lazy</code></a>)</li>
					<li>Risky (see also: <a href="https://www.javadoc.io/doc/io.vavr/vavr/0.10.4/io/vavr/control/Try.html"><code>vavr.Try</code></a>)</li>
				</ul>
			</section>

			<section>
				<h1><code>Mono</code> to <code>Flux</code></h1>
				<pre>
					<code class="hljs language-java" data-trim>
						Mono&lt;T&gt; mono;
						Flux&lt;T&gt; = mono.flux();
					</code>
				</pre>
			</section>

			<section>
				<h1><code>Flux</code> to <code>Mono</code></h1>
				<pre>
					<code class="hljs language-java" data-trim>
						Flux&lt;T&gt; flux;
						Mono&lt;List&lt;T&gt;&gt; mono = flux.collectList();
						Mono&lt;T&gt;      first = flux.next();
						Mono&lt;T&gt;       last = flux.last();
						Mono&lt;T&gt;       last = flux.single();
						Mono&lt;T&gt;       last = flux.singleOrEmpty();
						Mono&lt;T&gt;       last = flux.elementAt(n);
						Mono&lt;Long&gt;   count = flux.count();
						Mono&lt;T&gt;    reduced = flux.reduce();
					</code>
				</pre>
			</section>

			<section>
				<h1>History and ports</h1>
				<ul>
					<li><a href="https://dotnetfoundation.org/projects/reactive-extensions">Reactive Extensions for .NET</a></li>
					<li>RxJava</li>
					<li>RxScala</li>
					<li>RxPython</li>
					<li>RxSwift</li>
					<li>RxJS</li>
					<li>RxPHP</li>
				</ul>
			</section>

			<section id="Hot-cold">
				<h1>Hot vs. cold</h1>
				<p><code>publish()</code> / <code>connect()</code> / <code>autoConnect()</code>.</p>
			</section>

			<section id="block">
				<h1><code>block()</code></h1>
				<pre>
					<code class="hljs language-java" data-trim>
						Mono&lt;String&gt; mono;

						//DON'T!
						String s = mono.block();
					</code>
				</pre>
			</section>

			<section>
				<h1>Cardinality</h1>
				<code>Mono</code> and <code>Flux</code> can complete without result:
				<pre>
						<code class="hljs language-java" data-trim>
							Mono&lt;User&gt; findById(int id);
						</code>
					</pre>
			</section>

			<section>
				<section id="just">
					<h1><code>just()</code></h1>
					Antipattern:
					<pre>
						<code class="hljs language-java" data-trim data-line-numbers="1">
							Mono.just(restTemplate.getForEntity("/url"));
							nextOperation1();
							nextOperation2();
						</code>
					</pre>
				</section>

				<section>
					<h1><code>just()</code> in <code>zip()</code></h1>
					<pre>
						<code class="hljs language-java" data-trim>
							<script type="text/template">
								Mono<Tuple2<Request, Response>> tup = Mono.zip(
									Mono.just(request),
									monoResponse
								);
							</script>
						</code>
					</pre>
					Better:
					<pre>
						<code class="hljs language-java" data-trim>
							<script type="text/template">
								Mono<Tuple2<Request, Response>> tup = monoResponse
									.map(resp -> Tuples.of(request, response));
							</script>
						</code>
					</pre>
				</section>
			</section>
			
			<section id="defer">
				<h1><code>defer()</code></h1>
				Make eager things lazy:
				<pre>
					<code class="hljs language-java" data-trim>
						<script type="text/template">
							Mono.defer(() -> Mono.just(restTemplate.getForEntity("/url")));
						</script>
					</code>
				</pre>
				Better:
				<pre>
					<code class="hljs language-java" data-trim>
						<script type="text/template">
							Mono.fromCallable(() -> restTemplate.getForEntity("/url"));
						</script>
					</code>
				</pre>
			</section>

			<section>
				<section id="collectList">
					<h1><code>collectList()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Flux&lt;String&gt; flux;
								Mono&lt;List&lt;String&gt;&gt; list = flux.collectList();
							</code>
						</pre>
				</section>

				<section>
					<h1><code>collectList()</code></h1>
					<h2>Disadvantages</h2>
					<ul>
						<li>Must wait for the last element (completion)</li>
						<li>May lead to <code>OutOfMemoryError</code></li>
						<li>One exception throws out all elements</li>
						<li>Doesn't work with infinite streams</li>
					</ul>
				</section>

				<section id="buffering-operators">
					<h1>Operators that buffer extensively</h1>
					<ul>
						<li><code>buffer()</code></li>
						<li><code>cache()</code></li>
						<li><code>distinct()</code> (but not <code>distinctUntilChanged()</code>)</li>
						<li><code>collectList()</code></li>
						<li><code>collectMap()</code></li>
						<li><code>flatMapSequential()</code></li>
					</ul>
				</section>
			</section>

			<section id="map">
				<h1><code>map()</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
							OUTPUT fun(INPUT in)

							Flux&lt;INPUT&gt; flux;
							Flux&lt;OUTPUT&gt; result = flux.map(fun);
						</code>
					</pre>
			</section>

			<section>
				<h1>Operators are single-threaded</h1>
				<h2>Antipattern 1:</h2>
				(blocking <code>save</code>)
				<pre>
					<code class="hljs language-java" data-trim>
						users  //x1000
							.map(user -&gt; jpaRepository.save(user))
					</code>
				</pre>
				<h2>Antipattern 2:</h2>
				<pre>
					<code class="hljs language-java" data-trim>
						users  //x1000
							.subscribe(user -&gt; jpaRepository.save(user))
					</code>
				</pre>
			</section>


			<section>
				<section id="flatMap">
					<h1><code>flatMap()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Optional&lt;Integer&gt; tryParse(String s);
								
								Optional&lt;String&gt; s = Optional.of("42");
	
								Optional&lt;Optional&lt;Integer&gt;&gt; x = s.map(this::tryParse);
								
								Optional&lt;Integer&gt; y = s.flatMap(this::tryParse);
							</code>
						</pre>
				</section>

				<section>
					<h1><code>flatMap()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Stream&lt;Integer&gt; tryParse(String s);
								
								Stream&lt;String&gt; s = Stream.of("42");

								Stream&lt;Stream&lt;Integer&gt;&gt; x = s.map(this::tryParse);

								Stream&lt;Integer&gt; y = s.flatMap(this::tryParse);
							</code>
						</pre>
				</section>

				<section>
					<h1><code>flatMap()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								CompletableFuture&lt;Integer&gt; tryParse(String s);

								CompletableFuture&lt;String&gt; s = 
									CompletableFuture.completed("42");

								CompletableFuture&lt;CompletableFuture&lt;Integer&gt;&gt; x = 
									s.thenApply(this::tryParse);

								CompletableFuture&lt;Integer&gt; y = 
									s.thenCompose(this::tryParse);
							</code>
						</pre>
				</section>

				<section>
					<h1><code>flatMap()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Mono&lt;Integer&gt; tryParse(String s);
								
								Mono&lt;String&gt; s = Mono.just("42");
								
								Mono&lt;Mono&lt;Integer&gt;&gt; x = 
									s.map(this::tryParse);
								
								Mono&lt;Integer&gt; y = 
									s.flatMap(this::tryParse);
							</code>
						</pre>
				</section>

				<section>
					<h1><code>flatMap</code> = <code>map</code> + <code>merge</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Flux&lt;Integer&gt; userIds;  //Integer x1000

								Mono&lt;User&gt; loadUser(int id); //Mono&lt;User&gt; x1000
								
								Flux&lt;User&gt; x = userIds.flatMap(this::loadUser);
							</code>
						</pre>
				</section>

				<section>
					<h1><code>flatMap</code> pseudocode</h1>
					<pre>
							<code class="hljs language-java" data-trim>
								flatMap(f) {
									return merge(map(f));
								}
							</code>
						</pre>
				</section>
			</section>

			<section>
				<section id="zip">
					<h1><code>zip()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Mono&lt;Ads&gt; loadAds();
								Mono&lt;Article&gt; fetchArticle();
								Mono&lt;Header&gt; composeHeader();
								Mono&lt;Footer&gt; composeFooter();
								Mono&lt;Tags&gt; guessTags();
								Mono&lt;Next&gt; recommendNext();
							</code>
						</pre>
				</section>

				<section>
					<h1><code>zip()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Page makePage(Ads ads, Article article, Header header, 
												Footer footer, Tags tags, Next next);

								Mono&lt;Page&gt; x = Mono.zip(
									loadAds(),
									fetchArticle(),
									composeHeader(),
									composeFooter(),
									guessTags(),
									recommendNext(),
										(ads, art, head, foot, tags, next) -&gt; 
											makePage(ads, art, head, foot, tags, next)
								)

							</code>
						</pre>
				</section>

				<section>
					<h1><code>zip()</code></h1>
					Watch out for empty <code>Mono</code>!
					<pre>
							<code class="hljs language-java" data-trim data-line-numbers="6-8">
								Mono&lt;Page&gt; x = Mono.zip(
									loadAds(),
									fetchArticle(),
									composeHeader(),
									composeFooter(),
									guessTags()
										.switchIfEmpty(Mono.just(new Tags()))
										.timeout(ofMillis(500)),
									recommendNext(),
									this::makePage)

							</code>
						</pre>
				</section>

				<section>
					<h1>Asynchronous <code>zip()</code></h1>
					<pre>
						<code class="hljs language-java" data-trim>
							Mono&lt;Statement&gt; fooAsync(Order order, Customer customer);

							Mono&lt;Mono&lt;Statement&gt;&gt; x = Mono.zip(
									order, customer, 
									(Order o, Customer c) -&gt; fooAsync(o, c));
							
							Mono&lt;Statement&gt; x = Mono
									.zip(order, customer, (Order o, Customer c) -&gt; fooAsync(o, c))
									.flatMap(x -&gt; x);
							
						</code>
					</pre>
				</section>

				<section>
					<h1>Which thread runs after <code>zip()</code>?</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							<script type="text/template">
								Mono
										.zip(
												monoOnSchedulerA,
												monoOnSchedulerB
										)
										.doOnNext(whichThreadRunsMe?);
							</script>
						</code>
					</pre>
				</section>
			</section>

			<section id="timeout">
				<h1><code>timeout()</code></h1>
				<pre><code class="hljs language-java" data-trim>
					Mono&lt;Localization&gt; loc =
						Mono.fromCallable(() -&gt; slowGpsTracking())
								.timeout(ofSeconds(1),
										Mono.fromCallable(() -&gt; fastBtsTracking())
								);
				</code></pre>
			</section>

			<section id="onError">
				<h1><code>onError*()</code></h1>
				<pre>
					<code class="hljs language-java" data-trim data-line-numbers="|4,6">
						users
							.flatMap(user -&gt; 
								lastOrderOf(user)
									.onErrorReturn(Order.FAILED)
							)
							.onErrorReturn(Order.FAILED)
							.subscribe(order1, order2, FAILED, order4, order5, ...)
					</code>
				</pre>
			</section>

			<section id="filterWhen">
				<h1><code>filterWhen()</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;User&gt; users;

							Mono&lt;Boolean&gt; isVip(User user);
							
							users.filterWhen(this::isVip);
							users.filter(this::isVip);  //does not compile
						</code>
					</pre>
			</section>

			<section id="doOnSubscribe">
				<h1><code>doOnSubscribe()</code></h1>
				This is misleading:
				<pre>
						<code class="hljs language-java" data-trim>
							Mono&lt;Email&gt; sendEmail(String address) {
								log.info("Sending email to {}. O RLY?", address);  //this log lies
								return Mono.fromCallable(() -&gt; malingApi.send("...", address))
										.doOnSubscribe(s -&gt; log.info("Sending email to {}", address));
							}
						</code>
					</pre>
			</section>

			<section>
				<h1><code>doOnNext()</code></h1>
				<p>Equivalent to <code>Stream.peek()</code> in Java.</p>
				<p>Good for:</p>
				<ul>

				</ul>
			</section>

			<section>
				<section id="Side-effects">
					<h1>Side effects 1/5</h1>
					‚ùå Wrong:
					<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Article&gt; loadAndSaveArticles();
						</code>
					</pre>

					<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofMinutes(5))
								.subscribe(num -&gt; loadAndSaveArticles());
						</code>
					</pre>
				</section>

				<section>
					<h1>Side effects 2/5</h1>
					‚ùå Wrong:
					<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Article&gt; loadAndSaveArticles();
						</code>
					</pre>

					<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofMinutes(5))
								.doOnNext(num -&gt; loadAndSaveArticles())
								.subscribe();
						</code>
					</pre>
				</section>

				<section>
					<h1>Side effects 3/5</h1>
					‚ùå Wrong:
					<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Article&gt; loadAndSaveArticles();
						</code>
					</pre>

					<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofMinutes(5))
								.doOnNext(num -&gt; loadAndSaveArticles().blockLast())
								.subscribe();
						</code>
					</pre>
				</section>

				<section>
					<h1>Side effects 4/5</h1>
					‚ùå Wrong:
					<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Article&gt; loadAndSaveArticles();
						</code>
					</pre>

					<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofMinutes(5))
								.doOnNext(num -&gt; loadAndSaveArticles().subscribe())
								.subscribe();
						</code>
					</pre>
				</section>

				<section>
					<h1>Side effects 5/5</h1>
					‚úÖ Correct:
					<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Article&gt; loadAndSaveArticles();
						</code>
					</pre>

					<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofMinutes(5))
								.flatMap(n -&gt; loadAndSaveArticles())
								.subscribe();
							
						</code>
					</pre>
				</section>
			</section>

			<section id="window">
				<h1><code>window()</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Email&gt; emailsToSend;

							Mono&lt;Result&gt; send(Email email);
							
							Flux&lt;Result&gt; x = emailsToSend.flatMap(this::send);
						</code>
					</pre>
			</section>

			<section>
				<h1>Run all</h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Result&gt; sendMany(List&lt;Email&gt; emails);

							Flux&lt;Result&gt; results = emailsToSend.collectList()
								.flatMap(list -&gt; sendMany(list));
						</code>
					</pre>
			</section>

			<section>
				<h1>Run in batches (<code>buffer()</code>)</h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Result&gt; sendMany(List&lt;Email&gt; emails);

							Flux&lt;List&lt;Email&gt;&gt; batches = emailsToSend.buffer(100);
							batches.flatMap(this::sendMany);
						</code>
					</pre>
			</section>

			<section>
				<h1>Run in batches (<code>window()</code>)</h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux&lt;Result&gt; sendMany(List&lt;Email&gt; emails);

							Flux&lt;Flux&lt;Email&gt;&gt; batches2 = emailsToSend.window(100);
							batches2.flatMap(
									(Flux&lt;Email&gt; batch) -&gt; batch.collectList()
										.flatMap(batchList -&gt; sendMany(batchList)));
						</code>
					</pre>
			</section>

			<section>

				<section>
					<h1><code>window()</code> vs. <code>buffer</code></h1>
					<pre>
						<code class="hljs language-java" data-trim>
							flux
								.window(Duration.ofSeconds(1))
								.flatMap(Flux::count);
						</code>
					</pre>
					vs.
					<pre>
						<code class="hljs language-java" data-trim>
							flux
								.buffer(Duration.ofSeconds(1))
								.map(List::size);
						</code>
					</pre>
				</section>

				<section>
					<h1><code>window()</code></h1>
					<img src="reactor-workshop/window.jpeg" alt="window()" class="r-stretch">
				</section>

				<section>
					<h1><code>buffer()</code></h1>
					<img src="reactor-workshop/buffer.jpeg" alt="buffer()" class="r-stretch">
				</section>

			</section>

			<section id="interval">
				<h1><code>interval()</code></h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofHours(3))
								.subscribe(x -&gt; everyThreeHours());
						</code>
					</pre>
			</section>

			<section>
				<h1>Better</h1>
				<pre>
						<code class="hljs language-java" data-trim>
							Flux
								.interval(ofHours(3))
								.flatMap(x -&gt; everyThreeHours())
								.subscribe();
						</code>
					</pre>
			</section>

			<section>
				<h1>Alternatives</h1>
				<ul>
					<li>Quartz scheduler</li>
					<li><code>@Scheduled</code> in Spring</li>
				</ul>
			</section>

			<section id="Schedulers">
				<h1>Schedulers</h1>
				<dl>
					<dt>newBoundedElastic()</dt>
					<dd>elastic, limited pool</dd>					
					<dt>newParallel()</dt>
					<dd>CPU workloads</dd>					
					<dt>boundedElastic()</dt>
					<dd>singleton, don't use in production</dd>					
					<dt>paralell()</dt>
					<dd>used by Reactor itself, don't use</dd>
				</dl>
			</section>

			<section id="subscribeOn">
				<h1><code>subscribeOn()</code></h1>
				<pre>
					<code class="hljs language-java" data-trim data-line-numbers="|2-4|5-6|7-8|9-10|11-12">
						Mono
							.fromCallable(() -&gt; reliable.findBlocking(41))
							.subscribeOn(Schedulers.newBoundedElastic(10, 100, "A"))
							.doOnNext(x -&gt; log.info("Received {}", x))
							.publishOn(Schedulers.newBoundedElastic(10, 100, "B"))
							.map(x -&gt; ...)
							.publishOn(Schedulers.newBoundedElastic(10, 100, "C"))
							.filter(x -&gt; ...)
							.publishOn(Schedulers.newBoundedElastic(10, 100, "D"))
							.doOnNext(x -&gt; log.info("Still here {}", x))
							.publishOn(Schedulers.newBoundedElastic(10, 100, "E"))
							.subscribe(x -&gt; log.info("Finally received {}", x));
					</code>
				</pre>
			</section>

			<section>
				<h1>What's wrong here?</h1>
				<pre>
					<code class="hljs language-java" data-trim>
						domains
								.flatMap(domain -&gt;
										download(domain) //Mono
												.subscribeOn(newBoundedElastic(50, 1000, "Crawler"))
								);
					</code>
				</pre>
			</section>

			<section>
				<section id="publishOn">
					<h1><code>publishOn()</code></h1>
					‚ùå Wrong (<code>map</code> is long-running):
					<pre>
						<code class="hljs language-java" data-trim data-line-numbers="3">
							result
								.map(result -> result.getId())
								.map(id -> cpuIntensive(id))
						</code>
					</pre>
				</section>

				<section>
					<h1><code>publishOn()</code></h1>
					‚ùå Wrong (<code>map</code> is single-threaded anyway):
					<pre>
						<code class="hljs language-java" data-trim data-line-numbers="4">
							result
								.map(result -> result.getId())
								.publishOn(cpuScheduler)
								.map(id -> cpuIntensive(id))
						</code>
					</pre>
				</section>

				<section>
					<h1><code>publishOn()</code></h1>
					‚úÖ Correct:
					<pre>
						<code class="hljs language-java" data-trim data-line-numbers="4">
							result
								.map(result -> result.getId())
								.flatMap(id -> Mono.fromCallable(() -> 
										cpuIntensiveAsync(id))
												.subscribeOn(cpuScheduler)
								)
						</code>
					</pre>
				</section>

				<section>
					<h1>Weird behaviour of <code>publishOn()</code></h1>
					<pre>
						<code class="hljs language-java" data-trim>
							<script type="text/template">
								Mono
										.fromRunnable(() -> System.out.println(Thread.currentThread().getName()))
										.doOnNext(e -> {})  //remove this or use hide()
										.publishOn(Schedulers.boundedElastic())
							</script>
						</code>
					</pre>
					<a href="https://github.com/reactor/reactor-core/issues/1810"><code>Mono.fromCallable()</code> and <code>publishOn()</code></a>
				</section>
			</section>

			<section>
				<h1><code>flatMap()</code></h1>
				<pre>
					<code class="hljs language-txt" data-trim>
						-- G - Y - F ---------------------------------------> (t)
						   |   |   |
						   +--------------------------------------|
						       +---------|
						           +--------------------|

						---------------- Y.html ------- F.html -- G.html ---> (t)
					</code>
				</pre>
			</section>

			<section>
				<section id="flatMapSequential">
					<h1><code>flatMapSequential()</code></h1>
					<pre>
						<code class="hljs language-txt" data-trim>
							-- G - Y - F ---------------------------------------> (t)
							   |   |   |
							   +--------------------------------------|
							       +---------|........................
							           +--------------------|.........
						
							----------------------------------------- G.html Y.html F.html ---> (t)
						</code>
					</pre>
				</section>

				<section>
					<h1><code>flatMapSequential()</code></h1>
					<pre>
							<code class="hljs language-java" data-trim>
								Mono&lt;LargeImage&gt; download(URL url);

								Flux&lt;URL&gt; thousandUrls;
								
								Flux&lt;LargeImage&gt; x = thousandUrls.flatMapSequential(this::download);
							</code>
						</pre>
				</section>

				<section>
					<h1><code>flatMapSequential()</code></h1>
					<p>What if the first element fails?</p>
					<p>See: <code>flatMapSequentialDelayError()</code></p>
				</section>
			</section>

			<section>
				<h1><code>concatMap</code></h1>
				<p>Basically equivalent to</p>
				<pre>
					<code class="hljs language-java" data-trim>
						<script type="text/template">
							flatMap(f, 1)
						</script>
					</code>
				</pre>
			</section>

			<section>
				<section id="parallel">
					<h1><code>parallel()</code></h1>
					<pre>
						<code class="hljs language-txt" data-trim>
													+ -- A D ...
												/
							---- A B C D E F ... -+ ---- B E ...
												\
													+ -- C F ...					
						</code>
					</pre>
				</section>

				<section>
					<h1><code>parallel()</code></h1>
					From:
					<pre>
						<code class="hljs language-java" data-trim>
							flux
								.flatMap(x -&gt; 
										Mono.fromCallable(() -&gt; blockingOperation(x))
											.subscribeOn(scheduler))
						
						</code>
					</pre>
				</section>
				
				<section>
					<h1><code>parallel()</code></h1>
					To (incomplete):
					<pre>
						<code class="hljs language-java" data-trim>
							flux
								.parallel(3)
								.map(x -> blockingOperation(x))
						</code>
					</pre>
				</section>
			</section>
			
			<section id="expand">
				<h1><code>expand()</code></h1>
				<pre>
					<code class="hljs language-java" data-trim>
						Flux&lt;File&gt; listFiles(File parent);

						Flux&lt;File&gt; start = Flux.just(new File("/"));
						
						Flux&lt;File&gt; files = start.flatMap(this::listFiles);
						
						Flux&lt;File&gt; files = start.expand(this::listFiles);
					</code>
				</pre>
			</section>

			<section>
				<h1>SSE</h1>
				<pre>
					<code class="hljs" data-trim>
						curl 'https://api.twitter.com/live_pipeline/events?topic=%2Ftweet_engagement%2F012345678901234567890' \
						-H 'authority: api.twitter.com' \
						-H 'accept: text/event-stream'
								data: {"topic":"/system/config","payload":{"config":{"session_id":"...","subscription_ttl_millis":120000,"heartbeat_millis":25000}}}
								data: {"topic":"/system/subscriptions","payload":{"subscriptions":{"errors":[]}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"retweet_count":"20"}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"like_count":"30"}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"retweet_count":"21"}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"retweet_count":"22"}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"quote_count":"1"}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"like_count":"30"}}}
								data: {"topic":"/tweet_engagement/012345678901234567890","payload":{"tweet_engagement":{"retweet_count":"23"}}}
						</code>
					</pre>
			</section>

			<section id="Reactive-streams">
				<h1>Reactive streams</h1>
				<p>
					Implementations:
				</p>
				<ul>
					<li>RxJava 2+</li>
					<li>Reactor</li>
					<li>Akka Streams</li>
					<li>Vert.x</li>
					<li>Smallrye Mutiny</li>
					</ul>
			</section>

			<section>
				<section id="Backpressure">
					<h1>Backpressure</h1>
					<p>Sources you can't slow down:</p>
					<ul>
						<li><code>Flux.interval()</code></li>
						<li>Mouse moves (!)</li>
						<li>Network packets (?)</li>
					</ul>
				</section>

				<section>
					<h1>Ignoring backpressure</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							<script type="text/template">
								Flux.create(sink -> {
									while(!sink.isDisposed()) {
										sink.next(Math.random())
									}
								})

							</script>
						</code>
					</pre>
				</section>

				<section>
					<h1>Improved</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							<script type="text/template">
								Flux.generate(sink -> sink.next(Math.random());
							</script>
						</code>
					</pre>
				</section>

				<section>
					<h1>Missing backpressure</h1>
					<pre>
						<code class="hljs language-txt" data-trim>
							reactor.core.Exceptions$OverflowException: 
							Could not emit tick 256 due to lack of requests 
							(interval doesn't support small downstream requests that replenish slower than the ticks)
						</code>
					</pre>
				</section>

			</section>

			<section id="WebFlux">
				<h1>WebFlux</h1>
			</section>

			<section>
				<h1>Terminology</h1>

				<dl>
					<dt>blocking</dt>
					<dl>
						waits for a function to return. E.g. <code>RestTemplate.getForEntity()</code>, <code>Socket.read()</code>.
						See also <a href="https://github.com/Playtika/feign-reactive">Playtika/feign-reactive</a>
					</dl>

					<dt>asynchronous</dt>
					<dl>happens in background, probably in another thread. E.g. <code>CompletableFuture</code>, <code>AsyncRestTemplate</code></dl>
	
					<dt>non-blocking</dt>
					<dl>Event-driven, does not block any thread. E.g. Netty, <code>WebClient</code></dl>
	
					<dt>reactive</dt>
					<dl><em>asynchronous</em>, rather <em>non-blocking</em>, streaming, backpressure-aware</dl>
				</dl>
			</section>

			<section>
				<h1>Terminology</h1>

				<dl>
					<dt>concurrent</dt>
					<dl>threads preemptied, sharing the same core, not really running at the same time</dl>

					<dt>parallel</dt>
					<dl>thread running at the same time, on different cores/CPUs</dl>
				</dl>
			</section>

			<section id="Littles-Law">
				<h1>Little's Law</h1>
				Thread per request
				<table>
					<thead>
						<tr>
							<th>Threads</th>
							<th>Avg. resp.</th>
							<th>rps</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>1</td>
							<td>0.2s</td>
							<td>5</td>
						</tr>
						<tr>
							<td>100</td>
							<td>0.5s</td>
							<td>200</td>
						</tr>
						<tr>
							<td>100</td>
							<td>0.1s</td>
							<td>1000</td>
						</tr>
						<tr>
							<td>200</td>
							<td>0.2s</td>
							<td>1000</td>
						</tr>
						<tr>
							<td>100</td>
							<td>2.0s</td>
							<td>50</td>
						</tr>
						<tr>
							<td>2000</td>
							<td>2.0s</td>
							<td>1000</td>
						</tr>
					</tbody>
				</table>
			</section>

			<section id="Netty">
				<h1>Netty</h1>
				<h2>Netty ‚û° <code>reactor-netty</code> ‚û° WebFlux</h2>
				<ul>
					<li><a href="https://javamana.com/2021/10/20211016002303128r.html">Single machine million connection tuning and netty application level tuning</a></li>
					<li><a href="https://blog.krybot.com/a?ID=01800-fa002631-e651-4994-b3d8-3e62ac4f480c">1 million concurrent connection server notes how will Java Netty handle 1M connections</a></li>
				</ul>
			</section>

			<section id="WebClient">
				<h1><code>WebClient</code></h1>
				<dl>
					<dt><code>WebClient</code></dt>
					<dd>Non-blocking, uses Netty underneath</dd>
					<dt><code>RestTemplate</code></dt>
					<dd>Blocking, in <em>maintenance</em> mode</dd>
					<dt><code>AsyncRestTemplate</code></dt>
					<dd>Deprecated, wraps <code>RestTemplate</code> with a thread pool</dd>
				</dl>
			</section>

			<section>
				<section id="Refactoring">
					<h1>Refactoring toward Reactor</h1>
					<h2>Step 0:</h2>
					<pre>
						<code class="hljs language-java" data-trim>
							Person p = db.query();
							User u = rest.get();
						</code>
					</pre>
				</section>

				<section>
					<h1>Step 1:</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							Person p = Mono.fromCallable(() -&gt; db.query())
										.subscribeOn(myScheduler)
										.block(ofMillis(500));
							User u = Mono.fromCallable(() -&gt; rest.get())
										.subscribeOn(myScheduler)
										.block(ofMillis(500));
						</code>
					</pre>
				</section>

				<section>
					<h1>Step 2:</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							Person p = db.queryAsync()
										.block(ofMillis(500));
							User u = rest.getAsync()
										.block(ofMillis(500));
						</code>
					</pre>
				</section>

				<section>
					<h1>Step 3:</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							Tuple2&lt;Person, User&gt; t = Mono.zip(
								db.queryAsync(),
								rest.getAsync()
							).block(ofMillis(500));
						</code>
					</pre>
				</section>

				<section>
					<h1>Step 4:</h1>
					<pre>
						<code class="hljs language-java" data-trim>
							return Mono.zip(
								db.queryAsync(),
								rest.getAsync()
							);
						</code>
					</pre>
				</section>
			</section>

			<section id="Reactive-databases">
				<h1>Reactive databases</h1>
				<ul>
					<li><a href="https://docs.mongodb.com/drivers/reactive-streams/">MongoDB</a></li>
					<li>Cassandra</li>
					<li><a href="https://docs.couchbase.com/java-sdk/current/howtos/concurrent-async-apis.html">Couchbase</a></li>
					<li><a href="https://spring.io/guides/gs/spring-data-reactive-redis/">Redis</a></li>
					<li>SQL (via <a href="https://r2dbc.io/">R2DBC</a> - reactive relational database access)
						<ul>
							<li><a href="https://github.com/r2dbc/r2dbc-h2">H2</a></li>
							<li><a href="https://github.com/mariadb-corporation/mariadb-connector-r2dbc">MariaDB</a></li>
							<li><a href="https://github.com/r2dbc/r2dbc-mssql">Microsoft SQL Server</a></li>
							<li><a href="https://github.com/mirromutth/r2dbc-mysql">MySQL</a></li>
							<li><a href="https://github.com/jasync-sql/jasync-sql">jasync-sql MySQL</a></li>
							<li><a href="https://github.com/pgjdbc/r2dbc-postgresql">Postgres</a></li>
							<li><a href="https://github.com/oracle/oracle-r2dbc">Oracle</a></li>
						</ul>
					</li>
				</ul>
			</section>

			<section>
				<h1>Transactions</h1>
				<ul>
					<li>
						<a href="https://spring.io/blog/2019/05/16/reactive-transactions-with-spring">
							Reactive Transactions with Spring
						</a>
					</li>
					<li>
						<a href="https://www.vinsguru.com/spring-data-r2dbc-transaction/">Spring Data R2DBC Transaction</a>
					</li>
				</ul>
			</section>

			<section>
				<h1>Reactive MongoDB</h1>
				<pre>
					<code class="hljs language-java" data-trim data-line-numbers="|5">
						//finite
						Flux&lt;Document&gt; findAll();
						
						//infinite
						@Tailable
						Flux&lt;Document&gt; streamAll();
						
					</code>
				</pre>
			</section>

			<section id="ReactorDebugAgent">
				<h1>ReactorDebugAgent</h1>
				<pre>
					<code class="hljs language-java" data-trim>
						import reactor.tools.agent.ReactorDebugAgent;

						@BeforeClass
						public static void setup() {
							ReactorDebugAgent.init();
							ReactorDebugAgent.processExistingClasses();
						}
		
					</code>
				</pre>
			</section>

			<section id="BlockHound">
				<h1>BlockHound</h1>
				<pre>
					<code class="hljs language-java" data-trim>
						Flux
								.interval(Duration.ofMillis(10), Schedulers.parallel())
								.map(x -&gt; {
									TimeUnit.SECONDS.sleep(1);
									return x;
								})
					</code>
				</pre>
			</section>

			<section id="When-to-use">
				<h1>When to use WebFlux?</h1>
				<ul>
					<li>proxy/gateway/edge/API mashup type of services</li>
					<li>Backend for frontend</li>
					<li>crawler, fetching data from tons of sources</li>
					<li>ETL, batch processing</li>
					<li>A <strong>lot</strong> of open connections (WebSocket, SSE)</li>
					<li>A <strong>lot</strong> of traffic</li>
				</ul>
			</section>

			<section id="Micronaut">
				<h1>Micronaut</h1>
				<blockquote cite="https://docs.micronaut.io/latest/guide/#reactiveResponses">
					When returning a reactive type, Micronaut subscribes to the returned reactive type on the same thread as the request (a Netty Event Loop thread).
					[...] if you perform any blocking operations, you offload those operations to an appropriately configured thread pool, for example using the <a href="https://projectreactor.io">Project Reactor</a> [...] 
					<code>subscribeOn(..)</code> facility or <a href="../api/io/micronaut/scheduling/annotation/ExecuteOn.html">@ExecuteOn</a>.
				</blockquote>
			</section>

			<section>
				<h1>Performance benchmarking</h1>
				<ul>
					<li>JMeter</li>
					<li>Gatling</li>
					<li><code>ab</code></li>
					<li><code>wrk</code> and <code>wrk2</code></li>
				</ul>
			</section>

			<section id="Reference-materials">
				<h1>Reference materials</h1>
				<ul>
					<li><a href="http://www.flatmapthatshit.com/">Flat map that shit</a></li>
					<li><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What Color is Your Function?</a></li>
					<li><a href="https://www.techempower.com/benchmarks/">Web framework benchmarks</a></li>
				</ul>
			</section>

			<section>
				<h1>Beyond</h1>
				<ul>
					<li><a href="https://wiki.openjdk.java.net/display/loom/Main">Project Loom</a></li>
					<li><a href="https://www.youtube.com/watch?v=n_XRUljffu0">Project Loom: Revolution in concurrency or obscure implementation detail?</a></li>
				</ul>
			</section>

			<section id="Coroutines">
				<h1>Coroutines</h1>
				<ul>
					<li><a href="https://kotlinlang.org/docs/flow.html#flows">Kotlin flows</a></li>
					<li><a href="https://blog.frankel.ch/reactor-to-coroutines/">From Reactor to Coroutines</a></li>
					<li><a href="https://www.youtube.com/watch?v=YJV-3WNXG1s">Coroutines and Reactive Programming - friends or foes ‚Äì Konrad Kami≈Ñski</a></li>
				</ul>
		</section>

			<section>
				<h1>Miscellaneous</h1>
				<ul>
					<li><a href="https://gist.github.com/jboner/2841832">Latency Numbers Every Programmer Should Know</a></li>
				</ul>
			</section>

			<section>
				<h1>My articles</h1>
				<ul>
					<li><a href="https://nurkiewicz.com/2021/08/json-streaming-in-webflux.html">3 techniques to stream JSON in Spring WebFlux</a></li>
					<li><a href="https://nurkiewicz.com/2021/08/onerrorcontinue-reactor.html">When and how to use onErrorContinue(): Reactor FAQ</a></li>
					<li><a href="https://nurkiewicz.com/2015/11/which-thread-executes.html">Which thread executes CompletableFuture‚Äôs tasks and callbacks?</a></li>
				</ul>
			</section>
				
			<section>
				<h1>Presentations</h1>
				<ul>
					<li><a href="https://www.youtube.com/watch?v=MkdwriQAllk">Flight of the Flux: a look at Reactor's execution model by Simon Basl√©</a></li>
					<li><a href="https://www.youtube.com/watch?v=5TJiTSWktLU">JDD 2018: Reactive programming: lessons
							learned by Tomasz Nurkiewicz</a></li>
				</ul>
			</section>

			<section>
				<h1>Other tools</h1>
				<ul>
					<li><a href="https://rsocket.io/">RSocket</a></li>
					<li><a href="https://resilience4j.readme.io/docs/getting-started-1">resilience4j-reactor</a></li>
					<li><a href="https://r2dbc.io/">R2DBC</a> - reactive relational database access</li>
					<li><a href="https://rxmarbles.com">RxMarbles</a></li>
					<li><a href="https://rxviz.com/">Rx Vizualize</a></li>
					<li><a href="https://github.com/reactor/BlockHound">BlockHound</a></li>
					<li><a href="https://github.com/electronicarts/ea-async">electronicarts/ea-async</a></li>
				</ul>
			</section>

		</div>

	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/search/search.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		Reveal.initialize({
			hash: true,
			plugins: [RevealHighlight, RevealSearch],
			width: 2500,
			margin: 0.02,
			transition: 'fade',
			progress: true,
			controls: true,
			center: false,
			slideNumber: 'c/t',
		});
	</script>

</body>

</html>